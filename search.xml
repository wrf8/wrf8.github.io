<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jenkins --- iOS自动化打包</title>
      <link href="posts/1870901654.html"/>
      <url>posts/1870901654.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>此篇文章是以 <code>Jenkins</code>安装包 + <code>java8</code>安装包组成的环境进行的。</p><h2 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2. 插件安装"></a>2. 插件安装</h2><p>Jenkins安装完成，并且基本设置做好后。我们需要安装一些插件：</p><ul><li>Xcode integration</li><li>Keychains and Provisioning Profiles Management</li></ul><h3 id="2-1-系统管理"><a href="#2-1-系统管理" class="headerlink" title="2.1 系统管理"></a>2.1 系统管理</h3><p>首页的左侧，点击 <code>系统管理</code>:<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86.png" alt="系统管理"></p><h3 id="2-2-插件管理"><a href="#2-2-插件管理" class="headerlink" title="2.2 插件管理"></a>2.2 插件管理</h3><p>在系统管理页面找到 <code>插件管理</code>:<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86.png" alt="插件管理"></p><h3 id="2-3-安装插件"><a href="#2-3-安装插件" class="headerlink" title="2.3 安装插件"></a>2.3 安装插件</h3><ul><li>搜索插件安装<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%90%9C%E7%B4%A2%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.png"></li><li>本地上传插件安装，点击 <code>高级</code> -&gt; <code>上传插件</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6.png"></li></ul><h2 id="3-系统设置"><a href="#3-系统设置" class="headerlink" title="3. 系统设置"></a>3. 系统设置</h2><h3 id="3-1-钥匙串权限、-Library权限以及电脑用户管理权限"><a href="#3-1-钥匙串权限、-Library权限以及电脑用户管理权限" class="headerlink" title="3.1 钥匙串权限、~/Library权限以及电脑用户管理权限"></a>3.1 钥匙串权限、~/Library权限以及电脑用户管理权限</h3><h4 id="3-1-1-MobileDevice"><a href="#3-1-1-MobileDevice" class="headerlink" title="3.1.1 MobileDevice"></a>3.1.1 MobileDevice</h4><p>将 <code>/Users/用户名/Library</code> 的 <code>MobileDevice</code> 文件夹拷贝到 <code>/Users/Shared/Jenkins/Library</code>下</p><blockquote><p>注意：是将 <code>MobileDevice</code> 这个文件夹拷贝过去，而不是 <code>MobileDevice</code> 里的文件，<code>/Users/Shared/Jenkins/Library</code> 目录下是没有 <code>MobileDevice</code> 这个文件夹，所以先创建一个 <code>MobileDevice</code>文件夹。</p></blockquote><pre><code>sudo mkdir /Users/Shared/Jenkins/Library/MobileDevicesudo cp -r /Users/xxx/Library/MobileDevice/ /Users/Shared/Jenkins/Library/MobileDevice/</code></pre><h4 id="3-1-2-Keychains"><a href="#3-1-2-Keychains" class="headerlink" title="3.1.2 Keychains"></a>3.1.2 Keychains</h4><p>将 <code>/Users/用户名/Library/Keychains/</code> 下的 <code>login.keychain-db</code>文件拷贝到 <code>/Users/Shared/Jenkins/Library/Keychains</code> 文件夹下面</p><pre><code>cd /Users/Shared/Jenkins/Library/sudo mkdir Keychainssudo cp /Users/xxx/Library/Keychains/login.keychain-db ./Keychains/</code></pre><p>再将这个 <code>login.keychain-db</code> 拷贝到桌面上一份，将文件后缀改为 <code>.keychain</code></p><h4 id="3-1-3-钥匙串权限"><a href="#3-1-3-钥匙串权限" class="headerlink" title="3.1.3 钥匙串权限"></a>3.1.3 钥匙串权限</h4><p>打开钥匙串，找到相应的证书：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E8%AF%81%E4%B9%A6.png"><br>右键密钥显示简介，在访问控制那一项里勾选允许所有应用程序访问此项目，并存储更改<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E8%AF%81%E4%B9%A6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png"></p><h4 id="3-1-4-Library权限"><a href="#3-1-4-Library权限" class="headerlink" title="3.1.4 ~/Library权限"></a>3.1.4 ~/Library权限</h4><ol><li>进入mac系统偏好设置 — 用户与群组 — 其他用户 — jenkins ，勾选允许用户管理这台电脑，并右键选择高级选项，将名字改为jenkins<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AEjenkins%E7%94%A8%E6%88%B7.png"><blockquote><p>Jenkins 安装成功之后，会自动创建一个用户，该用户没有名字</p></blockquote></li></ol><p>找到 <code>Library</code> 资源库文件夹，设置共享与访问权限，everyone读与写都可以<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_library%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png"></p><h3 id="3-2-配置-Keychains-and-Provisioning-Profiles-Management"><a href="#3-2-配置-Keychains-and-Provisioning-Profiles-Management" class="headerlink" title="3.2 配置 Keychains and Provisioning Profiles Management"></a>3.2 配置 <code>Keychains and Provisioning Profiles Management</code></h3><p>插件安装完成后回到系统管理页面进行 <code>Keychains and Provisioning Profiles Management</code> 配置<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png"><br>选取拷贝到桌面的 <code>login.keychain</code> 文件以及相对应的 <code>Provisioning Profile</code> 文件，并upload</p><blockquote><p>注意：开发证书和 Provisioning profile 一定要对应正确，不然命令行打包会认证不了而失败</p></blockquote><h4 id="3-2-1-设置-Keychains"><a href="#3-2-1-设置-Keychains" class="headerlink" title="3.2.1 设置 Keychains"></a>3.2.1 设置 Keychains</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E8%AE%BE%E7%BD%AE.png"></p><ul><li><code>Filename</code>: 直接就是 <code>login.keychain</code></li><li><code>Password</code>: 钥匙串密码</li><li><code>Code Signing Identity</code>: 证书名称（PS：这里可以填写多个证书名称，一般开发和生产2个就够了）。可在钥匙串中找到证书，直接复制名称进行粘贴）</li></ul><h4 id="3-2-2-设置-Provisioning-Profiles"><a href="#3-2-2-设置-Provisioning-Profiles" class="headerlink" title="3.2.2 设置 Provisioning Profiles"></a>3.2.2 设置 Provisioning Profiles</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p><h2 id="4-项目新建和设置"><a href="#4-项目新建和设置" class="headerlink" title="4.项目新建和设置"></a>4.项目新建和设置</h2><h3 id="4-1-新建任务"><a href="#4-1-新建任务" class="headerlink" title="4.1 新建任务"></a>4.1 新建任务</h3><p>点击首页 <code>新建任务</code>，然后选择 <code>构建一个自由风格的软件项目</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA.png"><br>在通用选项里可进行一些描述信息填写和构建包丢弃计划（非必要设置）<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE.png"></p><h3 id="4-2-源码管理"><a href="#4-2-源码管理" class="headerlink" title="4.2 源码管理"></a>4.2 源码管理</h3><p>以 <code>Git</code> 为例，在源码管理中填写项目Git地址、相关密钥信息（https账户密码或ssh密钥）、指定分支名称<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86.png"><br>如果 <code>Credentials</code> 设置为 <code>无</code> 的话，会报错：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%BA%90%E7%A0%81%E4%BB%93%E5%BA%93%E6%9D%83%E9%99%90%E6%8A%A5%E9%94%99.png"><br>面板点击添加来设置 <code>SSH</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%B7%BB%E5%8A%A0SSH.png"></p><blockquote><p>私钥查看命令:</p><pre><code>$ cat ~/.ssh/id_rsa</code></pre><p>私钥填写包含 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code> 和 <code>-----END OPENSSH PRIVATE KEY-----</code></p></blockquote><h3 id="4-3-构建触发器"><a href="#4-3-构建触发器" class="headerlink" title="4.3 构建触发器"></a>4.3 构建触发器</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><h3 id="4-4-构建环境"><a href="#4-4-构建环境" class="headerlink" title="4.4 构建环境"></a>4.4 构建环境</h3><p>选择 <code>Keychains andProvisioning Profiles Management</code> 和 <code>Mobile Provisioning Profiles</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83.png"></p><h3 id="4-5-构建"><a href="#4-5-构建" class="headerlink" title="4.5 构建"></a>4.5 构建</h3><h4 id="4-5-1-Shell"><a href="#4-5-1-Shell" class="headerlink" title="4.5.1 Shell"></a>4.5.1 Shell</h4><p>来到构建选项，先选择添加 <code>执行shell</code>，因为要通过 <code>shell</code> 先执行 <code>pod install</code>操作，当然如果你没有使用 <code>cocoapods</code> 或者你直接把第三方库文件都放在git的话可以忽略这一步<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%9E%84%E5%BB%BA%E6%89%A7%E8%A1%8CShell.png"><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1Shell%E5%86%85%E5%AE%B9.png"></p><h4 id="4-5-2-XCode"><a href="#4-5-2-XCode" class="headerlink" title="4.5.2 XCode"></a>4.5.2 XCode</h4><h4 id="4-5-3-General-build-settings"><a href="#4-5-3-General-build-settings" class="headerlink" title="4.5.3 General build settings"></a>4.5.3 General build settings</h4><h4 id="4-5-4-Code-signing-amp-OS-X-keychain-options"><a href="#4-5-4-Code-signing-amp-OS-X-keychain-options" class="headerlink" title="4.5.4 Code signing &amp; OS X keychain options"></a>4.5.4 Code signing &amp; OS X keychain options</h4><h4 id="4-5-5-Advanced-Xcode-build-options"><a href="#4-5-5-Advanced-Xcode-build-options" class="headerlink" title="4.5.5 Advanced Xcode build options"></a>4.5.5 Advanced Xcode build options</h4><h2 id="5-问题集锦"><a href="#5-问题集锦" class="headerlink" title="5.问题集锦"></a>5.问题集锦</h2><h3 id="5-1-pod-command-not-found"><a href="#5-1-pod-command-not-found" class="headerlink" title="5.1 pod: command not found"></a>5.1 <code>pod: command not found</code></h3><pre><code>$ /bin/sh -xe /Users/Shared/Jenkins/tmp/hudson6502897316694164242.sh+ pod install --verbose --no-repo-update/Users/Shared/Jenkins/tmp/hudson6502897316694164242.sh: line 2: pod: command not foundBuild step &#39;Execute shell&#39; marked build as failure</code></pre><p>出现这个问题可能是因为你没有设置pod的运行路径，解决方法如下：</p><ol><li>打开Jenkins，然后在Jenkins左侧的菜单中找到<strong>系统管理—&gt;系统设置—&gt;全局属性</strong>，然后找到 <code>Environment variables</code>（中文：环境变量）并且勾选。</li><li>打开终端，在终端中输入 <code>echo $PATH</code>，终端会打印出一串字符串，几个路径，复制该路径，返回到Jenkins中</li><li>会让填写一个键值对，键默认填写 <code>PATH</code>，值填写你从终端复制的那个字符串，点击保存，完成，构建该项目。<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></li></ol><h3 id="5-2-Cloning-spec-repo-cocoapods-from-…"><a href="#5-2-Cloning-spec-repo-cocoapods-from-…" class="headerlink" title="5.2 Cloning spec repo cocoapods from …"></a>5.2 Cloning spec repo <code>cocoapods</code> from …</h3><p>配置execute 脚本拉取CocoaPods依赖的时候，不管是 <code>pod install --verbose --no-repo-update</code> 还是用 <code>pod install</code>，页面一直处于转圈圈状态，如下图所示:<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BA%E5%85%8B%E9%9A%86cocoapods.png"><br>等待很长时间之后报错如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BA%E5%85%8B%E9%9A%86cocoapods%E5%A4%B1%E8%B4%A5.png"><br>这个问题可以进入所在文件夹通过<code>pod repo add</code> 方式来解决，或者手动拷贝过去</p><h3 id="5-3-xcode-select-error-tool-‘xcodebuild’-requires-Xcode…"><a href="#5-3-xcode-select-error-tool-‘xcodebuild’-requires-Xcode…" class="headerlink" title="5.3 xcode-select: error: tool ‘xcodebuild’ requires Xcode…"></a>5.3 xcode-select: error: tool ‘xcodebuild’ requires Xcode…</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BAxcode-select%E6%8A%A5%E9%94%99.png"><br>这个问题是 <code>Xcode</code> 路径不对，在终端输入 <code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/</code> 解决</p><h3 id="5-4-xcodebuild-error-‘xxx-xcworkspace’-does-not-exist"><a href="#5-4-xcodebuild-error-‘xxx-xcworkspace’-does-not-exist" class="headerlink" title="5.4 xcodebuild: error: ‘xxx.xcworkspace’ does not exist."></a>5.4 xcodebuild: error: ‘xxx.xcworkspace’ does not exist.</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BAworkspace%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF.png"><br>这个错误是说我们选择的项目路径，也就是需要打包的工作路径、文件不对，修改方法为: 在Jenkins项目配置里面，找到构建，点击增加构建步骤，选择 <code>Advanced Xcode build options</code>，找到<code>Xcode Workspace File</code>填写你的工作路径: <code>/Users/Shared/.jenkins/workspace/Jenkins创建的项目/项目名称</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BAworkspace%E8%B7%AF%E5%BE%84.png"></p><h3 id="5-5-Unable-to-unlock-the-keychain"><a href="#5-5-Unable-to-unlock-the-keychain" class="headerlink" title="5.5 Unable to unlock the keychain"></a>5.5 Unable to unlock the keychain</h3><pre><code>security: SecKeychainUnlock /Users/Shared/Jenkins/Home/workspace/test/login.keychain: The user name or passphrase you entered is not correct.FATAL: Unable to unlock the keychain.</code></pre><p><code>Code signing &amp; OS X keychain options</code> 中 <code>Keychains Path</code> 和 <code>Keychains password</code> 不对导致的</p><h3 id="5-6-Code-Signing-Error-There-are-no-accounts-registered-with-Xcode…"><a href="#5-6-Code-Signing-Error-There-are-no-accounts-registered-with-Xcode…" class="headerlink" title="5.6 Code Signing Error: There are no accounts registered with Xcode…"></a>5.6 Code Signing Error: There are no accounts registered with Xcode…</h3><p>打包出现以下报错：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"><br>原因: 使用了错误的 <code>Provisioning Profile</code></p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins --- 安装</title>
      <link href="posts/210946848.html"/>
      <url>posts/210946848.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装java环境"><a href="#1-安装java环境" class="headerlink" title="1. 安装java环境"></a>1. 安装java环境</h2><p><code>Jenkins</code> 是一个用Java编写的持续集成工具，依赖于Java，所以在安装Jenkins前，需要先安装Java环境，可用以下命令检查是否安装：</p><pre><code>$ java -version</code></pre><p>如果已安装的话，会有以下内容的输出：</p><pre><code>java version &quot;15.0.2&quot; 2021-01-19Java(TM) SE Runtime Environment (build 15.0.2+7-27)Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</code></pre><p>如果没有安装的话，会提示<code>No Java runtime present, requesting install.</code>，可通过下面两种方式安装。</p><h3 id="1-1-官网下载-Java-SDK"><a href="#1-1-官网下载-Java-SDK" class="headerlink" title="1.1 官网下载 Java SDK"></a>1.1 官网下载 Java SDK</h3><p>通过 <code>java -version</code> 命令检查是否安装的时候，如果没有安装，会有如下提示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_java%E5%AE%89%E8%A3%85%E5%BC%B9%E6%A1%86.png"><br>点击更多信息，会直接跳转到<a href="https://www.oracle.com/java/technologies/javase-jdk15-downloads.html">Java官网</a>下载，下载之后按照安装提示安装即可。<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%B8%8B%E8%BD%BDjava%E5%8C%85.png"></p><h3 id="1-2-HomeBrew命令行安装"><a href="#1-2-HomeBrew命令行安装" class="headerlink" title="1.2 HomeBrew命令行安装"></a>1.2 HomeBrew命令行安装</h3><p>可通过 <code>brew install java</code> 命令安装java，执行之后如果输出以下内容，则代表安装成功：</p><pre><code>$ brew install javaUpdating Homebrew...==&gt; Auto-updated Homebrew!Updated 3 taps (homebrew/cask-versions, homebrew/core and homebrew/cask).==&gt; New Formulaeqt-libiodbc                   qt-mysql                      qt-postgresql                 xrayqt-mariadb                    qt-percona-server             qt-unixodbc==&gt; Updated FormulaeUpdated 30 formulae.==&gt; Updated CasksUpdated 11 casks.==&gt; Downloading https://homebrew.bintray.com/bottles/openjdk-15.0.2.catalina.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring openjdk-15.0.2.catalina.bottle.tar.gz==&gt; CaveatsFor the system Java wrappers to find this JDK, symlink it with  sudo ln -sfn /usr/local/opt/openjdk/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdkopenjdk is keg-only, which means it was not symlinked into /usr/local,because macOS provides similar software and installing this software inparallel can cause all kinds of trouble.If you need to have openjdk first in your PATH, run:  echo &#39;export PATH=&quot;/usr/local/opt/openjdk/bin:$PATH&quot;&#39; &gt;&gt; /Users/wangruifang/.bash_profileFor compilers to find openjdk you may need to set:  export CPPFLAGS=&quot;-I/usr/local/opt/openjdk/include&quot;==&gt; Summary🍺  /usr/local/Cellar/openjdk/15.0.2: 614 files, 324.9MB</code></pre><blockquote><p>从官网下载安装比较简单，HomeBrew命令行安装过程中容易出错（此篇文章第三部分记录的就是安装过程中遇到的问题）。</p></blockquote><h2 id="2-安装Jenkins"><a href="#2-安装Jenkins" class="headerlink" title="2.安装Jenkins"></a>2.安装Jenkins</h2><p>通安装java环境以下，Jenkins的安装也有两种方式</p><h3 id="2-1-安装包下载安装"><a href="#2-1-安装包下载安装" class="headerlink" title="2.1 安装包下载安装"></a>2.1 安装包下载安装</h3><p>前往<a href="https://www.jenkins.io/">Jenkins官网</a>下载 <code>.pkg</code> 安装包进行安装即可。</p><h3 id="2-2-HomeBrew命令行安装"><a href="#2-2-HomeBrew命令行安装" class="headerlink" title="2.2 HomeBrew命令行安装"></a>2.2 HomeBrew命令行安装</h3><p>可直接通过 <code>brew install jenkins</code> 命令安装：</p><pre><code>$ brew install jenkins</code></pre><p>安装结束后，可根据需要执行以下命令：</p><pre><code>// For the system Java wrappers to find this JDK, symlink it with$ sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk// openjdk@11 is keg-only, which means it was not symlinked into /usr/local, because this is an alternate version of another formula.// If you need to have openjdk@11 first in your PATH, run:$ echo &#39;export PATH=&quot;/usr/local/opt/openjdk@11/bin:$PATH&quot;&#39; &gt;&gt; /Users/wangruifang/.bash_profile//For compilers to find openjdk@11 you may need to set:$ export CPPFLAGS=&quot;-I/usr/local/opt/openjdk@11/include&quot;</code></pre><h2 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h2><p>安装完成之后，在终端输入命令：</p><pre><code>$ jenkins 或者$ brew services start jenkins </code></pre><p>启动 jenkins 服务，即可在浏览器中<a href="http://localhost:8080/">http://localhost:8080</a>中访问</p><blockquote><p><code>brew services start jenkins</code> 命令与 <code>jenkins</code> 的区别是：当终端关闭时，jenkins服务还可以继续使用。</p></blockquote><h3 id="3-1-解锁Jenkins"><a href="#3-1-解锁Jenkins" class="headerlink" title="3.1 解锁Jenkins"></a>3.1 解锁Jenkins</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E8%A7%A3%E9%94%81jenkins.png"><br>按照图中描述输入 <code>cat</code> + <code>密码路径</code>，获取密码复制到管理员密码框中，然后下一步:</p><pre><code>$ cat /Users/用户名/.jenkins/secrets/initialAdminPassword</code></pre><h3 id="3-2-选择安装推荐的插件"><a href="#3-2-选择安装推荐的插件" class="headerlink" title="3.2 选择安装推荐的插件"></a>3.2 选择安装推荐的插件</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E9%80%89%E6%8B%A9%E6%8F%92%E4%BB%B6.png"></p><h3 id="3-3-等待插件安装"><a href="#3-3-等待插件安装" class="headerlink" title="3.3 等待插件安装"></a>3.3 等待插件安装</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.png"></p><blockquote><p>这个过程可能会有插件安装失败，在进度完成之后可重试，会再次安装失败的插件</p></blockquote><h3 id="3-4-创建管理员用户"><a href="#3-4-创建管理员用户" class="headerlink" title="3.4 创建管理员用户"></a>3.4 创建管理员用户</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png"></p><h3 id="3-5-实例配置"><a href="#3-5-实例配置" class="headerlink" title="3.5 实例配置"></a>3.5 实例配置</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8jenkins%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA.png"><br>使用默认端口就可以， 点击保存后就会到Jenkins即将就绪页面，此时需重启Jenkins，执行命令：</p><pre><code>$ brew services restart jenkins</code></pre><blockquote><p>url重启Jenkins : <a href="http://localhost:8080/restart">http://localhost:8080/restart</a><br>url关闭Jenkins : <a href="http://localhost:8080/exit">http://localhost:8080/exit</a></p></blockquote><h3 id="3-6-完成"><a href="#3-6-完成" class="headerlink" title="3.6 完成"></a>3.6 完成</h3><p>jenkins服务重启后刷新<a href="http://localhost:8080/">http://localhost:8080</a>，就可以看到jenkins的登录页面了<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E7%99%BB%E5%BD%95.png"><br>输入账号密码就可以进入Jenkins首页：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%A6%96%E9%A1%B5.png"></p><h2 id="3-安装过程中遇到的问题"><a href="#3-安装过程中遇到的问题" class="headerlink" title="3.安装过程中遇到的问题"></a>3.安装过程中遇到的问题</h2><h3 id="3-1-No-available-formula-with-the-name-quot-java-quot"><a href="#3-1-No-available-formula-with-the-name-quot-java-quot" class="headerlink" title="3.1 No available formula with the name &quot;java&quot; "></a>3.1 <code>No available formula with the name &quot;java&quot; </code></h3><p><code>Q</code>: 执行 <code>brew install java</code>可能会出现以下报错内容：</p><pre><code>$ brew install javaUpdating Homebrew...Error: No available formula with the name &quot;java&quot; ==&gt; Searching for a previously deleted formula (in the last month)...Warning: homebrew/core is shallow clone. To get complete history run:  git -C &quot;$(brew --repo homebrew/core)&quot; fetch --unshallowError: No previously deleted formula found.==&gt; Searching for similarly named formulae...These similarly named formulae were found:app-engine-java               javacc                        jslint4java                   pdftk-javagoogle-java-format            javarepl                      libreadline-javaTo install one of them, run (for example):  brew install app-engine-java==&gt; Searching taps...==&gt; Searching taps on GitHub...Warning: Error searching on GitHub: curl failed!   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed  0     0    0     0    0     0      0      0 --:--:--  0:00:04 --:--:--     0curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to api.github.com:443 Error: No formulae found in taps.</code></pre><p><code>A</code>: 此代表当前 HomeBrew 版本较低导致安装失败，需update，可执行：</p><pre><code>$ brew update</code></pre><h3 id="3-2-homebrew-core-is-a-shallow-clone"><a href="#3-2-homebrew-core-is-a-shallow-clone" class="headerlink" title="3.2 homebrew-core is a shallow clone"></a>3.2 <code>homebrew-core is a shallow clone</code></h3><p><code>Q</code>: 执行 <code>brew update</code> 可能会出现以下报错：</p><pre><code>$ brew updateError:   homebrew-core is a shallow clone.To `brew update`, first run:  git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallowThis command may take a few minutes to run due to the large size of the repository.This restriction has been made on GitHub&#39;s request because updating shallowclones is an extremely expensive operation due to the tree layout and traffic ofHomebrew/homebrew-core and Homebrew/homebrew-cask. We don&#39;t do this for youautomatically to avoid repeatedly performing an expensive unshallow operation inCI systems (which should instead be fixed to not use shallow clones). Sorry forthe inconvenience!</code></pre><p><code>A</code>: 解决方法是先执行以下命令再执行 <code>brew update</code>：</p><pre><code>$ rm -rf /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</code></pre><h3 id="3-3-The-following-directories-are-not-writable-by-your-user-usr-local-share-man-man8"><a href="#3-3-The-following-directories-are-not-writable-by-your-user-usr-local-share-man-man8" class="headerlink" title="3.3 The following directories are not writable by your user: /usr/local/share/man/man8"></a>3.3 <code>The following directories are not writable by your user: /usr/local/share/man/man8</code></h3><p><code>Q</code>: 执行 <code>brew install java</code>可能会因为权限问题出现以下报错内容：</p><pre><code>$ brew install javaError: The following directories are not writable by your user:/usr/local/share/man/man8You should change the ownership of these directories to your user.  sudo chown -R $(whoami) /usr/local/share/man/man8And make sure that your user has write permission.  chmod u+w /usr/local/share/man/man8</code></pre><p><code>A</code>: 解决方法可执行以下命令：</p><pre><code>$ sudo chown -R $(whoami) /usr/local/share/man/man8</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 标签</title>
      <link href="posts/1519021198.html"/>
      <url>posts/1519021198.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-标签简介"><a href="#1-标签简介" class="headerlink" title="1.标签简介"></a>1.标签简介</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以，标签也是版本库的一个快照。</p><blockquote><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针，所以，创建和删除标签都是瞬间完成的。</p></blockquote><h2 id="2-打标签"><a href="#2-打标签" class="headerlink" title="2.打标签"></a>2.打标签</h2><h3 id="2-1-创建标签"><a href="#2-1-创建标签" class="headerlink" title="2.1 创建标签"></a>2.1 创建标签</h3><p>Git 支持两种标签：<code>轻量标签</code>（lightweight）与 <code>附注标签</code>（annotated）</p><h4 id="2-1-1-轻量标签"><a href="#2-1-1-轻量标签" class="headerlink" title="2.1.1 轻量标签"></a>2.1.1 轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息</p><pre><code>$ git tag v1.0.0</code></pre><h4 id="2-1-2-附注标签"><a href="#2-1-2-附注标签" class="headerlink" title="2.1.2 附注标签"></a>2.1.2 附注标签</h4><p>附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。</p><pre><code>$ git tag -a v1.0.0 -m &quot;my version 1.4&quot;$ git tag -a v1.0.0 9fceb02 //对过去的某次提交打标签$ git push origin v1.0.0    //将标签1.0.0推送到远程仓库</code></pre><h3 id="2-2-查看已有标签"><a href="#2-2-查看已有标签" class="headerlink" title="2.2 查看已有标签"></a>2.2 查看已有标签</h3><pre><code>$ git tag</code></pre><h3 id="2-3-删除标签"><a href="#2-3-删除标签" class="headerlink" title="2.3 删除标签"></a>2.3 删除标签</h3><pre><code>$ git tag -d v1.0.0</code></pre><blockquote><p>上述命令并不会从任何远程仓库中移除这个标签，你必须用:<br><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; </code><br>或者<br><code>git push origin --delete &lt;tagname&gt;</code></p></blockquote><h3 id="2-4-检出标签"><a href="#2-4-检出标签" class="headerlink" title="2.4 检出标签"></a>2.4 检出标签</h3><pre><code>$ git checkout v1.0.0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 分支</title>
      <link href="posts/1519021197.html"/>
      <url>posts/1519021197.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 基础</title>
      <link href="posts/28b33e30.html"/>
      <url>posts/28b33e30.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取Git仓库"><a href="#1-获取Git仓库" class="headerlink" title="1.获取Git仓库"></a>1.获取Git仓库</h2><p>通常有两种获取 <code>Git</code> 项目仓库的方式：</p><ol><li>本地创建 Git 仓库；</li><li>从其它服务器 <code>克隆</code> 一个已存在的 Git 仓库</li></ol><h3 id="1-1-本地创建-Git-仓库"><a href="#1-1-本地创建-Git-仓库" class="headerlink" title="1.1 本地创建 Git 仓库"></a>1.1 本地创建 Git 仓库</h3><h4 id="1-1-1-创建版本库"><a href="#1-1-1-创建版本库" class="headerlink" title="1.1.1 创建版本库"></a>1.1.1 创建版本库</h4><p>创建版本库很简单，首先，选择一个合适的地方，创建一个空目录：</p><pre><code>mkdir Git仓库目录cd Git仓库目录pwd //显示当前目录</code></pre><p>然后通过 <code>git init</code> 命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/username/Git_Repository/.git/</code></pre><p>这样Git仓库就创建好了，目前还是一个空的仓库，但是该目录下多了一个 <code>.git</code> 目录，这个目录是Git来跟踪管理版本库的，不可随意改动。</p><blockquote><p>如果你没有看到 <code>.git</code> 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p></blockquote><h4 id="1-1-2-本地Git关联远程仓库"><a href="#1-1-2-本地Git关联远程仓库" class="headerlink" title="1.1.2 本地Git关联远程仓库"></a>1.1.2 本地Git关联远程仓库</h4><p>以 <code>GitHub</code> 为例，可以从 GitHub 仓库克隆出新的仓库，也可以关联一个已有的本地仓库，然后将本地仓库的内容推送到 GitHub 仓库。打开本地仓库，执行以下命令来进行关联：</p><pre><code>git remote add origin git@github.com:username/Git_Repository.git</code></pre><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.</code></pre><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。以后只要本地有修改，就可以通过以下命令把本地master分支的最新修改推送至GitHub：</p><pre><code>$ git push origin master</code></pre><blockquote><p>由于远程库是空的，我们第一次推送master分支时，加上了 <code>-u</code> 参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></blockquote><h4 id="1-1-3-删除远程库"><a href="#1-1-3-删除远程库" class="headerlink" title="1.1.3 删除远程库"></a>1.1.3 删除远程库</h4><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用 <code>git remote rm &lt;name&gt;</code> 命令。使用前，建议先用 <code>git remote -v</code> 查看远程库信息：</p><pre><code>$ git remote -vorigin    git@github.com:username/Git_Repository.git (fetch)origin    git@github.com:username/Git_Repository.git (push)</code></pre><p>然后根据名字删除：</p><pre><code>$ git remote rm origin</code></pre><h3 id="1-2-克隆现有的仓库"><a href="#1-2-克隆现有的仓库" class="headerlink" title="1.2 克隆现有的仓库"></a>1.2 克隆现有的仓库</h3><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code>，url为仓库地址，比如：</p><pre><code>git clone https://github.com/libgit2/libgit2</code></pre><blockquote><p>这会在当前目录下创建一个名为 <code>libgit2</code> 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p></blockquote><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><pre><code>git clone https://github.com/libgit2/libgit2 mylibgit</code></pre><p>这会执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p><blockquote><p><code>Git</code> 支持多种数据传输协议。上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 <code>SSH</code> 传输协议，比如 <code>user@server:path/to/repo.git</code>。</p></blockquote><h2 id="2-Git基本操作"><a href="#2-Git基本操作" class="headerlink" title="2.Git基本操作"></a>2.Git基本操作</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git init</td><td align="center">初始化仓库</td></tr><tr><td align="center">git clone</td><td align="center">克隆远程仓库</td></tr></tbody></table><h3 id="2-2-提交与修改"><a href="#2-2-提交与修改" class="headerlink" title="2.2 提交与修改"></a>2.2 提交与修改</h3><h4 id="2-2-1-检查当前文件状态"><a href="#2-2-1-检查当前文件状态" class="headerlink" title="2.2.1 检查当前文件状态"></a>2.2.1 检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态，对于没有任何文件修改的仓库执行完命令之后显示<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_0.png"></p><h4 id="2-2-2-把更改的内容添加到暂存区"><a href="#2-2-2-把更改的内容添加到暂存区" class="headerlink" title="2.2.2 把更改的内容添加到暂存区"></a>2.2.2 把更改的内容添加到暂存区</h4><p>新建 <code>_config.yml</code> 文件，执行 <code>git status</code> 之后显示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_1.png"><br>此时代表 <code>_config.yml</code> 文件还未添加到暂存区，我们使用命令 <code>git add</code>，运行：</p><pre><code>git add _config.yml</code></pre><p>然后再执行 <code>git status</code>，就会看到 <code>_config.yml</code> 文件已被添加到暂存区，并处于暂存状态：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_2.png"></p><blockquote><p><code>git add</code> 命令使用文件或目录的路径作为参数</p></blockquote><h4 id="2-2-3-修改已暂存的文件"><a href="#2-2-3-修改已暂存的文件" class="headerlink" title="2.2.3 修改已暂存的文件"></a>2.2.3 修改已暂存的文件</h4><p>修改一个已在暂存区的文件，以 <code>_config.yml</code> 为例，修改之后执行 <code>git status</code> 命令之后，会看到下面内容：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_3.png"><br>暂存这次修改，再次执行 <code>git add</code> 命令。</p><blockquote><p><code>_config.yml</code> 文件同时出现在暂存区 和 非暂存区，但是 <code>git commit</code>时，只会提交最后一次运行 <code>git add</code> 时的版本。</p></blockquote><h4 id="2-2-4-状态预览"><a href="#2-2-4-状态预览" class="headerlink" title="2.2.4 状态预览"></a>2.2.4 状态预览</h4><p><code>git status</code> 命令的输出非常详细，但其用语有些繁琐。可以使用 <code>git status -s</code> 或 <code>git status -short</code> 来进行简洁输出：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_preview.png"></p><blockquote><p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态:<br><code>??</code> : 未被添加到暂存区的文件<br><code>A</code>   : 新添加到暂存区中的文件<br><code>M</code>   : 被修改的文件<br><code>AM</code> : 添加到暂存区之后又有改动</p></blockquote><h4 id="2-2-5-忽略文件"><a href="#2-2-5-忽略文件" class="headerlink" title="2.2.5 忽略文件"></a>2.2.5 忽略文件</h4><p>执行 <code>add</code> 操作时，有些文件是不想要放到暂存区，就可以使用下面的方法忽略掉:</p><ul><li>使用命令：<code>touch .gitignore</code> 创建 <code>.gitignore</code> 文件</li><li>在文件中写入需要忽略的文件</li></ul><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略</li><li>可以使用标准的 <code>glob</code> 模式匹配，它会递归地应用在整个工作区中</li><li>匹配模式可以以（<code>/</code>）开头防止递归</li><li>匹配模式可以以（<code>/</code>）结尾指定目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反</li></ul><blockquote><p>所谓的 <code>glob</code> 模式是指 <code>shell</code> 所使用的简化了的正则表达式:<br><code>*</code> : 匹配零个或多个任意字符<br><code>[abc]</code> : 匹配任何一个列在方括号中的字符(要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)<br><code>?</code> : 只匹配一个任意字符<br><code>[0-9]</code> : 匹配所有 <code>0</code> 到 <code>9</code> 的数字<br><code>**</code> : 匹配任意中间目录(比如：<code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等)</p></blockquote><p><code>.gitignore</code> 文件示例：</p><pre><code># 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf</code></pre><h4 id="2-2-6-比较暂存区和工作区的差异"><a href="#2-2-6-比较暂存区和工作区的差异" class="headerlink" title="2.2.6 比较暂存区和工作区的差异"></a>2.2.6 比较暂存区和工作区的差异</h4><ul><li>比较文件在暂存区和工作区的差异，使用命令：<pre><code>$ git diff</code></pre></li><li>查看文件修改之后还没有暂存的变化部分，直接使用命令：<pre><code>$ git diff [file]</code></pre></li><li>显示已暂存文件和上次提交的差异，使用命令：<pre><code>$ git diff --staged或$ git diff --cached</code></pre></li><li>显示两次提交之间的差异，使用命令：<pre><code>$ git diff [first-branch]...[second-branch]</code></pre></li></ul><h4 id="2-2-7-提交更新"><a href="#2-2-7-提交更新" class="headerlink" title="2.2.7 提交更新"></a>2.2.7 提交更新</h4><p>提交暂存区到本地仓库中，命令为：</p><pre><code>$ git commit -m &quot;message&quot; //message为提交log信息</code></pre><p>提交暂存区的指定文件到本地仓库，使用命令：</p><pre><code>$ git commit [file1] [file2] ... -m &quot;message&quot;</code></pre><p>修改文件后，不执行 <code>git add</code> 命令，直接跳过使用暂存区来提交，使用命令：</p><pre><code>$ git commit -a -m &quot;message&quot;</code></pre><blockquote><p>运行 <code>git commit -a</code> 相当于运行 <code>git add</code> 把所有文件加入暂存区，然后再运行 <code>git commit</code> 把文件提交本地仓库。<br>提交之后，发现漏提文件或者提交信息写错了，可以重新提交，使用命令：</p></blockquote><pre><code>$ git commit -m &quot;message&quot;$ git add forgotten_file$ git commit --amend</code></pre><blockquote><p>最终只会有一个提交——第二次提交将代替第一次提交的结果</p></blockquote><h4 id="2-2-8-删除文件"><a href="#2-2-8-删除文件" class="headerlink" title="2.2.8 删除文件"></a>2.2.8 删除文件</h4><ol><li><p>从工作区删除文件<br>从工作区中移除某个文件，可以直接删除，也可以用 <code>rm</code> 命令删：</p><pre><code>rm [file]</code></pre><p>这只是简单的从工作目录中删除了文件，运行 <code>git status</code> 时就会有 <code>Changes not staged for commit</code> 部分：</p><pre><code>$ rm test.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes not staged for commit:(use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)     deleted:    test.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>然后再运行 <code>git rm </code> 记录此次移除文件的操作，然后提交，文件从版本库中被删除：</p><pre><code>$ git rm test.mdrm &#39;test.md&#39;$ git commit -m &quot;remove test.md&quot;[master d46f35e] remove test.md1 file changed, 1 deletion(-)delete mode 100644 test.md</code></pre><blockquote><p>如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>git rm -f [file]</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p></blockquote></li><li><p>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可：</p><pre><code>$ git rm --cached test.md</code></pre></li></ol><h4 id="2-2-9-移动文件"><a href="#2-2-9-移动文件" class="headerlink" title="2.2.9 移动文件"></a>2.2.9 移动文件</h4><p><code>git mv</code> 命令用于移动或重命名一个文件、目录或软连接:</p><pre><code>$ git mv file_from file_to</code></pre><p><code>git mv</code> 相当于运行了下面三条命令：</p><pre><code>$ mv file_from file_to$ git rm file_from$ git add file_to</code></pre><h4 id="2-2-10-代码回退"><a href="#2-2-10-代码回退" class="headerlink" title="2.2.10 代码回退"></a>2.2.10 代码回退</h4><pre><code>$ git reset --files //用本地仓库覆盖暂存区中修改，也就是覆盖最后一次git add的内容$ git checkout --files  //把文件从暂存区复制到工作区，用于放弃本地的修改$ git checkout HEAD --files //回退最后一次的提交内容</code></pre><blockquote><p>从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></blockquote><h4 id="2-2-11-版本回退"><a href="#2-2-11-版本回退" class="headerlink" title="2.2.11 版本回退"></a>2.2.11 版本回退</h4><pre><code>$ git reset --hard HEAD^ //回退到上一版本$ git reset --hard HEAD^^ //回退到上上版本$ git reset --hard HEAD~100 //回退到前100个版本$ git reset --hard [版本号] //回退到固定版本号$ git reflog //记录每一次的命令（可以查看版本号）</code></pre><h3 id="2-3-提交日志"><a href="#2-3-提交日志" class="headerlink" title="2.3 提交日志"></a>2.3 提交日志</h3><h4 id="2-3-1-查看历史提交记录"><a href="#2-3-1-查看历史提交记录" class="headerlink" title="2.3.1 查看历史提交记录"></a>2.3.1 查看历史提交记录</h4><pre><code>$ git log</code></pre><h4 id="2-3-2-以列表形式查看指定文件的历史修改记录"><a href="#2-3-2-以列表形式查看指定文件的历史修改记录" class="headerlink" title="2.3.2 以列表形式查看指定文件的历史修改记录"></a>2.3.2 以列表形式查看指定文件的历史修改记录</h4><pre><code>$ git blame file</code></pre><h3 id="2-4-远程操作"><a href="#2-4-远程操作" class="headerlink" title="2.4 远程操作"></a>2.4 远程操作</h3><h4 id="2-4-1-本地推送远程"><a href="#2-4-1-本地推送远程" class="headerlink" title="2.4.1 本地推送远程"></a>2.4.1 本地推送远程</h4><p>如果还没有克隆现有仓库，并想将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><pre><code>$ git remote add origin &lt;url&gt;</code></pre><p>如果已经关联了远程仓库，可以使用下述命令看一下远程仓库是哪个</p><pre><code>$ git remote -v</code></pre><p>然后将本地的改动提交到远程仓库:</p><pre><code>$ git push origin [分支]</code></pre><h4 id="2-4-2-从远程仓库中抓取与拉取"><a href="#2-4-2-从远程仓库中抓取与拉取" class="headerlink" title="2.4.2 从远程仓库中抓取与拉取"></a>2.4.2 从远程仓库中抓取与拉取</h4><pre><code>$ git fetch //下载远程代码到本地仓库$ git pull  //合并</code></pre><blockquote><p><code>git fetch</code> 命令只会将数据下载到你的本地仓库，并不会自动合并或修改你当前的工作</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 入门</title>
      <link href="posts/bcaee25f.html"/>
      <url>posts/bcaee25f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于版本控制"><a href="#1-关于版本控制" class="headerlink" title="1.关于版本控制"></a>1.关于版本控制</h2><h3 id="1-1-什么是版本控制"><a href="#1-1-什么是版本控制" class="headerlink" title="1.1 什么是版本控制"></a>1.1 什么是版本控制</h3><p>版本控制是一种记录一个或若干文件(可以是任意类型的文件)内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="1-2-为什么要用版本控制"><a href="#1-2-为什么要用版本控制" class="headerlink" title="1.2 为什么要用版本控制"></a>1.2 为什么要用版本控制</h3><p>在我们的实际开发过程中，经常会有这样的问题：</p><ol><li>一个项目多人协同开发，多人修改后如何快速生成一份最新代码</li><li>检查某个文件的修改记录（修改人、修改时间、修改内容）</li><li>改错代码，需将项目代码恢复到之前的某个版本</li></ol><h3 id="1-3-历史分类"><a href="#1-3-历史分类" class="headerlink" title="1.3 历史分类"></a>1.3 历史分类</h3><p>纵观版本控制系统的发展历史，<a href="https://ericsink.com/vcbe/index.html">《Version Control By Example》</a>一书的作者 <code>Eric Sink</code> 在他的书中对版本控制进行了分类，广义上讲，版本控制工具的历史可以分为三代：</p><table><thead><tr><th align="center">代</th><th align="center">名称</th><th align="center">网络</th><th align="center">操作</th><th align="center">并发性</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">第一代</td><td align="center">本地版本控制系统</td><td align="center">无</td><td align="center">仅一个文件</td><td align="center">锁定的</td><td align="center">RCS</td></tr><tr><td align="center">第二代</td><td align="center">集中式版本控制系统</td><td align="center">集中式</td><td align="center">多文件</td><td align="center">提交之前合并</td><td align="center">CVS, SourceSafe, Subversion, Team Foundation Server</td></tr><tr><td align="center">第三代</td><td align="center">分布式版本控制系统</td><td align="center">分布式</td><td align="center">变更的集合</td><td align="center">合并之前提交</td><td align="center">Bazaar, Git, Mercurial</td></tr></tbody></table><h4 id="1-3-1-本地版本控制系统"><a href="#1-3-1-本地版本控制系统" class="headerlink" title="1.3.1 本地版本控制系统"></a>1.3.1 本地版本控制系统</h4><p>本地版本控制系统，一次只能有一个人处理文件，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><h4 id="1-3-2-集中式版本控制系统"><a href="#1-3-2-集中式版本控制系统" class="headerlink" title="1.3.2 集中式版本控制系统"></a>1.3.2 集中式版本控制系统</h4><p>集中式版本控制系统，版本库是集中存放在中央服务器的，协同工作的人都是通过客户端连接到这台服务器，取出最新的文件或者提交更新。<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_category_cvcs.png"><br>由上图可看到，在集中式版本控制系统中：</p><ul><li>优点: 不同的开发者可以在不同的电脑上进行协同开发，对同步修改更加宽容</li><li>缺点: 中央服务器的单点故障。如果宕机一小时，那么在这一个小时内，谁都无法提交更新。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，那么将丢失所有数据——包括项目的整个变更历史，只剩下各自机器上保留的单独快照。</li></ul><h4 id="1-3-3-分布式版本控制系统"><a href="#1-3-3-分布式版本控制系统" class="headerlink" title="1.3.3 分布式版本控制系统"></a>1.3.3 分布式版本控制系统</h4><p>分布式版本控制系统，允许合并和提交分开，在每个使用者电脑上都有一个完整的版本库，包括完整的历史记录，没有网络依然可以使用。<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_category_dvcs.png"><br>由上图可看到，分布式式版本控制系统也可以有个服务器端的仓库，用来同步各开发者的私有仓库！在分布式版本控制系统中，每个参与者的本地也会有一个完整的仓库。即使服务器端崩溃，我们仍然可以使用 Git（仅在本地仓库管理我们的代码），在网络具备时，再和服务器进行同步即可！</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><h3 id="2-1-Git起源"><a href="#2-1-Git起源" class="headerlink" title="2.1 Git起源"></a>2.1 Git起源</h3><p>Linus 在1991年创建了开源的 <code>Linux</code>，Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，初期世界各地的志愿者把源代码文件通过 <code>diff</code> 的方式发给Linus，然后由linus 本人通过 <code>linux</code> 命令 <code>diff</code> 和 <code>patch</code> 两条命令手动完成。随着 Linux 代码越来越壮大，靠 Linus 一个人来手动合并已经不现实。2002 年，Linus 选择了一个商业版本控制系统 <code>BitKeeper</code> 作为 Linux 内核的代码管理工具（<code>BitKeeper</code> 的开发商 <code>BitMover</code> 授权 linux 社区免费使用）。但是，免费使用是有很多的限制的，因此 linux 社区的大佬开始破解 <code>BitKeeper</code>。其中，<code>samba</code> 的作者 <code>andrew</code> 破解成功了。但是被 <code>BitMover</code> 公司发现，收回免费使用权。</p><p>迫不得已，Linus 选择了自己开发一个分布式版本控制工具以替代 <code>BitKeeper</code>。linus 闭关一个月，用C写出了 <code>Git</code>。在一个月后，<code>Git</code> 成功接管了 <code>Linux</code> 社区的版本控制工作，并且开始开源。</p><h3 id="2-2-Git简介"><a href="#2-2-Git简介" class="headerlink" title="2.2 Git简介"></a>2.2 Git简介</h3><p><code>Git</code> 是目前世界上最先进的分布式版本控制系统。每个开发者的本地都会有完整的版本库，不需要来联网，也能进行版本的管理和代码的提交，每个开发者都可以在本地进行提交代码、查看版本、切换分支等操作。</p><h4 id="2-2-1-Git特点"><a href="#2-2-1-Git特点" class="headerlink" title="2.2.1 Git特点"></a>2.2.1 Git特点</h4><ol><li>直接记录快照，而不是差异比较:<br> 其他版本控制系统(<code>CVS</code>、<code>Subversion</code>、<code>Perforce</code>、<code>Bazaar</code> 等等)将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异:<br> <img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_cvs_record.png"><br> 在<code>Git</code>中保存项时，它主要对当时的全部文件制作一个快照并保存这个快照的索引，<code>Git</code> 对待数据更像是一个 <code>快照流</code>。<br> <img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_git_record.png"></li><li>近乎所有操作都是本地执行</li><li>Git保证完整性: Git数据库中保存的信息都是以文件内容的哈希值（40个十六进制字符 <code>0-9</code> 和 <code>a-f</code>）来索引，而不是文件名。</li><li>执行的Git操作，只往Git数据库中增加数据，而且Git操作不可逆。</li></ol><h4 id="2-2-2-Git工作区、暂存区和版本库"><a href="#2-2-2-Git工作区、暂存区和版本库" class="headerlink" title="2.2.2 Git工作区、暂存区和版本库"></a>2.2.2 Git工作区、暂存区和版本库</h4><p>Git有三种状态，你的文件有可能处于其中之一：</p><ul><li><code>已提交</code>：表示数据已经安全的保存在本地数据库中</li><li><code>已修改</code>：表示修改了文件，但还没保存到数据库中</li><li><code>已暂存</code>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><p>由此可以引入Git的三个工作区：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_work_zone.png"></p><ul><li><code>工作区</code>：就是你在电脑里能看到的目录</li><li><code>暂存区</code>：英文叫 <code>stage</code> 或 <code>index</code>。一般存放在 <code>.git</code> 目录下的 <code>index</code> 文件 <code>（.git/index）</code>中，所以我们把暂存区有时也叫作索引（index）</li><li><code>版本库</code>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 Git 的版本库</li></ul><h4 id="2-2-3-Git工作流程"><a href="#2-2-3-Git工作流程" class="headerlink" title="2.2.3 Git工作流程"></a>2.2.3 Git工作流程</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_git_process.png"><br>一般工作流程如下：</p><ol><li>克隆Git资源作为工作目录</li><li>在工作目录中添加或者修改文件</li><li>如果其他人修改了，你可以更新资源</li><li>在提交前查看修改</li><li>提交修改，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li></ol><h3 id="2-3-Git安装"><a href="#2-3-Git安装" class="headerlink" title="2.3 Git安装"></a>2.3 Git安装</h3><p>Git 本身支持 <code>Mac OS X</code>、<code>Windows</code>、<code>Linux/Unix</code> 这些主流的平台。</p><h4 id="2-3-1-Mac-OS"><a href="#2-3-1-Mac-OS" class="headerlink" title="2.3.1 Mac OS"></a>2.3.1 Mac OS</h4><p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 <code>Xcode Command Line Tools</code>。 <code>Mavericks （10.9）</code> 或更高版本的系统中，在 <code>Terminal</code> 里尝试首次运行 git 命令即可:</p><pre><code>git --version</code></pre><p>如果没有安装过命令行开发者工具，将会提示你安装。</p><blockquote><p>还可以通过 <code>homebrew</code> 安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</p></blockquote><h3 id="2-4-Git配置"><a href="#2-4-Git配置" class="headerlink" title="2.4 Git配置"></a>2.4 Git配置</h3><p>Git 的配置主要就是 Git 命令 <code>git config</code> 的使用。</p><h4 id="2-4-1-设置用户信息"><a href="#2-4-1-设置用户信息" class="headerlink" title="2.4.1 设置用户信息"></a>2.4.1 设置用户信息</h4><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p><pre><code>$ git config --global user.name &quot;username&quot;$ git config --global user.email username@example.com</code></pre><blockquote><p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p></blockquote><h4 id="2-4-2-检查配置信息"><a href="#2-4-2-检查配置信息" class="headerlink" title="2.4.2 检查配置信息"></a>2.4.2 检查配置信息</h4><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置：</p><pre><code>$ git config --listcredential.helper=osxkeychaincore.excludesfile=/Users/username/.gitignore_globaldifftool.sourcetree.cmd=opendiff &quot;$LOCAL&quot; &quot;$REMOTE&quot;difftool.sourcetree.path=mergetool.sourcetree.cmd=/Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh &quot;$LOCAL&quot; &quot;$REMOTE&quot; -ancestor &quot;$BASE&quot; -merge &quot;$MERGED&quot;mergetool.sourcetree.trustexitcode=trueuser.name=usernameuser.email=email@email.comcommit.template=/Users/username/.stCommitMsghttp.postbuffer=524288000http.lowspeedlimit=0http.lowspeedtime=999999credential.helper=osxkeychaincore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=trueremote.origin.url=git@github.com:username/repository.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=origin</code></pre><p>你可以通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置:</p><pre><code>$ git config user.nameusername</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 添加Gitalk评论</title>
      <link href="posts/2465856778.html"/>
      <url>posts/2465856778.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>目前 <code>3-hexo</code> 已经集成了评论系统有 <code>gitalk</code> 、<code>gitment</code>、 <code>disqus</code> 、<code>来必力</code>、<code>utteranc</code>。本来以为按照 <code>3-hexo</code> 作者的设置文档很简单，没想到中间还是遇到一些问题，然后就将这些问题做了以下记录。</p><h2 id="2-Gitalk"><a href="#2-Gitalk" class="headerlink" title="2.Gitalk"></a>2.Gitalk</h2><h3 id="2-1-Gitalk简介"><a href="#2-1-Gitalk简介" class="headerlink" title="2.1 Gitalk简介"></a>2.1 Gitalk简介</h3><blockquote><p><a href="https://gitalk.github.io/">Gitalk</a> 是一款基于 <code>Github Issue</code> 和 <code>Preact</code> 开发的评论插件，使用 Github 帐号登录，界面干净整洁，支持 <code>MarkDown</code> 语法，在个人博客里添加了之后就可以很简便的进行评论和回复了。</p></blockquote><p>主要特性：</p><ul><li>使用 Github 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd | ctrl + enter）</li><li>支持 MarkDown 语法</li></ul><p>界面效果：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_comment.png"></p><h3 id="2-2-3-hexo添加Gitalk评论"><a href="#2-2-3-hexo添加Gitalk评论" class="headerlink" title="2.2 3-hexo添加Gitalk评论"></a>2.2 3-hexo添加Gitalk评论</h3><h4 id="2-2-1-登录Github注册OAuth应用"><a href="#2-2-1-登录Github注册OAuth应用" class="headerlink" title="2.2.1 登录Github注册OAuth应用"></a>2.2.1 登录Github注册OAuth应用</h4><p><a href="https://github.com/settings/applications/new"><strong>点击进行注册</strong></a> ，也可以通过 GitHub -&gt; 【点击头像】 -&gt; 【Settings】 -&gt; 【Developer settings】-&gt; 【OAuth Apps】-&gt;【New OAuth App】进行基本配置，如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_register.png"></p><ul><li><code>Application name</code>：应用名称，随便填</li><li><code>Homepage URL</code>：没有过多要求，可以填自己的博客地址(避免出问题最和Authorization callback URL好统一)</li><li><code>Application description</code>：应用描述，描述一下，无要求</li><li><code>Authorization callback URL</code>：这个就有要求了，填自己要使用 <code>Gitalk</code> 的博客地址，不可乱填</li></ul><p>注册完后，可得到 <code>Client ID</code> 和 <code>Client Secret</code>。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_client_info.png"></p><h4 id="2-2-2-新建存放评论的仓库"><a href="#2-2-2-新建存放评论的仓库" class="headerlink" title="2.2.2 新建存放评论的仓库"></a>2.2.2 新建存放评论的仓库</h4><p>因为 <code>gitalk</code> 是基于 Github 的 <code>Issue</code> 的，所以，你要为他建一个库或用现成的库，可以新建一个，而 <code>repo</code> 就是你要用的库的名称。 比如，为 Gitalk 专门建了一个叫 gitalk 的库，所以在 repo: 处填 gitalk。</p><h4 id="2-2-3-配置主题"><a href="#2-2-3-配置主题" class="headerlink" title="2.2.3 配置主题"></a>2.2.3 配置主题</h4><p>在主题下 <code>_config.yml</code> 中找到如下配置，启用评论，并使用 <code>gitalk</code></p><pre><code>##########评论设置#############comment:  on: true  type: gitalk</code></pre><p>在主题下 <code>_config.yml</code> 中找到 <code>gitalk</code> 配置，将第1步得到的 <code>Client ID</code> 和 <code>Client Secret</code> 复制到如下位置:</p><pre><code>gitalk:  githubID:    # 填你的 github 用户名  repo:  xxx.github.io     # 承载评论的仓库，一般使用 Github Page 仓库  ClientID:   # 第1步获得 Client ID  ClientSecret:  # 第1步获得 Client Secret  adminUser:     # Github 用户名  distractionFreeMode: true  language: zh-CN  perPage: 10</code></pre><p>到此为止，所有的配置就完成了，执行部署之后，过一会儿应该能看到效果了，应该能看到效果了。</p><h3 id="2-3-问题"><a href="#2-3-问题" class="headerlink" title="2.3 问题"></a>2.3 问题</h3><h4 id="2-3-1-未找到相关的lssues进行评论"><a href="#2-3-1-未找到相关的lssues进行评论" class="headerlink" title="2.3.1 未找到相关的lssues进行评论"></a>2.3.1 未找到相关的lssues进行评论</h4><p>如果出现以下提示，则<code>使用Github登录即可解决</code>。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_login.png"></p><h4 id="2-3-2-登录GitHub之后跳转博客首页"><a href="#2-3-2-登录GitHub之后跳转博客首页" class="headerlink" title="2.3.2 登录GitHub之后跳转博客首页"></a>2.3.2 登录GitHub之后跳转博客首页</h4><p>登录GitHub之后跳转到博客首页，主要是因为 <code>Homepage URL</code> 和 <code>Authorization callback URL</code>这两个地址错误引起的，我是因为注册 <code>OAuth应用</code> 的时候填写的博客地址，但是测试时用的 <code>http://localhost:4000/</code>，导致两个地址不匹配。</p><h4 id="2-3-3-Request-failed-with-status-code-403"><a href="#2-3-3-Request-failed-with-status-code-403" class="headerlink" title="2.3.3 Request failed with status code 403"></a>2.3.3 Request failed with status code 403</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403.png"></p><blockquote><p>遇到这个问题之后，我反复检查配置，发现跟别人讲解的都一样，但是自己的还是不能使用，像极了大多数家长教育自家孩子的那句话：为什么别人家的孩子都可以，就你不行【吐血】。那能怎么办呢，生活还是要继续，问题还是要解决。经过一番网上查找之后，发现遇到这个问题的不止我一个，真的是大有人在啊！</p></blockquote><p>首先有这个报错，肯定是有网络请求，F12 打开开发者工具，查看 <code>Network</code>项发现报错为:<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_developer.png"><br>这个请求是由 <code>https://cors-anywhere.herokuapp.com/</code> + <code>https://github.com/login/oauth/access_token</code>两部分组成，其实真正的请求地址是后面这个地址，是为了请求token，而 <a href="https://github.com/Rob--W/cors-anywhere"><strong>CORS Anywhere</strong></a> 是一个NodeJS代理，是一个开源框架，使用之后，可以在需要的时候做跨域请求，<code>CORS Anywhere</code> 为了确保每个人都可以使用该服务，每个周期的请求数都受到限制，但来自某些明确列入白名单的来源的请求除外。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_reason.png"><br>这个网站本来是演示用的，<strong>但是由于被滥用，从2021年1月31号开始停止开放，2.1开始用户只能手动先访问这个网站获取临时的访问权限，然后才能使用</strong>。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_solve.png"><br>从 <a href="https://gitalk.github.io/"><strong>Gitalk</strong></a>的 <code>issues</code> 中查到有两种解决方法：更新版本到1.7.2或者修改配置增加 <code>proxy</code>。修改配置增加 <code>proxy</code>方式如下（本博主题为 3-hexo）：</p><ol><li>打开 <code>themes/3-hexo/_config.yml</code>，将<code>gitalk</code>项添加 <code>proxy</code> 配置：<pre><code>gitalk:githubID: repo: ClientID: ClientSecret: adminUser: distractionFreeMode: truelanguage: zh-CNperPage: 10proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</code></pre></li><li>打开 <code>themes/3-hexo/layout/_partial/comments/gitalk.ejs</code> 文件，增加 <code>proxy: &#39;&lt;%=theme.gitalk.proxy %&gt;&#39;,</code>，完整代码为：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_solve_code.png"><br>重新部署Hexo之后，Gitalk评论就能使用了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 添加每日一言或诗词</title>
      <link href="posts/1bafec33.html"/>
      <url>posts/1bafec33.html</url>
      
        <content type="html"><![CDATA[<p>看到好多博客上都带有每日一言或者诗词功能，挺好看的，然后就按耐不住自己的小手手给自己的博客也安排上了。</p><h2 id="1-每日一言"><a href="#1-每日一言" class="headerlink" title="1.每日一言"></a>1.每日一言</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><blockquote><p>一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，有或是单纯的回忆。</p><p align="right">一言官方网站</p></blockquote><p>实现每日一言功能，需借助 <a href="https://links.jianshu.com/go?to=Hitokoto.cn">一言网</a>，创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。</p><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><p>关于每日一言如何使用，一言网关于<a href="https://pa-1251215871.cos-website.ap-chengdu.myqcloud.com/sentence/">语句接口</a>介绍的很详细，以下是以 <code>hexo-3-hexo</code>主题为例的使用说明：</p><p>首先打开主题的 <code>index.ejs</code>文件，路径<code>theme/3-hexo/layout/index.ejs</code>，将下面的代码添加到<code>&lt;body&gt;</code>之前:</p><pre><code>&lt;!-- 一言API --&gt;&lt;!-- 现代写法，推荐 --&gt;&lt;!-- 兼容低版本浏览器 (包括 IE)，可移除 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt;&lt;!--End--&gt;&lt;script&gt;  fetch(&#39;https://v1.hitokoto.cn&#39;)    .then(function (res)&#123;      return res.json();    &#125;)    .then(function (data) &#123;      var hitokoto = document.getElementById(&#39;hitokoto&#39;);      hitokoto.innerText = data.hitokoto + &#39;——【&#39; + data.from + &#39;】&#39;;    &#125;)    .catch(function (err) &#123;      console.error(err);    &#125;)&lt;/script&gt;</code></pre><p>然后再将下面的代码，添加到你想要添加的位置:</p><pre><code>&lt;p id=&quot;hitokoto&quot;&gt;正在加载一言...&lt;/p&gt;</code></pre><p>最后执行hexo三步连操作即可看到效果。</p><h2 id="2-今日诗词"><a href="#2-今日诗词" class="headerlink" title="2.今日诗词"></a>2.今日诗词</h2><p><a href="https://www.jinrishici.com/doc/#about">今日诗词API</a>，是一个可以返回一句古诗词名句的接口。它可以通过图片和 JSON 格式调用。今日诗词 API 根据不同地点、时间、节日、季节、天气、景观、城市进行智能推荐。</p><h3 id="2-1-修改样式"><a href="#2-1-修改样式" class="headerlink" title="2.1 修改样式"></a>2.1 修改样式</h3><p>修改今日诗词显示的样式，也可以不修改哟😜，在\themes\next\source\css\style.styl中适当位置添加以下样式代码：</p><pre><code>/*诗*/.poem-wrap &#123;    position: relative;    width: 730px;    max-width: 80%;    border: 2px solid #797979;    border-top: none;    text-align: center;    margin: 80px auto;&#125; .poem-wrap h1 &#123;    font-size: 30px;    position: relative;    margin-top: -20px;    display: inline-block;    letter-spacing: 4px;    color: #797979&#125; .poem-wrap p &#123;    width: 70%;    margin: auto;    line-height: 30px;    color: #797979;&#125; .poem-wrap p#poem &#123;    font-size: 25px;&#125; .poem-wrap p#info &#123;    font-size: 15px;    margin: 15px auto;&#125; .poem-border &#123;    position: absolute;    height: 2px;    width: 27%;    background-color: #797979;&#125; .poem-right &#123;    right: 0;&#125; .poem-left &#123;    left: 0;&#125; @media (max-width: 685px) &#123;    .poem-border &#123;        width: 18%;    &#125;&#125; @media (max-width: 500px) &#123;    .poem-wrap &#123;        margin-top: 60px;        margin-bottom: 20px;        border-top: 2px solid #797979;    &#125;     .poem-wrap h1 &#123;        margin: 20px 6px;    &#125;     .poem-border &#123;        display: none;    &#125;&#125;</code></pre><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p>在需要使用的 <code>.html</code> 文件或<code>.md</code>中添加:</p><pre><code>&lt;div class=&quot;poem-wrap&quot;&gt;  &lt;div class=&quot;poem-border poem-left&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;poem-border poem-right&quot;&gt;&lt;/div&gt;    &lt;h1&gt;今日诗词&lt;/h1&gt;    &lt;p id=&quot;poem&quot;&gt;挑选中...&lt;/p&gt;    &lt;p id=&quot;info&quot;&gt;  &lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    jinrishici.load(function(result) &#123;      poem.innerHTML = result.data.content      info.innerHTML = &#39;【&#39; + result.data.origin.dynasty + &#39;】&#39; + result.data.origin.author + &#39;《&#39; + result.data.origin.title + &#39;》&#39;      document.getElementById(&quot;poem&quot;).value(poem);      document.getElementById(&quot;info&quot;).value(info);    &#125;);  &lt;/script&gt;&lt;/div&gt;</code></pre><h3 id="2-3-效果"><a href="#2-3-效果" class="headerlink" title="2.3 效果"></a>2.3 效果</h3><div class="poem-wrap">  <div class="poem-border poem-left"></div>  <div class="poem-border poem-right"></div>    <h1>念两句诗</h1>    <p id="poem">挑选中...</p>    <p id="info">  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>  <script type="text/javascript">    jinrishici.load(function(result) {      poem.innerHTML = result.data.content      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'      document.getElementById("poem").value(poem);      document.getElementById("info").value(info);    });  </script></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 主题3-hexo</title>
      <link href="posts/5d51cb1e.html"/>
      <url>posts/5d51cb1e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>一千个读者心中有一千个哈姆雷特，同样的主题也可根据不同人的喜好演变成不同的风格，此博客是自己对主题3-hexo个性化定制的记录。</p></blockquote><h2 id="1-配置首页"><a href="#1-配置首页" class="headerlink" title="1.配置首页"></a>1.配置首页</h2><p>首页文件位置为 <code>/layout/indexs.md</code>，可根据自己需要来配置相关信息。</p><h3 id="1-1-添加每日一言或诗词"><a href="#1-1-添加每日一言或诗词" class="headerlink" title="1.1 添加每日一言或诗词"></a>1.1 添加每日一言或诗词</h3><p>关于如何添加每日一言或诗词，请查看 <a href="/posts/1bafec33.html">Hexo博客 — 添加每日一言或诗词</a></p><h2 id="2-左侧栏"><a href="#2-左侧栏" class="headerlink" title="2.左侧栏"></a>2.左侧栏</h2><h3 id="2-1-修改左侧栏宽度"><a href="#2-1-修改左侧栏宽度" class="headerlink" title="2.1 修改左侧栏宽度"></a>2.1 修改左侧栏宽度</h3><p>打开 <code>themes/_config.yml</code> 文件中，更改对应代码对应的宽度即可</p><pre><code>width:    lg: 120 # 1468px&lt;屏幕宽度 左侧分类宽度    md: 100 # 1024px&lt;屏幕宽度&lt;=1468px 左侧分类宽度    sm: 100 # 426px&lt;屏幕宽度&lt;=1024px 左侧分类宽度（ipad）</code></pre><h3 id="2-2-修改背景颜色"><a href="#2-2-修改背景颜色" class="headerlink" title="2.2 修改背景颜色"></a>2.2 修改背景颜色</h3><p>打开<code>themes/source/css/_partial/nav-left.styl</code>文件，将<code>.nav_left</code>的<code>background</code>设置成自己喜欢的颜色即可</p><h3 id="2-3-修改图片"><a href="#2-3-修改图片" class="headerlink" title="2.3 修改图片"></a>2.3 修改图片</h3><p><code>themes/source/img</code>文件中，<code>avatar.jpg</code>为头像，<code>weixin.jpg</code>和<code>alipay.jpg</code>分别对应打赏的微信和支付宝收款图片，直接将图片替换为自己的即可 </p><h2 id="3-文章列表栏"><a href="#3-文章列表栏" class="headerlink" title="3.文章列表栏"></a>3.文章列表栏</h2><h3 id="3-1-去除文章列表时间"><a href="#3-1-去除文章列表时间" class="headerlink" title="3.1 去除文章列表时间"></a>3.1 去除文章列表时间</h3><p>打开<code>themes/layout/_partial/nav_right.ejs</code> 文件，将下面代码删除即可</p><pre><code>&lt;span class=&quot;post-date&quot; title=&quot;&lt;%= date(post.date, &#39;YYYY-MM-DD HH:mm:ss&#39;)%&gt;&quot;&gt;&lt;%= date(post.date, &#39;YYYY/MM/DD&#39;) %&gt;&lt;/span&gt;</code></pre><h2 id="4-关于文章"><a href="#4-关于文章" class="headerlink" title="4.关于文章"></a>4.关于文章</h2><h3 id="4-1-字数统计"><a href="#4-1-字数统计" class="headerlink" title="4.1 字数统计"></a>4.1 字数统计</h3><pre><code>npm i --save hexo-wordcount</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- Markdown</title>
      <link href="posts/fcf4f4e7.html"/>
      <url>posts/fcf4f4e7.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Markdown概述"><a href="#1-Markdown概述" class="headerlink" title="1.Markdown概述"></a>1.Markdown概述</h2><h3 id="1-1-Markdown简介"><a href="#1-1-Markdown简介" class="headerlink" title="1.1 Markdown简介"></a>1.1 Markdown简介</h3><p>Markdown 是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">轻量级标记语言</a>，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由<a href="https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF">约翰·格鲁伯</a>创建。<br>Markdown 编写的文档可以导出 <code>HTML</code> 、<code>Word</code>、<code>图像</code>、<code>PDF</code>、<code>Epub</code> 等多种格式的文档。<br>Markdown 编写的文档后缀为 <code>.md</code>, <code>.markdown</code>。</p><h3 id="1-2-Markdown应用"><a href="#1-2-Markdown应用" class="headerlink" title="1.2 Markdown应用"></a>1.2 Markdown应用</h3><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于<code>论坛</code>上发表消息。如<code>GitHub</code>、<code>Reddit</code>、<code>Diaspora</code>、<code>Stack Exchange</code>、<code>OpenStreetMap</code> 、<code>SourceForge</code>、<code>简书</code>等，甚至还能被用来撰写<code>电子书</code>。</p><h2 id="2-Markdown基础技巧"><a href="#2-Markdown基础技巧" class="headerlink" title="2.Markdown基础技巧"></a>2.Markdown基础技巧</h2><h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>Markdown 支持两种标题的语法，类 <code>Setext</code> 和类 <code>atx</code> 形式。</p><h4 id="2-1-1-使用-和-标记一级和二级标题"><a href="#2-1-1-使用-和-标记一级和二级标题" class="headerlink" title="2.1.1 使用 = 和 - 标记一级和二级标题"></a>2.1.1 使用 <code>=</code> 和 <code>-</code> 标记一级和二级标题</h4><p>类 <code>Setext</code> 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><pre><code>我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><h4 id="2-1-2-使用-号标记"><a href="#2-1-2-使用-号标记" class="headerlink" title="2.1.2 使用 # 号标记"></a>2.1.2 使用 <code>#</code> 号标记</h4><p>使用 <code>#</code> 号可表示 <code>1-6</code> 级标题，一级标题对应一个 <code>#</code> 号，二级标题对应两个 <code>#</code> 号，以此类推:</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h3 id="2-2-段落格式"><a href="#2-2-段落格式" class="headerlink" title="2.2 段落格式"></a>2.2 段落格式</h3><h4 id="2-2-1-段落"><a href="#2-2-1-段落" class="headerlink" title="2.2.1 段落"></a>2.2.1 段落</h4><p>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在 <code>Visual Studio Code上</code>，<strong>段落的换行是使用两个以上空格加上回车</strong>。</p><h4 id="2-2-2-字体"><a href="#2-2-2-字体" class="headerlink" title="2.2.2 字体"></a>2.2.2 字体</h4><p>Markdown 可以使用以下几种字体：</p><pre><code>*斜体* 或 _斜体_**粗体** 或 __粗体文本__***加粗斜体*** 或 ___粗斜体文本___~~删除线~~++下划线++</code></pre><h4 id="2-2-3-对齐方式"><a href="#2-2-3-对齐方式" class="headerlink" title="2.2.3 对齐方式"></a>2.2.3 对齐方式</h4><pre><code>&lt;p align=&quot;left&quot;&gt;居左对齐&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;居右对齐&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;居中对齐&lt;/p&gt;</code></pre><h4 id="2-2-3-分隔线"><a href="#2-2-3-分隔线" class="headerlink" title="2.2.3 分隔线"></a>2.2.3 分隔线</h4><p>可以在一行中用三个以上的<code>*</code>(星号)、<code>-</code>(减号)、<code>_</code>(底线)来建立一个分隔线，行内不能有其他东西，也可以在星号或是减号中间插入空格:</p><pre><code>**** * ******- - -----------</code></pre><h4 id="2-2-4-删除线"><a href="#2-2-4-删除线" class="headerlink" title="2.2.4 删除线"></a>2.2.4 删除线</h4><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可:</p><pre><code>~~删除线~~</code></pre><h4 id="2-2-5-下划线"><a href="#2-2-5-下划线" class="headerlink" title="2.2.5 下划线"></a>2.2.5 下划线</h4><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现:</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><h3 id="2-3-列表"><a href="#2-3-列表" class="headerlink" title="2.3 列表"></a>2.3 列表</h3><h4 id="2-3-1-无序列表"><a href="#2-3-1-无序列表" class="headerlink" title="2.3.1 无序列表"></a>2.3.1 无序列表</h4><p>无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记，<strong>这些标记后面要添加一个空格</strong>，然后再填写内容:</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>以上三种写法显示效果一样，如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="2-3-2-有序列表"><a href="#2-3-2-有序列表" class="headerlink" title="2.3.2 有序列表"></a>2.3.2 有序列表</h4><p>有序列表使用<code>数字</code> + <code>.</code> 号来表示:</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>显示效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h4 id="2-3-3-列表嵌套"><a href="#2-3-3-列表嵌套" class="headerlink" title="2.3.3 列表嵌套"></a>2.3.3 列表嵌套</h4><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>显示效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h3 id="2-4-引用Blockquotes"><a href="#2-4-引用Blockquotes" class="headerlink" title="2.4 引用Blockquotes"></a>2.4 引用Blockquotes</h3><h4 id="2-4-1-普通引用"><a href="#2-4-1-普通引用" class="headerlink" title="2.4.1 普通引用"></a>2.4.1 普通引用</h4><p>Markdown 引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个<code>空格</code>符号:</p><pre><code>&gt; 学习是劳动，是充满思想的劳动。——乌申斯基</code></pre><p>显示效果如下：</p><blockquote><p>学习是劳动，是充满思想的劳动。——乌申斯基</p></blockquote><h4 id="2-4-2-引用嵌套"><a href="#2-4-2-引用嵌套" class="headerlink" title="2.4.2 引用嵌套"></a>2.4.2 引用嵌套</h4><p>引用是可以嵌套的，一个 <code>&gt;</code> 符号是最外层，两个 <code>&gt;</code> 符号是第一层嵌套，以此类推：</p><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>显示效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h4 id="2-4-3-引用中使用列表"><a href="#2-4-3-引用中使用列表" class="headerlink" title="2.4.3 引用中使用列表"></a>2.4.3 引用中使用列表</h4><p>引用中使用列表实例如下：</p><pre><code>&gt; 引用中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><p>显示效果如下：</p><blockquote><p>引用中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h4 id="2-4-4-列表中使用引用"><a href="#2-4-4-列表中使用引用" class="headerlink" title="2.4.4 列表中使用引用"></a>2.4.4 列表中使用引用</h4><p>如果要在列表项目内放进引用，那么就需要在 <code>&gt;</code> 前添加四个空格的缩进，实例如下：</p><pre><code>* 第一项    &gt; 学习呀    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><p>显示效果如下：</p><ul><li>第一项<blockquote><p>学习呀<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h3 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h3><h4 id="2-5-1-关键字"><a href="#2-5-1-关键字" class="headerlink" title="2.5.1 关键字"></a>2.5.1 关键字</h4><p>如果是段落上的一个函数或片段的代码可以用 `` 把它包起来：</p><pre><code>`code` 代码</code></pre><h4 id="2-5-2-代码块"><a href="#2-5-2-代码块" class="headerlink" title="2.5.2 代码块"></a>2.5.2 代码块</h4><ul><li>可以用 ``` 包裹一段代码，并指定一种语言，也可以不指定：</li><li>使用 <strong>4 个空格</strong>或者一个制表符（<strong>Tab 键</strong>）<br>效果如下：<pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="2-6-链接"><a href="#2-6-链接" class="headerlink" title="2.6 链接"></a>2.6 链接</h3><h4 id="2-6-1-常用链接"><a href="#2-6-1-常用链接" class="headerlink" title="2.6.1 常用链接"></a>2.6.1 常用链接</h4><pre><code>文字链接 [链接名称](http://链接网址)网址链接 &lt;http://链接网址&gt;</code></pre><h4 id="2-6-2-高级链接"><a href="#2-6-2-高级链接" class="headerlink" title="2.6.2 高级链接"></a>2.6.2 高级链接</h4><pre><code>这个链接用 1 作为网址变量 [Google][1].这个链接用 `百度` 作为网址变量 [百度!][百度].然后在文档的结尾为变量赋值（网址）  [1]: https://www.google.com/  [百度]: https://www.baidu.com/</code></pre><h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><p>跟链接的方法区别在于前面加了个感叹号 <code>!</code>:</p><pre><code>![图片名称](https://图片网址)</code></pre><p>也可以像网址那样对图片网址使用变量:</p><pre><code>这个链接用 1 作为网址变量 [Google][1].然后在文档的结尾位变量赋值（网址） [1]: https://www.google.com/logo.png</code></pre><blockquote><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签:<br><code>&lt;img src=&quot;https://developer.apple.com/home/images/hero-ios-14/ios-14-large_2x.png&quot; width=&quot;50%&quot;&gt;</code><br><img src="https://developer.apple.com/home/images/hero-ios-14/ios-14-large_2x.png" width="50%"></p></blockquote><h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p><pre><code>|  表头   | 表头  || :----: | :---: || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><blockquote><p>表格的对齐方式：<br><code>-:</code> 设置内容和标题栏居右对齐<br><code>:-</code> 设置内容和标题栏居左对齐<br><code>:-:</code> 设置内容和标题栏居中对齐</p></blockquote><h2 id="3-高级技巧"><a href="#3-高级技巧" class="headerlink" title="3 高级技巧"></a>3 高级技巧</h2><h3 id="3-1-行内-HTML-元素"><a href="#3-1-行内-HTML-元素" class="headerlink" title="3.1 行内 HTML 元素"></a>3.1 行内 HTML 元素</h3><p>目前只支持部分段内 HTML 元素效果，包括 <code>&lt;kdb&gt;</code> <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;em&gt;</code> <code>&lt;sup&gt;</code> <code>&lt;sub&gt;</code> <code>&lt;br&gt;</code> ，如:</p><ul><li>键位显示<pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre></li><li>代码块<pre><code>使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块</code></pre></li><li>粗斜体<pre><code>&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt;</code></pre></li></ul><h3 id="3-2-符号转义"><a href="#3-2-符号转义" class="headerlink" title="3.2 符号转义"></a>3.2 符号转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用<code>反斜杠</code>转义特殊字符：</p><pre><code>\_不想这里的文本变斜体\_\*\*不想这里的文本被加粗\*\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h2 id="4-在线Markdown编辑器"><a href="#4-在线Markdown编辑器" class="headerlink" title="4.在线Markdown编辑器"></a>4.在线Markdown编辑器</h2><ul><li><a href="http://markdown.xiaoshujiang.com/">【<strong>小书匠</strong>】</a>：专为markdown写作设计的文档编辑器，多种编辑模式，多种主题选择，丰富的语法支持。</li><li>【<strong>Visual Studio Code</strong>】：微软推出一款轻量级的文本编辑工具，类似于 Sublime。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 写文章</title>
      <link href="posts/2507c73c.html"/>
      <url>posts/2507c73c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建文章模版"><a href="#1-创建文章模版" class="headerlink" title="1.创建文章模版"></a>1.创建文章模版</h2><h3 id="1-1-文章模版"><a href="#1-1-文章模版" class="headerlink" title="1.1 文章模版"></a>1.1 文章模版</h3><p>为了新建文章方便，我们可以修改一下文章模板，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre><code>---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:tags:categories:---</code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，修改对应信息就可以了</p><h3 id="1-2-Front-matter"><a href="#1-2-Front-matter" class="headerlink" title="1.2 Front-matter"></a>1.2 Front-matter</h3><p><code>Front-matter</code> 选项中的所有内容均为非必填的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值</p><table><thead><tr><th align="center">配置选项</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">Markdown的文件标题</td><td align="center">文章标题</td></tr><tr><td align="center">date</td><td align="center">文件创建时的日期时间</td><td align="center">发布时间</td></tr><tr><td align="center">author</td><td align="center">根 <code>_config.yml</code> 中的 <code>author</code></td><td align="center">文章作者</td></tr><tr><td align="center">img</td><td align="center"><code>featureImages</code> 中的某个值</td><td align="center">文章特征图</td></tr><tr><td align="center">top</td><td align="center"><code>true</code></td><td align="center">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="center">cover</td><td align="center"><code>false</code></td><td align="center">表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="center">coverImg</td><td align="center">无</td><td align="center">表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="center">password</td><td align="center">无</td><td align="center">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="center">toc</td><td align="center"><code>true</code></td><td align="center">是否开启 <code>TOC</code>，可以针对某篇文章单独关闭 <code>TOC</code> 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="center">mathjax</td><td align="center"><code>false</code></td><td align="center">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="center">summary</td><td align="center">无</td><td align="center">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="center">categories</td><td align="center">无</td><td align="center">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="center">tags</td><td align="center">无</td><td align="center">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p>注意：</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code> 加密的 <code>password</code> 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 <code>SHA256</code> 加密的地址，可供使用：开源中国在线工具、chahuo、站长工具。</li></ol></blockquote><h2 id="2-创建文章"><a href="#2-创建文章" class="headerlink" title="2.创建文章"></a>2.创建文章</h2><h3 id="2-1-直接创建"><a href="#2-1-直接创建" class="headerlink" title="2.1 直接创建"></a>2.1 直接创建</h3><p>可以通过以下命令创建文章，该文件所在目录为 <code>_posts/xxxx.md</code></p><pre><code>$ hexo new xxxx.md</code></pre><h3 id="2-2-按分类创建文章"><a href="#2-2-按分类创建文章" class="headerlink" title="2.2 按分类创建文章"></a>2.2 按分类创建文章</h3><p>直接通过 <code>hexo new post xxxx.md</code> 来创建的文章，所有都在 <code>_posts</code>目录下，这样很不好归类查找，如果想在 _posts 目录下创建子目录分类文章的话，可通过下面方式创建</p><pre><code>$ hexo new post -p 目录1/目录2/.../文章.md</code></pre><h2 id="3-文章技巧"><a href="#3-文章技巧" class="headerlink" title="3.文章技巧"></a>3.文章技巧</h2><h3 id="3-1-文章添加图片"><a href="#3-1-文章添加图片" class="headerlink" title="3.1 文章添加图片"></a>3.1 文章添加图片</h3><h4 id="3-1-1-本地引用"><a href="#3-1-1-本地引用" class="headerlink" title="3.1.1 本地引用"></a>3.1.1 本地引用</h4><ol><li>绝对路径<br>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 <code>source/images</code> 文件夹中，通过 <code>markdown</code> 语法访问它们<pre><code>![](/images/image.jpg)</code></pre></li><li>相对路径<br>直接放在文章自己的目录中，需要将hexo根目录下的 <code>_config.yml</code> 配置文件中的 <code>post_asset_folder</code> 设为 <code>true</code> ，然后执行：<pre><code>$ cnpm install hexo-asset-image</code></pre>此时再执行命令 <code>hexo n article_name</code> 创建新的文章，在 <code>source/_posts</code> 中会生成文章 <code>post_name.md</code> 和同名文件夹 <code>post_name</code>，我们文章中所使用到的图片资源均放在 <code>post_name</code> 中，这时就可以在文章中使用相对路径引用图片资源了：<pre><code>![](img_name.jpg) //文章中的图片资源路径格式</code></pre><h4 id="3-1-2-CDN"><a href="#3-1-2-CDN" class="headerlink" title="3.1.2 CDN"></a>3.1.2 CDN</h4>将图片上传到一些免费的<code>CDN</code>服务中。比如 <code>Cloudinary</code> 提供的图片CDN服务，在 <code>Cloudinary</code> 中上传图片后，会生成对应的 <code>url</code>地址，将地址直接拿来引用即可。</li></ol><h3 id="3-2-生成永久文章链接"><a href="#3-2-生成永久文章链接" class="headerlink" title="3.2 生成永久文章链接"></a>3.2 生成永久文章链接</h3><p>hexo博客文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。比如：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_article_link.png" alt="image"><br>这样，如果文章标题是中文的话，URL链接是也会是中文。而且跳转站内文章填写链接的时候也不方便，修改文章标题后url就变了，以前的文章地址变成了404，就很不灵活，容易出错，所以生成唯一不变的URL链接很有必要。</p><h4 id="3-2-1-安装-hexo-abbrlink-插件"><a href="#3-2-1-安装-hexo-abbrlink-插件" class="headerlink" title="3.2.1 安装 hexo-abbrlink 插件"></a>3.2.1 安装 hexo-abbrlink 插件</h4><p>安装命令：</p><pre><code>npm install hexo-abbrlink --save</code></pre><h4 id="3-2-2-配置"><a href="#3-2-2-配置" class="headerlink" title="3.2.2 配置"></a>3.2.2 配置</h4><p>修改根目录配置文件 <code>config.yml</code>，改为：</p><pre><code># permalink: :year/:month/:day/:title/permalink: posts/:abbrlink.html  #此处可以自己设置，最终链接格式为：https://博客站点/permalinkabbrlink:    alg: crc32   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex</code></pre><p>生成完后，原 <code>md文件</code> 的 <code>Front-matter</code> 内会增加 <code>abbrlink</code> 字段，值为生成的<code>ID</code>。这个字段确保了在我们修改了博客标题title或创建日期date字段之后而不会改变链接地址。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 环境搭建</title>
      <link href="posts/5bd46458.html"/>
      <url>posts/5bd46458.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于博客"><a href="#1-关于博客" class="headerlink" title="1.关于博客"></a>1.关于博客</h2><p>喜欢写Blog的人，会经历三个阶段。</p><blockquote><p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p></blockquote><blockquote><p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p></blockquote><blockquote><p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p></blockquote><p>我们每个人的在网络上产生的数据越来越多，这些信息是我们在互联网上存在过的痕迹，值得我们认真对待。但是它们被分散分布在各个网站上。很多时候我们很难将它们聚合在一起，而且各个网站的信息排布方式也没有办法自由控制，所以我们需要一个可以由自己主宰的空间——博客。</p><p>通过博客，我们可以记录自己的生活和成长的轨迹。它不像 Twitter 那样碎片化，也不像 Facebook 那样关系化，它是私人的空间。</p><blockquote><p>之前写文章用的比较多的是印象笔记，较早时候感觉印象笔记还是挺好的，但是随着后来自己要求的慢慢变高，就觉得印象笔记里面编辑出来的文章样式不满足自己的需求，再加上创建带目录的文章竟然需要购买会员。然后就萌生自己搭建博客的想法，然后就从网上查了相关资料和介绍，在前人的基础上搭建了一个简单的博客(<code>Hexo+GitHub</code>)</p></blockquote><p>本篇博客旨在记录自己的搭建过程，方便以后的查看和修改，当然还有一些优化项和功能后续会慢慢更新。</p><h2 id="2-关于Hexo"><a href="#2-关于Hexo" class="headerlink" title="2.关于Hexo"></a>2.关于Hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a>基于<code>Node.js</code>，使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，可利用靓丽的主题生成静态网页，而且只需两三条命令即可将生成的网页上传到<code>github</code>等代码管理托管平台，简单、快速，是搭建博客的首选框架。</p><blockquote><p><code>Hexo</code>的作者是来自台湾的 <a href="https://zespia.tw/">Tommy Chen</a>，对中文的支持很友好，可以选择中文进行查看。</p></blockquote><p>Hexo特点:</p><ul><li>部署方便并且速度</li><li>支持 <code>Markdown</code>语法</li><li>使用极简命令即可部署到<code>GitHub Pages</code></li><li>高扩展性、可个性化定制</li><li>兼容于 <code>Windows</code>, <code>Mac</code> &amp; <code>Linux</code></li></ul><h2 id="3-搭建"><a href="#3-搭建" class="headerlink" title="3.搭建"></a>3.搭建</h2><p>本人使用Mac电脑，以此只记录了Mac电脑下的搭建过程</p><h3 id="3-1-安装Git"><a href="#3-1-安装Git" class="headerlink" title="3.1 安装Git"></a>3.1 安装Git</h3><p>什么是<code>Git</code>？关于<code>Git</code>，廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a>讲的特别好，大家可以去看看，也可以直接查看 <a href="https://git-scm.com/book/zh/v2">Git官网 Pro Git Book</a>中的讲解。而我们为了把本地的网页文件上传到<code>github</code>上面去，需要用到分布式版本控制工具<code>Git</code>。</p><p>在 <code>Mac</code> 上安装 <code>Git</code> 有多种方式。最简单的方法是安装 <code>Xcode Command Line Tools</code>。 Mavericks（10.9）或更高版本的系统中，在 <code>Terminal</code> 里尝试首次运行 <code>git</code> 命令即可。</p><pre><code>$ git --version</code></pre><p>如果没有安装过命令行开发者工具，将会提示你安装。</p><p>如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 macOS Git 安装程序可以在 Git 官方网站下载，网址为 <a href="https://git-scm.com/download/mac%E3%80%82">https://git-scm.com/download/mac。</a></p><pre><code>git --version</code></pre><blockquote><p>如果你想安装更新的版本，可以使用二进制安装程序。官方维护的 <code>macOS Git</code> 安装程序可以在 <code>Git</code> 官方网站下载，网址为 <a href="https://git-scm.com/download/mac">https://git-scm.com/download/mac</a></p></blockquote><h3 id="3-2-安装Node-js"><a href="#3-2-安装Node-js" class="headerlink" title="3.2 安装Node.js"></a>3.2 安装Node.js</h3><p>打开 <a href="https://nodejs.org/en/download/">Node.js</a> 下载页面，直接选择 <code>macOS Installer</code> 下载，然后双击已下载的<code>pkg</code>文件安装即可。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_node_js_download.png"><br>安装完成之后，可通过以下命令来检查是否安装成功:</p><pre><code>node -v</code></pre><h3 id="3-3-安装Hexo"><a href="#3-3-安装Hexo" class="headerlink" title="3.3 安装Hexo"></a>3.3 安装Hexo</h3><p>安装完 <code>Git</code> 和 <code>Node.js</code>之后，即可使用 <code>npm</code> 安装 <code>Hexo</code>。终端输入如下命令：</p><pre><code>sudo npm install -g hexo-cli</code></pre><p>安装完成之后输入 <code>hexo -v</code> 验证是否安装成功。</p><blockquote><p>Hexo官网上的安装命令是 <code>npm install -g hexo-cli</code>，但是实际安装的时候需要加上 <code>sudo</code>，否则会因为权限问题报错而导致安装失败</p></blockquote><h4 id="3-3-1-初始化"><a href="#3-3-1-初始化" class="headerlink" title="3.3.1 初始化"></a>3.3.1 初始化</h4><p>使用终端 <code>cd</code> 到一个文件目录，执行以下命令（命令中的 <code>Blog</code> 是要创建的博客文件夹）:</p><pre><code>hexo init Blog</code></pre><p>使用终端 <code>cd</code> 到 <code>Blog</code> 文件夹下，执行以下命令，安装必备的组件：</p><pre><code>cd Blognpm install</code></pre><p>安装完成之后，<code>Blog</code> 目录下有：</p><ul><li><code>node_modules</code>: 依赖包</li><li><code>public</code>: 存放生成的页面</li><li><code>scaffolds</code>: 生成文章的一些模板</li><li><code>source</code>: 用来存放你的文章</li><li><code>themes</code>: 安装的主题</li><li><code>_config.yml</code>: 博客的配置文件</li></ul><h4 id="3-3-2-本地预览"><a href="#3-3-2-本地预览" class="headerlink" title="3.3.2 本地预览"></a>3.3.2 本地预览</h4><p>经过上面步骤之后，基本的博客系统就已经搭建好了，而且自带了 <code>landscape</code> 主题，执行如下命令，开启本地 <code>Hexo</code> 服务器:</p><pre><code>sudo npm install hexo-server  //安装hexo serverhexo generate //或者 hexo g，生成静态页面hexo server //或者 hexo s，本地预览</code></pre><p>然后浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_landscape.png"></p><h3 id="3-4-将Hexo部署到GitHub-Pages"><a href="#3-4-将Hexo部署到GitHub-Pages" class="headerlink" title="3.4 将Hexo部署到GitHub Pages"></a>3.4 将Hexo部署到GitHub Pages</h3><h4 id="3-4-1-创建仓库"><a href="#3-4-1-创建仓库" class="headerlink" title="3.4.1 创建仓库"></a>3.4.1 创建仓库</h4><p>登录 <a href="https://github.com/">GitHub</a> 账号，新建名称为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 的仓库，具体如下图所示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_creat.png"></p><h4 id="3-4-2-开启GitHub-Pages"><a href="#3-4-2-开启GitHub-Pages" class="headerlink" title="3.4.2 开启GitHub Pages"></a>3.4.2 开启GitHub Pages</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_setting.png"><br>点击 <code>setting</code> ,打开创建的仓库的设置页面，滑动到 <code>GitHub Pages</code> 位置，进行如下设置，这样才能通过 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>来访问<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_pages.png"></p><h4 id="3-4-3-生成SSH添加到GitHub"><a href="#3-4-3-生成SSH添加到GitHub" class="headerlink" title="3.4.3 生成SSH添加到GitHub"></a>3.4.3 生成SSH添加到GitHub</h4><p><code>GitHub</code> 使用 <code>SSH</code> 公钥进行认证，关于 <code>SSH</code> 相关内容可以直接查看另一篇博客<a href="2021/03/07/%E5%B7%A5%E5%85%B7/Terminal/Terminal---%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5">Terminal—生成SSH公钥</a></p><p>在 <code>GitHub</code> 中，点击头像打开 <code>Setting</code> 页面，将 <code>SSH</code> 添加到 <code>SSH and GPG keys</code>中，如下图所示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_ssh.png"><br>然后在终端输入 <code>ssh -T git@github.com</code>，如果出现 <code>Hi xxx! You&#39;ve successfully authenticated...</code>，那么恭喜你，添加成功了。</p><h4 id="3-4-4-将Hexo部署到GitHub-Pages"><a href="#3-4-4-将Hexo部署到GitHub-Pages" class="headerlink" title="3.4.4 将Hexo部署到GitHub Pages"></a>3.4.4 将Hexo部署到GitHub Pages</h4><p>打开 <code>Blog</code> 根目录下的 <code>_config.yml</code> 文件，这是博客的配置文件，在这里可以修改博客配置的各种相关信息，修改 <code>deploy</code> 相关信息如下：</p><pre><code>deploy:  type: git  repository: https://github.com/xxx/xxx.github.io.git //此地址为自己github的仓库地址  branch: master</code></pre><blockquote><p>修改 <code>_config.yml</code> 文件时，所有的冒号 <code>:</code> 后面都要加一个空格，否则执行命令时会报错。</p></blockquote><p>配置之后，<code>Hexo</code> 和 <code>GitHub</code> 就能关联起来，部署时，就可以将生成的静态网页上传到上面填写的仓库中。</p><p>然后就可以通过下面命令，将本地 <code>Hexo</code> 博客部署到 <code>GitHub</code> 上：</p><pre><code>npm install hexo-deployer-git --save //安装 deploy-githexo clean  //清除之前生成的静态文件hexo g  //生成静态页面至public目录hexo d  //将.deploy目录部署到GitHub</code></pre><p>至此博客已部署完成，可以通过 <code>https://xxx.github.io/</code> 来访问你的博客啦！！！</p><h2 id="4-个性化定制"><a href="#4-个性化定制" class="headerlink" title="4.个性化定制"></a>4.个性化定制</h2><h3 id="4-1-基本配置"><a href="#4-1-基本配置" class="headerlink" title="4.1 基本配置"></a>4.1 基本配置</h3><p>在文件根目录下的 <code>_config.yml</code> ，就是整个hexo框架的配置文件，可在文件中设置博客站点的标题、副标题等相关信息。</p><h4 id="4-1-1-新建page"><a href="#4-1-1-新建page" class="headerlink" title="4.1.1 新建page"></a>4.1.1 新建page</h4><p>如果新建page页，可以使用</p><pre><code>hexo new page newpage</code></pre><p>系统会自动在<code>source</code>文件夹下创建一个<code>newpage</code>文件夹，以及<code>newpage</code>文件夹中的<code>index.md</code>，这样访问的<code>newpage</code>对应的链接就是<a href="http://xxx.xxx/newpage">http://xxx.xxx/newpage</a></p><h4 id="4-1-2-新建分类categories页"><a href="#4-1-2-新建分类categories页" class="headerlink" title="4.1.2 新建分类categories页"></a>4.1.2 新建分类categories页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;categories&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code>---title: categoriesdate: 2021-03-03 08:25:30type: &quot;categories&quot;layout: &quot;categories&quot;---</code></pre><h4 id="4-1-3-新建标签tags页"><a href="#4-1-3-新建标签tags页" class="headerlink" title="4.1.3 新建标签tags页"></a>4.1.3 新建标签tags页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;tags&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code>---title: tagsdate: 2021-03-03 08:25:30type: &quot;tags&quot;layout: &quot;tags&quot;---</code></pre><h4 id="4-1-4-新建关于我about页"><a href="#4-1-4-新建关于我about页" class="headerlink" title="4.1.4 新建关于我about页"></a>4.1.4 新建关于我about页</h4><p><code>about</code> 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;about&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code>---title: aboutdate: 2021-03-03 08:25:30type: &quot;about&quot;layout: &quot;about&quot;---</code></pre><h4 id="4-1-5-添加404页面"><a href="#4-1-5-添加404页面" class="headerlink" title="4.1.5 添加404页面"></a>4.1.5 添加404页面</h4><p>原来的主题没有<code>404</code>页面，我们加一个。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><pre><code>title: 404date: 2019-08-5 16:41:10type: &quot;404&quot;layout: &quot;404&quot;description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;</code></pre><p>网上好多都说要在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件(注：我安装的主题在该目录下已有<code>404.ejs</code>文件，无需自己创建)</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    /* don&#39;t remove. */    .about-cover &#123;        height: 75vh;    &#125;&lt;/style&gt;&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;                &lt;div class=&quot;brand&quot;&gt;                    &lt;div class=&quot;title center-align&quot;&gt;                        404                    &lt;/div&gt;                    &lt;div class=&quot;description center-align&quot;&gt;                        &lt;%= page.description %&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 每天切换 banner 图.  Switch banner image every day.    $(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);&lt;/script&gt;</code></pre><h3 id="4-2-更换主题"><a href="#4-2-更换主题" class="headerlink" title="4.2 更换主题"></a>4.2 更换主题</h3><p>hexo 搭建之后默认安装的主题是 <code>landscape</code>，更多风格主题查看 <a href="https://hexo.io/themes/">Hexo官网Themes</a>，可以从里面选择自己喜欢的主题进行安装。</p><h4 id="4-2-1-主题推荐"><a href="#4-2-1-主题推荐" class="headerlink" title="4.2.1 主题推荐"></a>4.2.1 主题推荐</h4><ul><li><a href="https://github.com/next-theme/hexo-theme-next">NexT主题</a>：简洁美观，目前Github上Star最高的Hexo主题，支持几种不同的风格。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_next.png"></li><li><a href="https://github.com/blinkfox/hexo-theme-matery">Metery主题</a>：简单漂亮，瀑布流式的文章列表，文章内容美观易读。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_matery.png"></li><li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">Wikitten主题</a>：简单，双列，分类管理，具备多层次分类知识，适用于个人Wiki知识管理。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_wikitten.png"></li></ul><h4 id="4-2-2-主题安装"><a href="#4-2-2-主题安装" class="headerlink" title="4.2.2 主题安装"></a>4.2.2 主题安装</h4><p>我们所有的主题都被放在根目录 <code>/themes</code> 文件夹下，可以将主题的的源码下载到 <code>/themes</code> 文件夹下，然后将 Hexo 根目录下的 <code>_config.yml</code> 中的主题设置为下载的主题：</p><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: 主题 #更改为自己下载的主题</code></pre><p>配置好后，执行 <code>hexo clean</code> 和 <code>hexo g &amp; s</code> 就能看到博客已经更换成新安装的主题风格了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
