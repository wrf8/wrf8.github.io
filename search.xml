<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XCode相关问题</title>
      <link href="posts/3904328560.html"/>
      <url>posts/3904328560.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-历史版本"><a href="#1-历史版本" class="headerlink" title="1. 历史版本"></a>1. 历史版本</h2><h3 id="1-1-下载地址"><a href="#1-1-下载地址" class="headerlink" title="1.1 下载地址"></a>1.1 下载地址</h3><p>下载地址：<a href="https://developer.apple.com/download/more/">https://developer.apple.com/download/more/</a><br><img src="https://upload-images.jianshu.io/upload_images/328067-370f6fc6b3621e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="屏幕快照 2019-09-16 下午4.44.53.png"></p><h2 id="2-Xcode-相关问题"><a href="#2-Xcode-相关问题" class="headerlink" title="2. Xcode 相关问题"></a>2. Xcode 相关问题</h2><h3 id="2-1-问题：XCode-11-新创建工程低版本黑屏的问题"><a href="#2-1-问题：XCode-11-新创建工程低版本黑屏的问题" class="headerlink" title="2.1 问题：XCode 11 新创建工程低版本黑屏的问题"></a>2.1 问题：XCode 11 新创建工程低版本黑屏的问题</h3><p>XCode 10创建工程：<br><img src="https://upload-images.jianshu.io/upload_images/328067-5c30a0c128bc9b8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-09-09 上午11.46.01.png"></p><p>XCode 11创建工程：<br><img src="https://upload-images.jianshu.io/upload_images/328067-7db0fa08f8639c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-09-09 上午11.45.21.png"></p><p>对比AppDelegate.h发现：缺少 <code>UIWindow *window</code> 的属性，所以我们直接在AppDelegate.h中按照以前的方法添加一个 <code>UIWindow *window</code> 的属性即可.<br><img src="https://upload-images.jianshu.io/upload_images/328067-f5f8ab2526d946a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="屏幕快照 2019-09-09 上午11.53.41.png"></p><h3 id="2-2-XCode打包"><a href="#2-2-XCode打包" class="headerlink" title="2.2 XCode打包"></a>2.2 XCode打包</h3><p><img src="https://upload-images.jianshu.io/upload_images/328067-40ba2c77d3879e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="屏幕快照 2019-09-23 下午6.07.56.png"></p><h4 id="2-2-1-问题1：Xcode-11打包报错“IPA-processing-failed”"><a href="#2-2-1-问题1：Xcode-11打包报错“IPA-processing-failed”" class="headerlink" title="2.2.1 问题1：Xcode 11打包报错“IPA processing failed”"></a>2.2.1 问题1：Xcode 11打包报错“IPA processing failed”</h4><p>原因：项目里面 <code>bitcode</code> 设置为 <code>NO</code>，打包时Xcode 默认选中了<code>Rebuild from Bitcode</code><br><img src="https://upload-images.jianshu.io/upload_images/328067-b4e96e19a1797b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="屏幕快照 2019-09-23 下午6.08.24.png"><br>解决办法：将 <code>Rebuild from Bitcode</code> 取消选中即可。</p><h4 id="2-2-1-问题2：Xcode-12打包报错“IPA-processing-failed”"><a href="#2-2-1-问题2：Xcode-12打包报错“IPA-processing-failed”" class="headerlink" title="2.2.1 问题2：Xcode 12打包报错“IPA processing failed”"></a>2.2.1 问题2：Xcode 12打包报错“IPA processing failed”</h4><p>原因：某一个动态库打包的时候没有移除模拟器架构<br>解决方法：</p><pre><code>//方法一：1,、终端cd到framework所在的目录2、查看SDK的二进制文件支持的CPU架构，如果只显示armv7 arm64，那么就没问题，如果有模拟器的架构x86_64, i386那就是有问题lipo -info XXX.framework/XXX3、移除支持x86_64,i386的二进制文件lipo XXX.framework/XXX -remove x86_64 -remove i386 -output XXX4、替换framwork内部二进制文件[记得备份]mv XXX XXX.framework/XXX5、查看剥离后的二进制文件支持的CPU架构，如果显示armv7 arm64，就完成剥离，可上传AppStorelipo -info XXX.framework/XXX</code></pre><pre><code>//方法二：buildPhases-&gt;New Run Script Phase添加以下内容APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;# This script loops through the frameworks embedded in the application and# removes unused architectures.find &quot;$APP_PATH&quot; -name &#39;*.framework&#39; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;EXTRACTED_ARCHS=()for ARCH in $ARCHSdoecho &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)doneecho &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;echo &quot;Replacing original executable with thinned version&quot;rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;done</code></pre><h4 id="2-2-2-问题：XCode-11打包上传App-Store一直卡在Authenticating-with-the-itunes-store"><a href="#2-2-2-问题：XCode-11打包上传App-Store一直卡在Authenticating-with-the-itunes-store" class="headerlink" title="2.2.2 问题：XCode 11打包上传App Store一直卡在Authenticating with the itunes store"></a>2.2.2 问题：XCode 11打包上传App Store一直卡在<code>Authenticating with the itunes store</code></h4><p>原因：</p><ol><li>Xcode更新到11之后，可以通过XCode直接上传，也可以用上传工具<code>Transporter</code>，但最后上传包是通过程序<code>iTMSTransporter</code>来完成的。</li><li>第一次上传包的时候会在硬盘目录：/用户/你的电脑登录账号名/资源库/Caches/com.apple.amp.itmstransporter/目录下下载一些缓存文件，这些缓存文件没有下载完，或者下载失败没下载完时，提交应用这个页面就会卡住或者这个页面很慢。</li></ol><p>解决办法：</p><pre><code>1. 直接下载`com.apple.amp.itmstransporter `文件覆盖原有文件，链接:https://pan.baidu.com/s/1V9btJT01cNhGubINP7Hjxg  密码:van72. 把解压后的`com.apple.amp.itmstransporter`目录放到`/用户/你的电脑登录账号名/资源库/Caches/`目录下，覆盖你原有的`com.apple.amp.itmstransporter`目录3. 将新的`com.apple.amp.itmstransporter`目录下/obr/2.0.0/目录下的repository.xml文件中的所有`Simpsons`修改为你自己电脑的登录账号名，否则上传时会在错误的路径下找资源文件4. 再次尝试上传</code></pre><h2 id="2-3-XCode-添加-pch-文件"><a href="#2-3-XCode-添加-pch-文件" class="headerlink" title="2.3 XCode 添加 pch 文件"></a>2.3 XCode 添加 pch 文件</h2><p>1、File &gt; New &gt; File &gt; iOS &gt; Other &gt; PCH File 创建pch文件<br>2、Tartet -&gt; Build Settings -&gt; 搜索 Prefix Header -&gt; 将创建的pch文件路径写入</p><p><img src="https://upload-images.jianshu.io/upload_images/328067-001d2318262c0b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-11-29 上午9.04.04.png"></p><h2 id="2-4-XCode-注释"><a href="#2-4-XCode-注释" class="headerlink" title="2.4 XCode 注释"></a>2.4 XCode 注释</h2><pre><code>Command + / 注释单行代码Command + option + / 可以对属性和类以及方法进行注释#pragma mark  &lt;#注释的内容#&gt;</code></pre><h2 id="2-5-其他报错"><a href="#2-5-其他报错" class="headerlink" title="2.5 其他报错"></a>2.5 其他报错</h2><h3 id="2-5-1-使用模拟器时Xcode控制打印-Sending-selectors-failed-with-Error-Domain-NSCocoaErrorDomain-Code-4099"><a href="#2-5-1-使用模拟器时Xcode控制打印-Sending-selectors-failed-with-Error-Domain-NSCocoaErrorDomain-Code-4099" class="headerlink" title="2.5.1 使用模拟器时Xcode控制打印 Sending selectors failed with: Error Domain=NSCocoaErrorDomain Code=4099"></a>2.5.1 使用模拟器时Xcode控制打印 <code>Sending selectors failed with: Error Domain=NSCocoaErrorDomain Code=4099</code></h3><p><img src="https://upload-images.jianshu.io/upload_images/328067-f8927fac9277fe46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-12-24 上午9.37.15.png"><br>解决方法：</p><ul><li>在终端输入如下命令：<pre><code>xcrun simctl spawn booted log config --mode &quot;level:off&quot;  --subsystem com.apple.CoreTelephony</code></pre></li></ul><h3 id="2-5-2-XCode运行别人项目代码出现-No-account-for-team-quot-8PC4X7QUY9-quot-Add-a-new-account-in-the-Accounts-preference-pane-or-verify-that-your-accounts-have-valid-credentials"><a href="#2-5-2-XCode运行别人项目代码出现-No-account-for-team-quot-8PC4X7QUY9-quot-Add-a-new-account-in-the-Accounts-preference-pane-or-verify-that-your-accounts-have-valid-credentials" class="headerlink" title="2.5.2 XCode运行别人项目代码出现 No account for team &quot;8PC4X7QUY9&quot;. Add a new account in the Accounts preference pane or verify that your accounts have valid credentials"></a>2.5.2 XCode运行别人项目代码出现 <code>No account for team &quot;8PC4X7QUY9&quot;. Add a new account in the Accounts preference pane or verify that your accounts have valid credentials</code></h3><p>解决方法：</p><pre><code>1. 复制错误码：8PC4X7QUY92. 在 Target -&gt; Building 搜索 `8PC4X7QUY9`，并将其去掉重新运行即可</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/328067-637325aa1608a574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="2-5-3-XCode-出现dyld-Library-not-loaded-rpath-XXX-framework的错误"><a href="#2-5-3-XCode-出现dyld-Library-not-loaded-rpath-XXX-framework的错误" class="headerlink" title="2.5.3 XCode 出现dyld: Library not loaded: @rpath/XXX.framework的错误"></a>2.5.3 XCode 出现<code>dyld: Library not loaded: @rpath/XXX.framework</code>的错误</h3><p>解决办法：</p><pre><code>1. Targets -&gt; Build Phases 点击+ 选择`New Copy Files`2. `Destination`选择+，把提示报错的framework添加在这里</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> iOS-工具篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS优化 --- IPA包大小优化</title>
      <link href="posts/4187382084.html"/>
      <url>posts/4187382084.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>苹果对 iOS App 大小有严格限制：<strong>下载大小</strong>超限会阻碍用户在蜂窝网络下载 App ，直接影响新用户转化；<strong>可执行文件</strong>超限将导致 App 审核被拒，直接影响上架。</p><h3 id="1-1-下载大小限制"><a href="#1-1-下载大小限制" class="headerlink" title="1.1 下载大小限制"></a>1.1 下载大小限制</h3><p>App 大小有下载大小和安装大小的概念:</p><ul><li><code>下载大小</code>是指 App 压缩包（也就是 <code>.ipa</code> 文件）所占的空间，用户在下载 App 时，下载的是压缩包，这样做可以节省流量；当压缩包下载完成后，就会自动解压，解压过程也就是通常所说的安装过程；</li><li><code>安装大小</code>就是指压缩包解压后所占用的空间。</li></ul><p>安装大小在 App Store 上就可以看见 ，通常它会影响用户的下载意愿：<br><img src="/images/iOS/iOS-%E4%BC%98%E5%8C%96/ipa%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96_%E5%AE%89%E8%A3%85%E5%A4%A7%E5%B0%8F.png"><br>而下载大小只有开发者在 <code>App Store Connect</code> 后台才可以看，用户看不见，它影响的是下载消耗的流量和时长：<br><img src="/images/iOS/iOS-%E4%BC%98%E5%8C%96/ipa%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96_%E4%B8%8B%E8%BD%BD%E5%A4%A7%E5%B0%8F.png"></p><p>若<strong>下载大小</strong>超过限制，将无法使用蜂窝网络下载 App（ iOS 13 之前），会收到文件容量太大的提示，需通过 Wi-Fi 网络下载。如下，为苹果历年来对 App 下载大小限制的变化情况：</p><ul><li>2008 年 7 月，搭载了 App Store 的 iPhone 3G 正式发售，下载限制仅为 10 MB</li><li>2010 年 2 月，苹果将 iPhone 3G 的下载限制从 10 MB 提升到 20 MB</li><li>2012 年 3 月，iOS 5.1 正式版后，下载限制从 20 MB 提升到 50 MB</li><li>2013 年 9 月，iOS 7 正式版后，下载限制从 50 MB 提升至 100 MB</li><li>2017 年 9 月，iOS 11 正式版后，下载限制从 100 MB 提升至 150 MB</li><li>2019 年 5 月，下载限制从 150 MB 提升至 200 MB</li><li>2019 年 9 月，iOS 13 正式版后，若下载大小超过 200 MB，用户可选择是否使用蜂窝网络下载</li></ul><p>如今，App 下载大小超出 200 MB 时 ，会出现两种情况：</p><ul><li>iOS 13 以下的用户，无法通过蜂窝数据下载 App</li><li>iOS 13 及以上的用户，需要手动设置才可以使用蜂窝网络下载 App<br><img src="/images/iOS/iOS-%E4%BC%98%E5%8C%96/ipa%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96_%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%B8%8B%E8%BD%BDApp.png"></li></ul><h3 id="1-2-可执行文件大小限制"><a href="#1-2-可执行文件大小限制" class="headerlink" title="1.2 可执行文件大小限制"></a>1.2 可执行文件大小限制</h3><p>根据 <a href="https://help.apple.com/app-store-connect/#/dev611e0a21f">最大构建版本文件大小</a> 中描述，苹果对可执行文件大小亦有明确限制，超过该限制会导致 App 无法提交App Store：</p><pre><code>ERROR: ERROR ITMS-90122: &quot;Invalid ExecutaBe Size. The size of your app&#39;s executaBe file &#39;News.app/News&#39; is 68534272 bytes for architecture &#39;arm64&#39;, which exceeds the maximum allowed size of 60 MB.&quot;</code></pre><p>具体限制如下：<br><img src="/images/iOS/iOS-%E4%BC%98%E5%8C%96/ipa%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96_%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> iOS-优化篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods --- 安装和使用</title>
      <link href="posts/206885443.html"/>
      <url>posts/206885443.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-CocoaPods简介"><a href="#1-CocoaPods简介" class="headerlink" title="1.CocoaPods简介"></a>1.CocoaPods简介</h2><p>CocoaPods是专门为iOS工程提供第三方依赖库的管理工具，通过CocoaPods，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置，就可以直观、集中和自动化地管理我们项目的第三方库。</p><p>CocoaPods将所有依赖的库都放在一个名为Pods的项目下，然后让主项目依赖Pods项目。然后，我们编码工作都从主项目转移到Pods项目。Pods项目最终会编译为一个 <code>libPod-项目名.a</code> 静态库，主项目依赖于这个静态库。</p><p>对于资源文件，CocoaPods 提供了一个名为 <code>Pods-resources.sh</code> 的 <code>bash</code> 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。</p><p>CocoaPods 通过一个名为 <code>Pods.xcconfig</code> 的文件来在编译时设置所有的依赖和参数。</p><p>CocoaPods是用 Ruby 写的，由若干个 <code>Ruby</code> 包 (<code>gems</code>) 构成，在解析整合过程中，最重要的几个 <code>gems</code> 分别是： </p><ul><li><a href="https://links.jianshu.com/go?to=https://github.com/CocoaPods/CocoaPods/">CocoaPods/CocoaPods</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/CocoaPods/Core">CocoaPods/Core</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/CocoaPods/Xcodeproj">CocoaPods/Xcodeproj</a></li></ul><h2 id="2-CocoaPods的核心组件"><a href="#2-CocoaPods的核心组件" class="headerlink" title="2.CocoaPods的核心组件"></a>2.CocoaPods的核心组件</h2><ul><li><p>CocoaPods/CocoaPod<br>这是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 <code>gems</code> 来执行任务。</p></li><li><p>CocoaPods/Core<br>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 <code>Podfile</code> 和 <code>podspecs</code>。</p></li><li><p>Podfile<br>Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <code>Podfile</code> 指南。</p></li><li><p>Podspec<br><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</p></li><li><p>CocoaPods/Xcodeproj<br>这个 <code>gem</code> 组件负责所有工程文件的整合。它能够创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 <code>gem</code> 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 <code>gem</code>。</p></li></ul><h2 id="3-CocoaPods的安装和使用"><a href="#3-CocoaPods的安装和使用" class="headerlink" title="3.CocoaPods的安装和使用"></a>3.CocoaPods的安装和使用</h2><h3 id="3-1-安装rvm"><a href="#3-1-安装rvm" class="headerlink" title="3.1 安装rvm"></a>3.1 安装rvm</h3><p>检查Mac是否安装了rvm，打开终端，输入指令：</p><pre><code>rvm -v</code></pre><ul><li>如果不存在，则会出现下面的情况：</li></ul><pre><code>Last login: Thu Sep 19 08:32:35 on consolebogon:~ wangruifang$ rvm -v-bash: rvm: command not found</code></pre><ul><li>如果存在，则会打印rvm的版本信息：</li></ul><pre><code>bogon:~ wangruifang$ rvm -vrvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]</code></pre><p>如果不存在，先要安装一下，依次输入以下命令：</p><pre><code>curl -L get.rvm.io | bash -s stablesource ~/.bashrcsource ~/.bash_profile</code></pre><p>升级rvm到最新的稳定版本命令：</p><pre><code>rvm get stable</code></pre><h3 id="3-2-安装ruby"><a href="#3-2-安装ruby" class="headerlink" title="3.2 安装ruby"></a>3.2 安装ruby</h3><h4 id="3-2-1-查询ruby所有可安装的版本信息："><a href="#3-2-1-查询ruby所有可安装的版本信息：" class="headerlink" title="3.2.1 查询ruby所有可安装的版本信息："></a>3.2.1 查询ruby所有可安装的版本信息：</h4><pre><code>rvm list known</code></pre><p>结果如下：</p><pre><code>[ruby-]1.8.6[-p420][ruby-]1.8.7[-head] # security released on head[ruby-]1.9.1[-p431][ruby-]1.9.2[-p330][ruby-]1.9.3[-p551][ruby-]2.0.0[-p648][ruby-]2.1[.10][ruby-]2.2[.10][ruby-]2.3[.8][ruby-]2.4[.6][ruby-]2.5[.5][ruby-]2.6[.3][ruby-]2.7[.0-preview1]ruby-head···</code></pre><h4 id="3-2-2-选择一个ruby版本进行安装"><a href="#3-2-2-选择一个ruby版本进行安装" class="headerlink" title="3.2.2 选择一个ruby版本进行安装"></a>3.2.2 选择一个ruby版本进行安装</h4><blockquote><p>2.6.3为最新正式版版本，2.7.0为测试版</p></blockquote><pre><code>rvm install 2.6.3// 注意:安装过程中需要两次按下 Enter 键, 第二次按下后需要输入电脑访问密码(不可见,只管输入就行);// 如果你电脑没有安装Xcode和Command Line Tools for Xcode以及Homebrew 会自动下载安装,建议提前安装这三者.</code></pre><h4 id="3-2-3-设置为默认版本"><a href="#3-2-3-设置为默认版本" class="headerlink" title="3.2.3 设置为默认版本"></a>3.2.3 设置为默认版本</h4><pre><code>rvm use 2.6.3 --default</code></pre><h3 id="3-3-检查更新ruby版本环境"><a href="#3-3-检查更新ruby版本环境" class="headerlink" title="3.3 检查更新ruby版本环境"></a>3.3 检查更新ruby版本环境</h3><p>cocoapods是用<code>gem ruby</code>实现的，想要使用它首先需要有<code>gem ruby</code>的环境。且Mac的OS X系统默认已经可以运行<code>ruby</code>。</p><p>检查 <code>gem ruby</code> 版本号：</p><pre><code>sudo gem -v</code></pre><p>更新 <code>gem ruby</code> 版本号：</p><pre><code>sudo gem update --system</code></pre><h3 id="3-4-检查更新ruby源"><a href="#3-4-检查更新ruby源" class="headerlink" title="3.4 检查更新ruby源"></a>3.4 检查更新ruby源</h3><h4 id="3-4-1-检查ruby源"><a href="#3-4-1-检查ruby源" class="headerlink" title="3.4.1 检查ruby源"></a>3.4.1 检查ruby源</h4><pre><code>bogon:~ wangruifang$ gem sources -l *** CURRENT SOURCES ***https://rubygems.org/</code></pre><h4 id="3-4-2-替换国内镜像源"><a href="#3-4-2-替换国内镜像源" class="headerlink" title="3.4.2 替换国内镜像源"></a>3.4.2 替换国内镜像源</h4><p>之所以要添加国内的 <code>ruby-china</code>源，是因为<code>taobao</code>源已经停止维护了，所以此处替换的是<code>ruby-china</code>源，且尽量确保只有一个。</p><pre><code>//移除原有镜像源：gem sources --remove https://rubygems.org///添加国内镜像源gem sources --add https://gems.ruby-china.org</code></pre><h3 id="3-5-安装CocoaPods"><a href="#3-5-安装CocoaPods" class="headerlink" title="3.5 安装CocoaPods"></a>3.5 安装CocoaPods</h3><pre><code>sudo gem install cocoapods</code></pre><p>OS X EL Capitan 或 macOS High Sierra System 后改为：</p><pre><code>sudo gem install -n /usr/local/bin cocoa pods</code></pre><p>如果安装了多个Xcode使用下面的命令选择（一般需要选择最近的Xcode版本）</p><pre><code>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer</code></pre><p>设置pod：</p><pre><code>pod setup</code></pre><h3 id="3-6-创建一个工程，并创建Podfile配置文件"><a href="#3-6-创建一个工程，并创建Podfile配置文件" class="headerlink" title="3.6 创建一个工程，并创建Podfile配置文件"></a>3.6 创建一个工程，并创建Podfile配置文件</h3><p>先用 <code>cd</code> 进入到工程中去，输入指令<code>vim podfile</code> 创建 <code>Podfile</code> 文件，然后按 <code>i</code> 进入到编辑模式来配置 <code>Podfile</code> 文件：</p><pre><code>platform :ios, &#39;9.0&#39;target “target名称” dopod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;end</code></pre><p>按 <code>Esc</code> 退出编辑，按 <code>Shift +冒号</code>，输入 <code>wq</code> 退出文件编辑，然后下载 <code>Podfile</code> 文件内的第三方，执行命令：</p><pre><code>pod install</code></pre><h3 id="3-7-pod命令"><a href="#3-7-pod命令" class="headerlink" title="3.7 pod命令"></a>3.7 pod命令</h3><pre><code># 第一次使用安装框架    //只用安装一次,之后使用 添加删除都用 pod update --no-repo-update $ pod install# 安装框架，不更新本地索引，速度快$ pod install --no-repo-update # 今后升级、添加、删除框架，或者框架不好用$ pod update# 更新框架，不更新本地索引，速度快$ pod update --no-repo-update # 搜索框架$ pod search XXX# 帮助$ pod --help</code></pre><h2 id="4-CocoaPods使用过程中遇到的问题"><a href="#4-CocoaPods使用过程中遇到的问题" class="headerlink" title="4.CocoaPods使用过程中遇到的问题"></a>4.CocoaPods使用过程中遇到的问题</h2><h3 id="4-1-去除CocoaPods相关库警告"><a href="#4-1-去除CocoaPods相关库警告" class="headerlink" title="4.1 去除CocoaPods相关库警告"></a>4.1 去除CocoaPods相关库警告</h3><h4 id="4-1-1-去除所有警告"><a href="#4-1-1-去除所有警告" class="headerlink" title="4.1.1 去除所有警告"></a>4.1.1 去除所有警告</h4><p>去除所有警告，在 <code>platform :ios, ‘x.0’</code> 的后面加入这句：</p><pre><code>inhibit_all_warnings!</code></pre><h4 id="4-1-2-消除单个警告："><a href="#4-1-2-消除单个警告：" class="headerlink" title="4.1.2 消除单个警告："></a>4.1.2 消除单个警告：</h4><pre><code>pod &#39;MJExtension&#39;,&#39;~&gt;3.0.15.1&#39;,:inhibit_warnings =&gt; true</code></pre><h3 id="4-2-Unable-to-find-a-pod-with-name…"><a href="#4-2-Unable-to-find-a-pod-with-name…" class="headerlink" title="4.2 Unable to find a pod with name…"></a>4.2 Unable to find a pod with name…</h3><p><strong>问题：</strong><code>[!] Unable to find a pod with name, author, summary, or description matching xxx.</code></p><p><strong>解决办法：</strong>删除 <code>~/Library/Caches/CocoaPods</code> 目录下的 <code>search_index.json</code> 文件</p><pre><code>rm ~/Library/Caches/CocoaPods/search_index.json</code></pre><h3 id="4-3-CDN-trunk-URL-couldn’t-be-downloaded…"><a href="#4-3-CDN-trunk-URL-couldn’t-be-downloaded…" class="headerlink" title="4.3 CDN: trunk URL couldn’t be downloaded…"></a>4.3 CDN: trunk URL couldn’t be downloaded…</h3><p><strong>问题：</strong><code>[!] CDN: trunk URL couldn&#39;t be downloaded: https://raw.githubusercontent.com/CocoaPods/Specs/master/Specs/2/e/7/YTKNetworkExtension/0.1.0/YTKNetworkExtension.podspec.json, error: Failed to open TCP connection to raw.githubusercontent.com:443 (Connection refused - connect(2) for &quot;raw.githubusercontent.com&quot; port 443)</code></p><p><strong>问题原因：</strong>CocoaPods 1.8+将CDN切换为默认的 <code>spec repo</code>源，并附带一些增强功能！CDN支持最初是在1.7版本中引入的，最终在1.7.2中完成。 它旨在大大加快初始设置和依赖性分析。</p><p><strong>解决办法：</strong></p><ol><li>podfile文件中添加source源：<code>source &#39;https://github.com/CocoaPods/Specs.git</code></li><li>移除 <code>trunk</code></li></ol><pre><code>pod repo remove trunk</code></pre><h3 id="4-4-xxxxx-does-not-specify-a-Swift-version…"><a href="#4-4-xxxxx-does-not-specify-a-Swift-version…" class="headerlink" title="4.4 xxxxx  does not specify a Swift version…"></a>4.4 xxxxx  does not specify a Swift version…</h3><p><strong>问题：</strong><code> xxxxx  does not specify a Swift version and none of the targets (Pods) integrating it have the SWIFT_VERSION attribute set. Please contact the author or set the SWIFT_VERSION attribute in at least one of the targets that integrate this pod</code></p><p><strong>解决办法：</strong>在podfile文件添加<code>use_frameworks!</code></p><pre><code>target ‘Project_xx’ do  use_frameworks!end</code></pre><h3 id="4-5-Failed-to-extract-git-version-from-git-–version…"><a href="#4-5-Failed-to-extract-git-version-from-git-–version…" class="headerlink" title="4.5 Failed to extract git version from git –version…"></a>4.5 Failed to extract git version from git –version…</h3><p><strong>问题：</strong>升级Mac OS之后执行pod命令出现<code>Failed to extract git version from git --version (&quot;xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n&quot;) (RuntimeError)</code></p><p><strong>解决办法：</strong>重装 <code>xcode command line</code>：</p><pre><code>xcode-select --install</code></pre><p>如果没有解决问题，执行以下命令</p><pre><code>sudo xcode-select -switch /</code></pre><h3 id="4-6-curl-56-LibreSSL-SSL-read-SSL-ERROR-SYSCALL"><a href="#4-6-curl-56-LibreSSL-SSL-read-SSL-ERROR-SYSCALL" class="headerlink" title="4.6 curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL"></a>4.6 curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL</h3><p><strong>问题：</strong>pod install时出现<code>error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54</code>错误</p><p><strong>解决办法：</strong></p><pre><code>git config --global http.postBuffer 524288000</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> iOS-工具篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 高级运算符</title>
      <link href="posts/620084014.html"/>
      <url>posts/620084014.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-位运算符"><a href="#1-位运算符" class="headerlink" title="1.位运算符"></a>1.位运算符</h2><p>Swift 支持 C 语言中的全部位运算符。</p><h3 id="1-1-按位取反运算符"><a href="#1-1-按位取反运算符" class="headerlink" title="1.1 按位取反运算符 ~"></a>1.1 按位取反运算符 <code>~</code></h3><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D.png"></p><p>按位取反运算符是一个前缀运算符，直接放在运算数之前，并且它们之间不能添加任何空格：</p><pre><code>let initialBits: UInt8 = 0b00001111let invertedBits = ~initialBits // 等于 0b11110000</code></pre><h3 id="1-2-按位与运算符-amp"><a href="#1-2-按位与运算符-amp" class="headerlink" title="1.2 按位与运算符 &amp;"></a>1.2 按位与运算符 <code>&amp;</code></h3><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%8C%89%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p><pre><code>let firstSixBits: UInt8 = 0b11111100let lastSixBits: UInt8  = 0b00111111let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100</code></pre><h3 id="1-3-按位或运算符"><a href="#1-3-按位或运算符" class="headerlink" title="1.3 按位或运算符 |"></a>1.3 按位或运算符 <code>|</code></h3><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%8C%89%E4%BD%8D%E6%88%96.png"></p><pre><code>let someBits: UInt8 = 0b10110010let moreBits: UInt8 = 0b01011110let combinedbits = someBits | moreBits // 等于 11111110</code></pre><h3 id="1-4-按位异或运算符"><a href="#1-4-按位异或运算符" class="headerlink" title="1.4 按位异或运算符 ^"></a>1.4 按位异或运算符 <code>^</code></h3><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96.png"></p><pre><code>let firstBits: UInt8 = 0b00010100let otherBits: UInt8 = 0b00000101let outputBits = firstBits ^ otherBits // 等于 00010001</code></pre><h3 id="1-5-按位左移-lt-lt-、右移运算符-gt-gt"><a href="#1-5-按位左移-lt-lt-、右移运算符-gt-gt" class="headerlink" title="1.5 按位左移 &lt;&lt;、右移运算符 &gt;&gt;"></a>1.5 按位左移 <code>&lt;&lt;</code>、右移运算符 <code>&gt;&gt;</code></h3><p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。</p><h4 id="1-5-1-无符号整数的移位运算"><a href="#1-5-1-无符号整数的移位运算" class="headerlink" title="1.5.1 无符号整数的移位运算"></a>1.5.1 无符号整数的移位运算</h4><p>对无符号整数进行移位的规则如下：</p><ol><li>已存在的位按指定的位数进行左移和右移。</li><li>任何因移动而超出整型存储范围的位都会被丢弃。</li><li>用 <code>0</code> 来填充移位后产生的空白位。</li></ol><p>这种方法称为<code>逻辑移位</code>。<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97.png"></p><pre><code>let shiftBits: UInt8 = 4 // 即二进制的 00000100shiftBits &lt;&lt; 1           // 00001000shiftBits &lt;&lt; 2           // 00010000shiftBits &lt;&lt; 5           // 10000000shiftBits &lt;&lt; 6           // 00000000shiftBits &gt;&gt; 2           // 00000001</code></pre><p>可以使用移位运算对其他的数据类型进行编码和解码：</p><pre><code>let pink: UInt32 = 0xCC6699let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16  // redComponent 是 0xCC，即 204let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102let blueComponent = pink &amp; 0x0000FF         // blueComponent 是 0x99，即 153</code></pre><h4 id="1-5-2-有符号整数的移位运算"><a href="#1-5-2-有符号整数的移位运算" class="headerlink" title="1.5.2 有符号整数的移位运算"></a>1.5.2 有符号整数的移位运算</h4><ul><li>有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。符号位为 <code>0</code> 代表正数，为 <code>1</code> 代表负数。</li><li>其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起。</li></ul><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%AD%A34Int8.png"></p><p>负数的存储方式略有不同。它存储 <code>2</code> 的 <code>n</code> 次方减去其实际值的绝对值，这里的 <code>n</code> 是数值位的位数。一个 <code>8</code> 比特位的数有 <code>7</code> 个比特位是数值位，所以是 <code>2</code> 的 <code>7</code> 次方，即 <code>128</code>。</p><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E8%B4%9F4Int8.png"></p><p>这次的符号位为 <code>1</code>，说明这是一个负数，另外 <code>7</code> 个位则代表了数值 <code>124</code>（即 <code>128 - 4</code>）的二进制表示：</p><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_124.png"></p><p>负数的表示通常被称为<code>二进制补码</code>。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点:</p><ul><li>如果想对 <code>-1</code> 和 <code>-4</code> 进行加法运算，我们只需要对这两个数的全部 <code>8</code> 个比特位执行标准的二进制相加（包括符号位），并且将计算结果中超出 <code>8</code> 位的数值丢弃：</li></ul><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E4%B8%A4%E8%B4%9F%E6%95%B0%E7%9B%B8%E5%8A%A0.png"></p><ul><li>使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 <code>2</code>，每向右一位就将自身的数值除以 <code>2</code>。要达到此目的，对有符号整数的右移有一个额外的规则：当对有符号整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 <code>0</code>。</li></ul><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97.png"></p><p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为<code>算术移位</code>。</p><p>由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 <code>0</code>。在移位的过程中保持符号位不变，意味着负整数在接近 <code>0</code> 的过程中会一直保持为负。</p><h2 id="2-溢出运算符"><a href="#2-溢出运算符" class="headerlink" title="2.溢出运算符"></a>2.溢出运算符</h2><p>当向一个整数类型的常量或者变量赋予超过它容量的值时，Swift 默认会报错，而不是允许生成一个无效的数。这个行为为我们在运算过大或者过小的数时提供了额外的安全性。</p><pre><code>var potentialOverflow = Int16.max// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数potentialOverflow += 1// 这里会报错</code></pre><p>Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 <code>&amp;</code> 开头的：</p><ul><li>溢出加法 <code>&amp;+</code></li><li>溢出减法 <code>&amp;-</code></li><li>溢出乘法 <code>&amp;*</code></li></ul><h3 id="2-1-数值溢出"><a href="#2-1-数值溢出" class="headerlink" title="2.1 数值溢出"></a>2.1 数值溢出</h3><p>数值有可能出现上溢或者下溢。</p><h4 id="2-1-1-无符号整数溢出"><a href="#2-1-1-无符号整数溢出" class="headerlink" title="2.1.1 无符号整数溢出"></a>2.1.1 无符号整数溢出</h4><p>对一个无符号整数使用溢出加法（<code>&amp;+</code>）进行上溢运算：</p><pre><code>var unsignedOverflow = UInt8.max// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255unsignedOverflow = unsignedOverflow &amp;+ 1// 此时 unsignedOverflow 等于 0</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E4%B8%8A%E6%BA%A2.png"></p><p>对一个无符号整数使用溢出加法（<code>&amp;-</code>）进行下溢运算：</p><pre><code>var unsignedOverflow = UInt8.min// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0unsignedOverflow = unsignedOverflow &amp;- 1// 此时 unsignedOverflow 等于 255</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E4%B8%8B%E6%BA%A2.png"></p><h4 id="2-1-2-有符号整数溢出"><a href="#2-1-2-有符号整数溢出" class="headerlink" title="2.1.2 有符号整数溢出"></a>2.1.2 有符号整数溢出</h4><p>溢出也会发生在有符号整型上。针对有符号整型的所有溢出加法或者减法运算都是按位运算的方式执行的，符号位也需要参与计算:</p><pre><code>var signedOverflow = Int8.min// signedOverflow 等于 Int8 所能容纳的最小整数 -128signedOverflow = signedOverflow &amp;- 1// 此时 signedOverflow 等于 127</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA.png"></p><p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大数。</p><h2 id="3-优先级和结合性"><a href="#3-优先级和结合性" class="headerlink" title="3.优先级和结合性"></a>3.优先级和结合性</h2><pre><code>2 + 3 % 4 * 5// 结果是 17</code></pre><h2 id="4-运算符函数"><a href="#4-运算符函数" class="headerlink" title="4.运算符函数"></a>4.运算符函数</h2><p>类和结构体可以为现有的运算符提供自定义的实现。这通常被称为<code>运算符重载</code>。</p><h3 id="4-1-中缀运算符"><a href="#4-1-中缀运算符" class="headerlink" title="4.1 中缀运算符"></a>4.1 中缀运算符</h3><p>中缀运算符 为 二元运算符。</p><pre><code>struct Vector2D &#123;    var x = 0.0, y = 0.0&#125;extension Vector2D &#123;    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;        return Vector2D(x: left.x + right.x, y: left.y + right.y)    &#125;&#125;let vector = Vector2D(x: 3.0, y: 1.0)let anotherVector = Vector2D(x: 2.0, y: 4.0)let combinedVector = vector + anotherVector// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6_%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0.png"></p><h3 id="4-1-前缀和后缀运算符"><a href="#4-1-前缀和后缀运算符" class="headerlink" title="4.1 前缀和后缀运算符"></a>4.1 前缀和后缀运算符</h3><p>前缀运算符(<code>-a</code>) 和 后缀运算符(<code>b!</code>) 为 一元运算符。</p><p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 修饰符：</p><pre><code>extension Vector2D &#123;    static prefix func - (vector: Vector2D) -&gt; Vector2D &#123;        return Vector2D(x: -vector.x, y: -vector.y)    &#125;&#125;let positive = Vector2D(x: 3.0, y: 4.0)let negative = -positive// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例let alsoPositive = -negative// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例</code></pre><h3 id="4-2-复合赋值运算符"><a href="#4-2-复合赋值运算符" class="headerlink" title="4.2 复合赋值运算符"></a>4.2 复合赋值运算符</h3><p>复合赋值运算符将赋值运算符（<code>=</code>）与其它运算符进行结合: <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>等</p><blockquote><p>在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改。</p></blockquote><pre><code>extension Vector2D &#123;    static func += (left: inout Vector2D, right: Vector2D) &#123;        left = left + right    &#125;&#125;var original = Vector2D(x: 1.0, y: 2.0)let vectorToAdd = Vector2D(x: 3.0, y: 4.0)original += vectorToAdd// original 的值现在为 (4.0, 6.0)</code></pre><blockquote><p>不能对默认的赋值运算符（<code>=</code>）进行重载。只有复合赋值运算符可以被重载。同样地，也无法对三元条件运算符 （<code>a ? b : c</code>） 进行重载。</p></blockquote><h3 id="4-3-等价运算符"><a href="#4-3-等价运算符" class="headerlink" title="4.3 等价运算符"></a>4.3 等价运算符</h3><p>通常情况下，自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为相等运算符（<code>==</code>）与不等运算符（<code>!=</code>）。</p><p>为了使用等价运算符对自定义的类型进行判等运算，需要为“相等”运算符提供自定义实现，实现的方法与其它中缀运算符一样, 并且增加对标准库 <code>Equatable</code> 协议的遵循：</p><pre><code>extension Vector2D: Equatable &#123;    static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123;        return (left.x == right.x) &amp;&amp; (left.y == right.y)    &#125;&#125;let twoThree = Vector2D(x: 2.0, y: 3.0)let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)if twoThree == anotherTwoThree &#123;    print(&quot;These two vectors are equivalent.&quot;)&#125;// 打印“These two vectors are equivalent.”</code></pre><h3 id="4-4-自定义运算符"><a href="#4-4-自定义运算符" class="headerlink" title="4.4 自定义运算符"></a>4.4 自定义运算符</h3><p>新的运算符要使用 <code>operator</code> 关键字在全局作用域内进行定义，同时还要指定 <code>prefix</code>、<code>infix</code> 或者 <code>postfix</code> 修饰符：</p><pre><code>prefix operator +++</code></pre><pre><code>extension Vector2D &#123;    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D &#123;        vector += vector        return vector    &#125;&#125;var toBeDoubled = Vector2D(x: 1.0, y: 4.0)let afterDoubling = +++toBeDoubled// toBeDoubled 现在的值为 (2.0, 8.0)// afterDoubling 现在的值也为 (2.0, 8.0)</code></pre><h4 id="4-4-1-自定义中缀运算符的优先级"><a href="#4-4-1-自定义中缀运算符的优先级" class="headerlink" title="4.4.1 自定义中缀运算符的优先级"></a>4.4.1 自定义中缀运算符的优先级</h4><p>每个自定义中缀运算符都属于某个优先级组。优先级组指定了这个运算符相对于其他中缀运算符的优先级和结合性。</p><p>而没有明确放入某个优先级组的自定义中缀运算符将会被放到一个默认的优先级组内，其优先级高于三元运算符。</p><pre><code>infix operator +-: AdditionPrecedenceextension Vector2D &#123;    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123;        return Vector2D(x: left.x + right.x, y: left.y - right.y)    &#125;&#125;let firstVector = Vector2D(x: 1.0, y: 2.0)let secondVector = Vector2D(x: 3.0, y: 4.0)let plusMinusVector = firstVector +- secondVector// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)</code></pre><p>这个运算符把两个向量的 <code>x</code> 值相加，同时从第一个向量的 <code>y</code> 中减去第二个向量的 <code>y</code> 。因为它本质上是属于“相加型”运算符，所以将它放置在 <code>+</code> 和 <code>-</code> 等默认中缀“相加型”运算符相同的优先级组中。</p><blockquote><p>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 访问控制</title>
      <link href="posts/4250655424.html"/>
      <url>posts/4250655424.html</url>
      
        <content type="html"><![CDATA[<p><code>访问控制</code>可以限定其它源文件或模块对你的代码的访问。</p><p>你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、函数、初始化方法、基本类型、下标索引等设置访问级别。</p><p>协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。</p><h2 id="1-模块和源文件"><a href="#1-模块和源文件" class="headerlink" title="1.模块和源文件"></a>1.模块和源文件</h2><p>Swift 中的访问控制模型基于模块和源文件：</p><ul><li>模块指的是以独立单元构建和发布的 <code>Framework</code> 或 <code>Application</code>。在 Swift 中的一个模块可以使用 <code>import</code> 关键字引入另外一个模块。</li><li>源文件是单个源码文件，它通常属于一个模块，源文件可以包含多个类和函数的定义。</li></ul><h2 id="2-访问级别"><a href="#2-访问级别" class="headerlink" title="2.访问级别"></a>2.访问级别</h2><p>Swift 为代码中的实体提供了四种不同的访问级别:<code>public</code>、<code>open</code> 、<code>internal</code>、<code>fileprivate</code>、<code>private</code>。</p><table><thead><tr><th align="center">访问级别</th><th align="center">定义</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center">public/open</td><td align="center">可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体</td><td align="center">指定框架的外部接口</td></tr><tr><td align="center">internal</td><td align="center">可以访问自己模块中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体</td><td align="center">只在应用程序或框架内部使用</td></tr><tr><td align="center">fileprivate</td><td align="center">文件内私有，只能在当前源文件中使用</td><td align="center">功能的部分实现细节只需要在文件内使用</td></tr><tr><td align="center">private</td><td align="center">只能在类中访问，离开了这个类或者结构体的作用域外面就无法访问</td><td align="center">功能的部分细节只需要在当前作用域内使用</td></tr></tbody></table><p><code>open</code> 为最高访问级别（限制最少），<code>private</code> 为最低访问级别（限制最多）。</p><p><code>open</code> 只能作用于类和类的成员，它和 <code>public</code> 的区别主要在于 <code>open</code> 限定的类和成员能够在模块外能被继承和重写。</p><h3 id="2-1-访问级别基本原则"><a href="#2-1-访问级别基本原则" class="headerlink" title="2.1 访问级别基本原则"></a>2.1 访问级别基本原则</h3><p>Swift 中的访问级别遵循一个基本原则：实体不能定义在具有更低访问级别（更严格）的实体中。例如：</p><ul><li>一个 <code>public</code> 的变量，其类型的访问级别不能是 <code>internal</code>，<code>fileprivate</code> 或是 <code>private</code>。因为无法保证变量的类型在使用变量的地方也具有访问权限。</li><li>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。</li></ul><h3 id="2-2-默认访问级别"><a href="#2-2-默认访问级别" class="headerlink" title="2.2 默认访问级别"></a>2.2 默认访问级别</h3><p>代码中所有的实体，如果不显式的指定它们的访问级别，那么它们将都有一个 <code>internal</code> 的默认访问级别。因此，多数情况下不需要显示指定实体的访问级别。</p><h2 id="3-访问控制语法"><a href="#3-访问控制语法" class="headerlink" title="3.访问控制语法"></a>3.访问控制语法</h2><p>通过修饰符 <code>open</code>、<code>public</code>、<code>internal</code>、<code>fileprivate</code>、<code>private</code> 来声明实体的访问级别：</p><pre><code>public class SomePublicClass &#123;&#125;internal class SomeInternalClass &#123;&#125;fileprivate class SomeFilePrivateClass &#123;&#125;private class SomePrivateClass &#123;&#125;public var somePublicVariable = 0internal let someInternalConstant = 0fileprivate func someFilePrivateFunction() &#123;&#125;private func somePrivateFunction() &#123;&#125;</code></pre><p>除非专门指定，否则实体默认的访问级别为 <code>internal</code>:</p><pre><code>class SomeInternalClass &#123;&#125;   // 隐式 internalvar someInternalConstant = 0 // 隐式 internal</code></pre><h2 id="4-不同类型的访问级别"><a href="#4-不同类型的访问级别" class="headerlink" title="4.不同类型的访问级别"></a>4.不同类型的访问级别</h2><h3 id="4-1-单-target-应用程序的访问级别"><a href="#4-1-单-target-应用程序的访问级别" class="headerlink" title="4.1 单 target 应用程序的访问级别"></a>4.1 单 target 应用程序的访问级别</h3><p>对于单 <code>target</code> 应用程序，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以不需要明确设置访问级别，使用默认的访问级别 <code>internal</code> 即可。但是，也可以使用 <code>fileprivate</code> 或 <code>private</code> 访问级别，用于隐藏一些功能的实现细节。</p><h3 id="4-2-框架的访问级别"><a href="#4-2-框架的访问级别" class="headerlink" title="4.2 框架的访问级别"></a>4.2 框架的访问级别</h3><p>当开发框架时，就需要把一些对外的接口定义为 <code>open</code> 或 <code>public</code> 访问级别，以便使用者导入该框架后可以正常使用其功能。这些被定义为对外的接口，就是这个框架的 API。</p><blockquote><p>框架的内部实现仍然可以使用默认的访问级别 <code>internal</code>，当需要对框架内部其它部分隐藏细节时可以使用 <code>private</code> 或 <code>fileprivate</code>。</p></blockquote><h3 id="4-3-单元测试-target-的访问级别"><a href="#4-3-单元测试-target-的访问级别" class="headerlink" title="4.3 单元测试 target 的访问级别"></a>4.3 单元测试 target 的访问级别</h3><p>当应用程序包含单元测试 <code>target</code> 时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有 <code>open</code> 或 <code>public</code> 级别的实体才可以被其他模块访问。</p><p>然而，如果在导入应用程序模块的语句前使用 <code>@testable</code> 特性，然后在允许测试的编译设置（<code>Build Options -&gt; Enable Testability</code>）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p><h3 id="4-4-自定义类型"><a href="#4-4-自定义类型" class="headerlink" title="4.4 自定义类型"></a>4.4 自定义类型</h3><p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。</p><p>一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别:</p><ul><li>如果你将类型指定为 <code>private</code> 或者 <code>fileprivate</code> 级别，那么该类型的所有成员的默认访问级别也会变成 <code>private</code> 或者 <code>fileprivate</code> 级别。</li><li>如果你将类型指定为 <code>internal</code> 或 <code>public</code>（或者不明确指定访问级别，而使用默认的 <code>internal</code> ），那么该类型的所有成员的默认访问级别将是 <code>internal</code>。</li></ul><blockquote><p>一个 <code>public</code> 类型的所有成员的访问级别默认为 <code>internal</code> 级别，而不是 <code>public</code> 级别。如果你想将某个成员指定为 <code>public</code> 级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p></blockquote><pre><code>public class SomePublicClass &#123;                  // 显式 public 类    public var somePublicProperty = 0            // 显式 public 类成员    var someInternalProperty = 0                 // 隐式 internal 类成员    fileprivate func someFilePrivateMethod() &#123;&#125;  // 显式 fileprivate 类成员    private func somePrivateMethod() &#123;&#125;          // 显式 private 类成员&#125;class SomeInternalClass &#123;                       // 隐式 internal 类    var someInternalProperty = 0                 // 隐式 internal 类成员    fileprivate func someFilePrivateMethod() &#123;&#125;  // 显式 fileprivate 类成员    private func somePrivateMethod() &#123;&#125;          // 显式 private 类成员&#125;fileprivate class SomeFilePrivateClass &#123;        // 显式 fileprivate 类    func someFilePrivateMethod() &#123;&#125;              // 隐式 fileprivate 类成员    private func somePrivateMethod() &#123;&#125;          // 显式 private 类成员&#125;private class SomePrivateClass &#123;                // 显式 private 类    func somePrivateMethod() &#123;&#125;                  // 隐式 private 类成员&#125;</code></pre><h4 id="4-4-1-元组类型"><a href="#4-4-1-元组类型" class="headerlink" title="4.4.1 元组类型"></a>4.4.1 元组类型</h4><p><strong>元组的访问级别将由元组中访问级别最严格的类型来决定</strong>。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 <code>internal</code>，另一个类型为 <code>private</code>，那么这个元组的访问级别为 <code>private</code>。</p><blockquote><p>元组不同于类、结构体、枚举、函数那样有单独的定义。一个元组的访问级别由元组中元素的访问级别来决定的，不能被显示指定。</p></blockquote><h4 id="4-4-2-函数类型"><a href="#4-4-2-函数类型" class="headerlink" title="4.4.2 函数类型"></a>4.4.2 函数类型</h4><p>函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。</p><pre><code>func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;    // 此处是函数实现部分&#125;</code></pre><p>这个函数的返回类型是一个元组，该元组中包含两个自定义的类。其中一个类的访问级别是 <code>internal</code>，另一个的访问级别是 <code>private</code>，所以根据元组访问级别的原则，该元组的访问级别是 <code>private</code>（元组的访问级别与元组中访问级别最低的类型一致）。</p><p>因为该函数返回类型的访问级别是 <code>private</code>，所以你必须使用 <code>private</code> 修饰符来明确指定该函数的访问级别：</p><pre><code>private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123;    // 此处是函数实现部分&#125;</code></pre><p>将函数指定为 <code>public</code> 或 <code>internal</code>，或者使用默认的访问级别 <code>internal</code> 都是错误的，因为如果把该函数当做 <code>public</code> 或 <code>internal</code> 级别来使用的话，可能会无法访问 <code>private</code> 级别的返回值。</p><h4 id="4-4-3-枚举类型"><a href="#4-4-3-枚举类型" class="headerlink" title="4.4.3 枚举类型"></a>4.4.3 枚举类型</h4><p>枚举成员的访问级别和该枚举类型相同，不能为枚举成员单独指定不同的访问级别。</p><pre><code>public enum CompassPoint &#123;    case north    case south    case east    case west&#125;// CompassPoint 被指定为 public，则所有成员的访问级别都是 public</code></pre><p><strong>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别</strong>。例如，你不能在一个 <code>internal</code> 的枚举中定义 <code>private</code> 的原始值类型。</p><h4 id="4-4-4-嵌套类型"><a href="#4-4-4-嵌套类型" class="headerlink" title="4.4.4 嵌套类型"></a>4.4.4 嵌套类型</h4><p><strong>嵌套类型的访问级别和包含它的类型的访问级别相同</strong>，嵌套类型是 <code>public</code> 的情况除外。在一个 <code>public</code> 的类型中定义嵌套类型，那么嵌套类型自动拥有 <code>internal</code> 的访问级别。如果你想让嵌套类型拥有 <code>public</code> 访问级别，那么必须显式指定该嵌套类型的访问级别为 <code>public</code>。</p><h3 id="4-5-子类"><a href="#4-5-子类" class="headerlink" title="4.5 子类"></a>4.5 子类</h3><p>可以继承同一模块中的所有有访问权限的类，也可以继承不同模块中被 <code>open</code> 修饰的类。一个子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 <code>internal</code>，子类的访问级别就不能是 <code>public</code>。</p><p>此外，在同一模块中，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。在不同模块中，你可以重写类中被 <code>open</code> 修饰的成员。</p><p>可以通过重写给所继承类的成员提供更高的访问级别:</p><pre><code>public class A &#123;    fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123;    override internal func someMethod() &#123;&#125;&#125;</code></pre><p>在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 <code>fileprivate</code> 级别的成员，在同一模块内访问父类 <code>internal</code> 级别的成员）：</p><pre><code>public class A &#123;    fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123;    override internal func someMethod() &#123;        super.someMethod()    &#125;&#125;</code></pre><h3 id="4-6-常量、变量、属性、下标"><a href="#4-6-常量、变量、属性、下标" class="headerlink" title="4.6 常量、变量、属性、下标"></a>4.6 常量、变量、属性、下标</h3><ul><li>常量、变量、属性: 不能拥有比它们的类型更高的访问级别(不能定义一个 <code>public</code> 级别的属性，但是它的类型却是 <code>private</code> 级别的)</li><li>下标: 不能拥有比索引类型或返回类型更高的访问级别</li></ul><p>如果常量、变量、属性、下标的类型是 <code>private</code> 级别的，那么它们必须明确指定访问级别为 <code>private</code>：</p><pre><code>private var privateInstance = SomePrivateClass()</code></pre><p>常量、变量、属性、下标的 <code>Getters</code> 和 <code>Setters</code> 的访问级别和它们所属类型的访问级别相同。</p><p><code>Setter</code> 的访问级别可以低于对应的 <code>Getter</code> 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 <code>var</code> 或 <code>subscript</code> 关键字之前，你可以通过 <code>fileprivate(set)</code>，<code>private(set)</code> 或 <code>internal(set)</code> 为它们的写入权限指定更低的访问级别。</p><pre><code>struct TrackedString &#123;    private(set) var numberOfEdits = 0    var value: String = &quot;&quot; &#123;        didSet &#123;            numberOfEdits += 1        &#125;    &#125;&#125;</code></pre><p>结构体 <code>TrackedString</code> 和它的属性 <code>value</code> 都没有显式地指定访问级别，所以它们都是用默认的访问级别 <code>internal</code>。但是该结构体的 <code>numberOfEdits</code> 属性使用了 <code>private(set)</code> 修饰符，这意味着 <code>numberOfEdits</code> 属性只能在结构体的定义中进行赋值。<code>numberOfEdits</code> 属性的 <code>Getter</code> 依然是默认的访问级别 <code>internal</code>，但是 <code>Setter</code> 的访问级别是 <code>private</code>，这表示该属性只能在内部修改，而在结构体的外部则表现为一个只读属性。</p><pre><code>var stringToEdit = TrackedString()stringToEdit.value = &quot;This string will be tracked.&quot;stringToEdit.value += &quot; This edit will increment numberOfEdits.&quot;stringToEdit.value += &quot; So will this one.&quot;print(&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;)// 打印“The number of edits is 3”</code></pre><p>虽然可以在其他的源文件中实例化该结构体并且获取到 <code>numberOfEdits</code> 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。</p><p><strong>可以在必要时为 <code>Getter</code> 和 <code>Setter</code> 显式指定访问级别</strong>。</p><pre><code>public struct TrackedString &#123;    public private(set) var numberOfEdits = 0    public var value: String = &quot;&quot; &#123;        didSet &#123;            numberOfEdits += 1        &#125;    &#125;    public init() &#123;&#125;&#125;</code></pre><p>上面的例子将 <code>TrackedString</code> 结构体明确指定为了 <code>public</code> 访问级别。结构体的成员（包括 <code>numberOfEdits</code> 属性）拥有默认的访问级别 <code>internal</code>。结合 <code>public</code> 和 <code>private(set)</code> 修饰符把结构体中的 <code>numberOfEdits</code> 属性的 <code>Getter</code> 的访问级别设置为 <code>public</code>，而 <code>Setter</code> 的访问级别设置为 <code>private</code>。</p><h3 id="4-7-构造器"><a href="#4-7-构造器" class="headerlink" title="4.7 构造器"></a>4.7 构造器</h3><p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是 <code>必要构造器</code>，它的访问级别必须和所属类型的访问级别相同。</p><p>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p><h4 id="4-7-1-默认构造器"><a href="#4-7-1-默认构造器" class="headerlink" title="4.7.1 默认构造器"></a>4.7.1 默认构造器</h4><p>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 <code>public</code>:</p><ul><li>如果一个类型被指定为 <code>public</code> 级别，那么默认构造器的访问级别将为 <code>internal</code>。</li><li>如果希望一个 <code>public</code> 级别的类型也能在其他模块中使用这种无参数的默认构造器，只能自己提供一个 <code>public</code> 访问级别的无参数构造器。</li></ul><h4 id="4-7-2-结构体默认的成员逐一构造器"><a href="#4-7-2-结构体默认的成员逐一构造器" class="headerlink" title="4.7.2 结构体默认的成员逐一构造器"></a>4.7.2 结构体默认的成员逐一构造器</h4><p>如果结构体中任意存储型属性的访问级别为 <code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是 <code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p><blockquote><p>如同前面提到的默认构造器，如果你希望一个 <code>public</code> 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 <code>public</code> 访问级别的成员逐一构造器。</p></blockquote><h3 id="4-8-协议"><a href="#4-8-协议" class="headerlink" title="4.8 协议"></a>4.8 协议</h3><p>如果想为一个协议类型明确地指定访问级别，在声明协议时指定即可。这将限制该协议只能在适当的访问级别范围内被遵循。</p><p>协议中的每个方法或属性都必须具有和该协议相同的访问级别。你不能将协议中的方法或属性设置为其他访问级别。这样才能确保该协议的所有方法或属性对于任意遵循者都可用。</p><blockquote><p>如果你定义了一个 <code>public</code> 访问级别的协议，那么该协议的所有实现也会是 <code>public</code> 访问级别。这一点不同于其他类型，例如，类型是 <code>public</code> 访问级别时，其成员的访问级别却只是 <code>internal</code>。</p></blockquote><h4 id="4-8-1-协议继承"><a href="#4-8-1-协议继承" class="headerlink" title="4.8.1 协议继承"></a>4.8.1 协议继承</h4><p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 <code>internal</code> 协议的新协议访问级别指定为 <code>public</code> 协议。</p><h4 id="4-8-2-协议遵循"><a href="#4-8-2-协议遵循" class="headerlink" title="4.8.2 协议遵循"></a>4.8.2 协议遵循</h4><ul><li><strong>一个类型可以遵循比它级别更低的协议</strong>，例如，你可以定义一个 <code>public</code> 级别类型，它能在别的模块中使用，但是如果它遵循一个 <code>internal</code> 协议，这个遵循的部分就只能在这个 <code>internal</code> 协议所在的模块中使用。</li><li><strong>遵循协议时的上下文级别是类型和协议中级别最小的那个</strong>。如果一个类型是 <code>public</code> 级别，但它要遵循的协议是 <code>internal</code> 级别，那么这个类型对该协议的遵循上下文就是 <code>internal</code> 级别。</li><li><strong>当你编写或扩展一个类型让它遵循一个协议时，你必须确保该类型对协议的每一个要求的实现，至少与遵循协议的上下文级别一致</strong>。例如，一个 <code>public</code> 类型遵循一个 <code>internal</code> 协议，这个类型对协议的所有实现至少都应是 <code>internal</code> 级别的。</li></ul><h3 id="4-9-扩展"><a href="#4-9-扩展" class="headerlink" title="4.9 扩展"></a>4.9 扩展</h3><ul><li><code>Extension</code> 可以在访问级别允许的情况下对类、结构体、枚举进行扩展。<code>Extension</code> 的新增成员具有和原始类型成员一致的访问级别</li><li>可以通过修饰语重新指定 <code>extension</code> 的默认访问级别（例如，private），从而给该 <code>extension</code> 中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独成员指定的访问级别所覆盖。</li><li>如果使用 <code>extension</code> 来遵循协议的话，就不能显式地声明 <code>extension</code> 的访问级别。<code>extension</code> 每个 <code>protocol</code> 要求的实现都默认使用 <code>protocol</code> 的访问级别。</li></ul><h4 id="4-9-1-Extension-的私有成员"><a href="#4-9-1-Extension-的私有成员" class="headerlink" title="4.9.1 Extension 的私有成员"></a>4.9.1 Extension 的私有成员</h4><p>扩展同一文件内的类，结构体或者枚举，<code>extension</code> 里的代码会表现得跟声明在原类型里的一模一样。也就是说你可以这样：</p><ul><li>在类型的声明里声明一个私有成员，在同一文件的 <code>extension</code> 里访问。</li><li>在 <code>extension</code> 里声明一个私有成员，在同一文件的另一个 <code>extension</code> 里访问。</li><li>在 <code>extension</code> 里声明一个私有成员，在同一文件的类型声明里访问。</li></ul><pre><code>protocol SomeProtocol &#123;    func doSomething()&#125;struct SomeStruct &#123;    private var privateVariable = 12&#125;extension SomeStruct: SomeProtocol &#123;    func doSomething() &#123;        print(privateVariable)    &#125;&#125;</code></pre><h3 id="4-10-泛型"><a href="#4-10-泛型" class="headerlink" title="4.10 泛型"></a>4.10 泛型</h3><p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p><h3 id="4-11-类型别名"><a href="#4-11-类型别名" class="headerlink" title="4.11 类型别名"></a>4.11 类型别名</h3><p>定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，<code>private</code> 级别的类型别名可以作为 <code>private</code>、<code>fileprivate</code>、<code>internal</code>、<code>public</code> 或者 <code>open</code> 类型的别名，但是 <code>public</code> 级别的类型别名只能作为 <code>public</code> 类型的别名，不能作为 <code>private</code>、<code>fileprivate</code> 或 <code>internal</code> 类型的别名。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 内存安全</title>
      <link href="posts/1374244109.html"/>
      <url>posts/1374244109.html</url>
      
        <content type="html"><![CDATA[<p>默认情况下，Swift 会阻止你代码里不安全的行为。因为 Swift 自动管理内存，所以大部分时候你完全不需要考虑内存访问的事情。然而，理解潜在的冲突也是很重要的，可以避免你写出访问冲突的代码。</p><h2 id="1-理解内存访问冲突"><a href="#1-理解内存访问冲突" class="headerlink" title="1.理解内存访问冲突"></a>1.理解内存访问冲突</h2><p>内存的访问，会发生在你给变量赋值，或者传递参数给函数时。例如，下面的代码就包含了读和写的访问：</p><pre><code>// 向 one 所在的内存区域发起一次写操作var one = 1// 向 one 所在的内存区域发起一次读操作print(&quot;We&#39;re number \(one)!&quot;)</code></pre><p>内存访问的冲突会发生在你的代码尝试同时访问同一个存储地址的时侯。同一个存储地址的多个访问同时发生会造成不可预计或不一致的行为。在 Swift 里，有很多修改值的行为都会持续好几行代码，在修改值的过程中进行访问是有可能发生的。</p><h3 id="1-1-内存访问性质"><a href="#1-1-内存访问性质" class="headerlink" title="1.1 内存访问性质"></a>1.1 内存访问性质</h3><p>内存访问冲突时，要考虑内存访问上下文中的这三个性质：访问是读还是写，访问的时长，以及被访问的存储地址。特别是，冲突会发生在当你有两个访问符合下列的情况：</p><ul><li>至少有一个是写访问</li><li>它们访问的是同一个存储地址</li><li>它们的访问在时间线上部分重叠</li></ul><blockquote><p>读和写访问的区别很明显：一个写访问会改变存储地址，而读操作不会。内存访问的时长要么是瞬时的，要么是长期的。</p></blockquote><p>如果一个访问不可能在其访问期间被其它代码访问，那么就是一个瞬时访问。正常来说，两个瞬时访问是不可能同时发生的。大多数内存访问都是瞬时的。例如，下面列举的所有读和写访问都是瞬时的：</p><pre><code>func oneMore(than number: Int) -&gt; Int &#123;    return number + 1&#125;var myNumber = 1myNumber = oneMore(than: myNumber)print(myNumber)// 打印“2”</code></pre><p>然而，有几种被称为长期访问的内存访问方式，会在别的代码执行时持续进行。瞬时访问和长期访问的区别在于别的代码有没有可能在访问期间同时访问，也就是在时间线上的重叠。一个长期访问可以被别的长期访问或瞬时访问重叠。</p><h2 id="2-访问冲突"><a href="#2-访问冲突" class="headerlink" title="2.访问冲突"></a>2.访问冲突</h2><h3 id="2-1-In-Out-参数的访问冲突"><a href="#2-1-In-Out-参数的访问冲突" class="headerlink" title="2.1 In-Out 参数的访问冲突"></a>2.1 In-Out 参数的访问冲突</h3><p>关于 <code>in-out</code>:</p><ul><li>一个函数会对它所有的 <code>in-out</code> 参数进行长期写访问。</li><li><code>in-out</code> 参数的写访问会在所有非 <code>in-out</code> 参数处理完之后开始，直到函数执行完毕为止。</li><li>如果有多个 <code>in-out</code> 参数，则写访问开始的顺序与参数的顺序一致。</li></ul><h4 id="2-1-1-访问以-in-out-形式传入后的原变量"><a href="#2-1-1-访问以-in-out-形式传入后的原变量" class="headerlink" title="2.1.1 访问以 in-out 形式传入后的原变量"></a>2.1.1 访问以 <code>in-out</code> 形式传入后的原变量</h4><p>长期访问的存在会造成一个结果，你不能在访问以 <code>in-out</code> 形式传入后的原变量，即使作用域原则和访问权限允许——任何访问原变量的行为都会造成冲突。例如：</p><pre><code>var stepSize = 1func increment(_ number: inout Int) &#123;    number += stepSize&#125;increment(&amp;stepSize)// 错误：stepSize 访问冲突</code></pre><p><code>number</code> 和 <code>stepSize</code> 都指向了同一个存储地址。同一块内存的读和写访问重叠了，就此产生了冲突。<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8_inout.png"></p><p>解决这个冲突的一种方式，是显示拷贝一份 stepSize ：</p><pre><code>// 显式拷贝var copyOfStepSize = stepSizeincrement(&amp;copyOfStepSize)// 更新原来的值stepSize = copyOfStepSize// stepSize 现在的值是 2</code></pre><h4 id="2-1-2-同一函数的多个-in-out-参数里传入同一变量"><a href="#2-1-2-同一函数的多个-in-out-参数里传入同一变量" class="headerlink" title="2.1.2 同一函数的多个 in-out 参数里传入同一变量"></a>2.1.2 同一函数的多个 in-out 参数里传入同一变量</h4><p>长期写访问的存在还会造成另一种结果，往同一个函数的多个 <code>in-out</code> 参数里传入同一个变量也会产生冲突，例如：</p><pre><code>func balance(_ x: inout Int, _ y: inout Int) &#123;    let sum = x + y    x = sum / 2    y = sum - x&#125;var playerOneScore = 42var playerTwoScore = 30balance(&amp;playerOneScore, &amp;playerTwoScore)  // 正常balance(&amp;playerOneScore, &amp;playerOneScore)// 错误：playerOneScore 访问冲突</code></pre><p>上面的 <code>balance(_:_:)</code> 函数会将传入的两个参数平均化。将 <code>playerOneScore</code> 和 <code>playerTwoScore</code> 作为参数传入不会产生错误 —— 有两个访问重叠了，但它们访问的是不同的内存位置。相反，将 <code>playerOneScore</code> 作为参数同时传入就会产生冲突，因为它会发起两个写访问，同时访问同一个的存储地址。</p><h3 id="2-2-方法里-self-的访问冲突"><a href="#2-2-方法里-self-的访问冲突" class="headerlink" title="2.2 方法里 self 的访问冲突"></a>2.2 方法里 self 的访问冲突</h3><p>一个结构体的 <code>mutating</code> 方法会在调用期间对 <code>self</code> 进行写访问。</p><pre><code>struct Player &#123;    var name: String    var health: Int    var energy: Int    static let maxHealth = 10    mutating func restoreHealth() &#123;        health = Player.maxHealth    &#125;&#125;</code></pre><p>在上面的 <code>restoreHealth()</code> 方法里，一个对于 <code>self</code> 的写访问会从方法开始直到方法 <code>return</code>。在这种情况下，<code>restoreHealth()</code> 里的其它代码不可以对 <code>Player</code> 实例的属性发起重叠的访问。下面的 <code>shareHealth(with:)</code> 方法接受另一个 <code>Player</code> 的实例作为 <code>in-out</code> 参数，产生了访问重叠的可能性。</p><pre><code>extension Player &#123;    mutating func shareHealth(with teammate: inout Player) &#123;        balance(&amp;teammate.health, &amp;health)    &#125;&#125;var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)var maria = Player(name: &quot;Maria&quot;, health: 5, energy: 10)oscar.shareHealth(with: &amp;maria)  // 正常</code></pre><p>上面的例子虽然有两个写访问，但是不会冲突：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8_self_safe.png"></p><p>当然，如果你将 <code>oscar</code> 作为参数传入 <code>shareHealth(with:)</code> 里，就会产生冲突：</p><pre><code>oscar.shareHealth(with: &amp;oscar)// 错误：oscar 访问冲突</code></pre><p><code>mutating</code> 方法在调用期间需要对 <code>self</code> 发起写访问，而同时 <code>in-out</code> 参数也需要写访问。在方法里，<code>self</code> 和 <code>teammate</code> 都指向了同一个存储地址——就像下面展示的那样。对于同一块内存同时进行两个写访问，并且它们重叠了，就此产生了冲突。<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8_self_error.png"></p><h3 id="2-3-属性的访问冲突"><a href="#2-3-属性的访问冲突" class="headerlink" title="2.3 属性的访问冲突"></a>2.3 属性的访问冲突</h3><p>如结构体，元组和枚举的类型都是由多个独立的值组成的，例如结构体的属性或元组的元素。因为它们都是值类型，修改值的任何一部分都是对于整个值的修改，意味着其中一个属性的读或写访问都需要访问整一个值。例如，元组元素的写访问重叠会产生冲突：</p><pre><code>var playerInformation = (health: 10, energy: 20)balance(&amp;playerInformation.health, &amp;playerInformation.energy)// 错误：playerInformation 的属性访问冲突</code></pre><p>上面的例子里，传入同一元组的元素对 <code>balance(_:_:)</code> 进行调用，产生了冲突，因为 <code>playerInformation</code> 的访问产生了写访问重叠。<code>playerInformation.health</code> 和 <code>playerInformation.energy</code> 都被作为 <code>in-out</code> 参数传入，意味着 <code>balance(_:_:)</code> 需要在函数调用期间对它们发起写访问。任何情况下，对于元组元素的写访问都需要对整个元组发起写访问。这意味着对于 <code>playerInfomation </code>发起的两个写访问重叠了，造成冲突。</p><p>在实践中，大多数对于结构体属性的访问都会安全的重叠。例如，将上面例子里的变量改为本地变量而非全局变量，编译器就会可以保证这个重叠访问是安全的：</p><pre><code>func someFunction() &#123;    var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)    balance(&amp;oscar.health, &amp;oscar.energy)  // 正常&#125;</code></pre><p>限制结构体属性的重叠访问对于保证内存安全不是必要的。保证内存安全是必要的，但因为访问独占权的要求比内存安全还要更严格——意味着即使有些代码违反了访问独占权的原则，也是内存安全的，所以如果编译器可以保证这种非专属的访问是安全的，那 Swift 就会允许这种行为的代码运行。特别是当你遵循下面的原则时，它可以保证结构体属性的重叠访问是安全的：</p><ul><li>你访问的是实例的存储属性，而不是计算属性或类的属性</li><li>结构体是本地变量的值，而非全局变量</li><li>结构体要么没有被闭包捕获，要么只被非逃逸闭包捕获了</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 自动引用计数</title>
      <link href="posts/3594445199.html"/>
      <url>posts/3594445199.html</url>
      
        <content type="html"><![CDATA[<p>Swift 使用自动引用计数（ARC）机制来跟踪和管理应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，无须自己来考虑内存的管理。<code>ARC</code> 会在类的实例不再被使用时，自动释放其占用的内存。</p><blockquote><p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p></blockquote><h2 id="1-自动引用计数的工作机制"><a href="#1-自动引用计数的工作机制" class="headerlink" title="1.自动引用计数的工作机制"></a>1.自动引用计数的工作机制</h2><p>自动引用计数的工作机制:</p><ul><li>创建实例：ARC分配内存来储存该实例的信息（包含类型信息、实例关联的存储属性信息）</li><li>销毁实例：ARC释放实例所占用的内存，并让释放的内存能挪作他用</li><li>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。</li></ul><h2 id="2-自动引用计数实践"><a href="#2-自动引用计数实践" class="headerlink" title="2.自动引用计数实践"></a>2.自动引用计数实践</h2><pre><code>class Person &#123;    let name: String    init(name: String) &#123;        self.name = name        print(&quot;\(name) 开始初始化&quot;)    &#125;    deinit &#123;        print(&quot;\(name) 被析构&quot;)    &#125;&#125;// 值会被自动初始化为nil，目前还不会引用到Person类的实例var reference1: Person?var reference2: Person?var reference3: Person?// 创建Person类的新实例，此时会调用构造函数reference1 = Person(name: &quot;John Appleseed&quot;)//赋值给其他两个变量，该实例又会多出两个强引用reference2 = reference1reference3 = reference1//断开第一个强引用reference1 = nil//断开第二个强引用reference2 = nil//断开第三个强引用，此时会调用析构函数reference3 = nil</code></pre><p>以上程序执行输出结果为：</p><pre><code>John Appleseed 开始初始化John Appleseed 被析构</code></pre><h2 id="3-类实例之间的循环强引用"><a href="#3-类实例之间的循环强引用" class="headerlink" title="3.类实例之间的循环强引用"></a>3.类实例之间的循环强引用</h2><p>在上面的例子中，ARC 会跟踪你所新创建的 <code>Person</code> 实例的引用数量，并且会在 <code>Person</code> 实例不再被需要时销毁它。</p><p>然而，我们可能会写出一个类实例的强引用数永远不能变成 <code>0</code> 的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的<code>循环强引用</code>。</p><h3 id="3-1-循环引用实例"><a href="#3-1-循环引用实例" class="headerlink" title="3.1 循环引用实例"></a>3.1 循环引用实例</h3><p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code> 和 <code>Apartment</code>，用来建模公寓和它其中的居民：</p><pre><code>class Person &#123;    let name: String    init(name: String) &#123; self.name = name &#125;    var apartment: Apartment?    deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;class Apartment &#123;    let unit: String    init(unit: String) &#123; self.unit = unit &#125;    var tenant: Person?    deinit &#123; print(&quot;Apartment \(unit) is being deinitialized&quot;) &#125;&#125;</code></pre><p>接下来定义两个可选类型的变量 <code>john</code> 和 <code>unit4A</code>，并分别被设为下面的 <code>Apartment</code> 和 <code>Person</code> 的实例。这两个变量都被初始化为 <code>nil</code> :</p><pre><code>var john: Person?var unit4A: Apartment?</code></pre><p>然后创建特定的 <code>Person</code> 和 <code>Apartment</code> 实例并将赋值给 <code>john</code> 和 <code>unit4A</code> 变量：</p><pre><code>john = Person(name: &quot;John Appleseed&quot;)unit4A = Apartment(unit: &quot;4A&quot;)</code></pre><p>两个实例被创建和赋值后的强引用关系如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB0.png"><br>将这两个实例关联在一起:</p><pre><code>john!.apartment = unit4Aunit4A!.tenant = john</code></pre><p>此时的强引用关系如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB1.png"></p><p>当这两个实例关联后会产生一个循环强引用。<code>Person</code> 实例现在有了一个指向 <code>Apartment</code> 实例的强引用，而 <code>Apartment</code> 实例也有了一个指向 <code>Person</code> 实例的强引用。因此，当你断开 <code>john</code> 和 <code>unit4A</code> 变量所持有的强引用时，引用计数并不会降为 <code>0</code>，实例也不会被 ARC 销毁：</p><pre><code>john = nilunit4A = nil</code></pre><blockquote><p>注意，当把这两个变量设为 <code>nil</code> 时，没有任何一个析构器被调用。循环强引用会一直阻止 <code>Person</code> 和 <code>Apartment</code> 类实例的销毁，这就在应用程序中造成了内存泄漏。</p></blockquote><p>在将 <code>john</code> 和 <code>unit4A</code> 赋值为 <code>nil</code> 后，强引用关系如下图：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB2.png"><br><code>Person</code> 和 <code>Apartment</code> 实例之间的强引用关系保留了下来并且不会被断开。</p><h3 id="3-2-解决实例之间的循环强引用"><a href="#3-2-解决实例之间的循环强引用" class="headerlink" title="3.2 解决实例之间的循环强引用"></a>3.2 解决实例之间的循环强引用</h3><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：</p><ul><li>弱引用</li><li>无主引用</li></ul><p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p><p>当其他的实例有更短的生命周期时，使用弱引用。相反的，当其他实例有相同的或者更长生命周期时，使用无主引用。</p><h4 id="3-2-1-弱引用"><a href="#3-2-1-弱引用" class="headerlink" title="3.2.1 弱引用"></a>3.2.1 弱引用</h4><p>弱引用不会对其引用的实例保持强引用，ARC会在引用的实例被销毁后自动将其弱引用赋值为 <code>nil</code>(弱引用的实例要被定义为 <code>可选变量</code>)，用 <code>weak</code> 关键字表明弱引用</p><blockquote><p>当 ARC 设置弱引用为 <code>nil</code> 时，属性观察不会被触发。可以像其他可选值一样，检查弱引用的值是否存在，这样可以避免访问已销毁的实例的引用。</p></blockquote><pre><code>class Person &#123;    let name: String    init(name: String) &#123; self.name = name &#125;    var apartment: Apartment?    deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;class Apartment &#123;    let unit: String    init(unit: String) &#123; self.unit = unit &#125;    weak var tenant: Person?    deinit &#123; print(&quot;Apartment \(unit) is being deinitialized&quot;) &#125;&#125;</code></pre><p>然后跟之前一样，建立两个变量（<code>john</code> 和 <code>unit4A</code>）之间的强引用，并关联两个实例：</p><pre><code>var john: Person?var unit4A: Apartment?john = Person(name: &quot;John Appleseed&quot;)unit4A = Apartment(unit: &quot;4A&quot;)john!.apartment = unit4Aunit4A!.tenant = john</code></pre><p>现在，两个关联在一起的实例的引用关系如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB3.png"><br>此时只有 <code>Person</code> 实例对 <code>Apartment</code> 实例的强引用，把 <code>john</code> 变量赋值为 <code>nil</code> 而断开其所保持的强引用:</p><pre><code>john = nil// 打印“John Appleseed is being deinitialized”</code></pre><p>由于再也没有指向 <code>Person</code> 实例的强引用，该实例会被销毁，且 <code>tenant</code> 属性会被赋值为 <code>nil</code>：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB4.png"></p><p>唯一剩下的指向 <code>Apartment</code> 实例的强引用来自于变量 <code>unit4A</code>。如果你断开这个强引用，再也没有指向 <code>Apartment</code> 实例的强引用了：</p><pre><code>unit4A = nil// 打印“Apartment 4A is being deinitialized”</code></pre><p>由于再也没有指向 <code>Apartment</code> 实例的强引用，该实例会被销毁：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB5.png"></p><h4 id="3-2-2-无主引用"><a href="#3-2-2-无主引用" class="headerlink" title="3.2.2 无主引用"></a>3.2.2 无主引用</h4><p>无主引用不会牢牢保持住引用的实例，和弱引用不同的是：</p><ul><li>无主引用在其他实例有相同或者更长的生命周期时使用</li><li>在被声明的属性或者变量（<strong>非可选类型</strong>）前面加上关键字 <code>unowned</code> 表示无主引用</li><li>ARC 无法在实例被销毁后将无主引用设为 <code>nil</code></li></ul><blockquote><p>使用无主引用，你必须确保引用始终指向一个未销毁的实例。</p><p>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。</p></blockquote><pre><code>class Customer &#123;    let name: String    var card: CreditCard?    init(name: String) &#123;        self.name = name    &#125;    deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;class CreditCard &#123;    let number: UInt64    unowned let customer: Customer    init(number: UInt64, customer: Customer) &#123;        self.number = number        self.customer = customer    &#125;    deinit &#123; print(&quot;Card #\(number) is being deinitialized&quot;) &#125;&#125;</code></pre><p>下面的代码片段定义了一个叫 <code>john</code> 的可选类型 <code>Customer</code> 变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为 <code>nil</code>：</p><pre><code>var john: Customer?</code></pre><p>现在你可以创建 <code>Customer</code> 类的实例，用它初始化 <code>CreditCard</code> 实例，并将新创建的 <code>CreditCard</code> 实例赋值为客户的 <code>card</code> 属性：</p><pre><code>john = Customer(name: &quot;John Appleseed&quot;)john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)</code></pre><p>在关联两个实例后，它们的引用关系如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB6.png"></p><p>由于 <code>customer</code> 的无主引用，当你断开 <code>john</code> 变量持有的强引用时，再也没有指向 <code>Customer</code> 实例的强引用了：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB7.png"></p><p>由于再也没有指向 <code>Customer</code> 实例的强引用，该实例被销毁了。其后，再也没有指向 <code>CreditCard</code> 实例的强引用，该实例也随之被销毁了：</p><pre><code>john = nil// 打印“John Appleseed is being deinitialized”// 打印“Card #1234567890123456 is being deinitialized”</code></pre><h4 id="3-2-3-无主引用和隐式解包可选值属性"><a href="#3-2-3-无主引用和隐式解包可选值属性" class="headerlink" title="3.2.3 无主引用和隐式解包可选值属性"></a>3.2.3 无主引用和隐式解包可选值属性</h4><p>上面的例子涵盖了两种常用的需要打破循环强引用的场景:</p><ul><li>弱引用: 两个属性的值都允许为 <code>nil</code>，并会潜在的产生循环强引用</li><li>无主引用: 一个属性的值允许为 <code>nil</code>，而另一个属性的值不允许为 <code>nil</code>，这也可能会产生循环强引用</li></ul><p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为 <code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解包可选值属性。</p><p>这使两个属性在初始化完成后能被直接访问（不需要可选解包），同时避免了循环引用</p><pre><code>class Country &#123;    let name: String    var capitalCity: City!    init(name: String, capitalName: String) &#123;        self.name = name        self.capitalCity = City(name: capitalName, country: self)    &#125;&#125;class City &#123;    let name: String    unowned let country: Country    init(name: String, country: Country) &#123;        self.name = name        self.country = country    &#125;&#125;</code></pre><p><code>Country</code> 的构造器调用了 <code>City</code> 的构造器。然而，只有 <code>Country</code> 的实例完全初始化后，<code>Country</code> 的构造器才能把 <code>self</code> 传给 <code>City</code> 的构造器。</p><p>为了满足这种需求，通过在类型结尾处加上感叹号（<code>City!</code>）的方式，将 <code>Country</code> 的 <code>capitalCity</code> 属性声明为隐式解包可选值类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code> 属性的默认值为 <code>nil</code>，但是不需要解包它的值就能访问它。</p><p>由于 <code>capitalCity</code> 默认值为 <code>nil</code>，一旦 <code>Country</code> 的实例在构造器中给 <code>name</code> 属性赋值后，整个初始化过程就完成了。这意味着一旦 <code>name</code> 属性被赋值后，<code>Country</code> 的构造器就能引用并传递隐式的 <code>self</code>。<code>Country</code> 的构造器在赋值 <code>capitalCity</code> 时，就能将 <code>self</code> 作为参数传递给 <code>City</code> 的构造器。</p><p>上述的意义在于你可以通过一条语句同时创建 Country 和 City 的实例，而不产生循环强引用，并且 capitalCity 的属性能被直接访问，而不需要通过感叹号来解包它的可选值：</p><pre><code>var country = Country(name: &quot;Canada&quot;, capitalName: &quot;Ottawa&quot;)print(&quot;\(country.name)&#39;s capital city is called \(country.capitalCity.name)&quot;)// 打印“Canada&#39;s capital city is called Ottawa”</code></pre><h2 id="4-闭包的循环强引用"><a href="#4-闭包的循环强引用" class="headerlink" title="4.闭包的循环强引用"></a>4.闭包的循环强引用</h2><p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如 <code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod()</code>。这两种情况都导致了闭包 “捕获” <code>self</code>，从而产生了循环强引用。</p><h3 id="4-1-闭包循环强引用实例"><a href="#4-1-闭包循环强引用实例" class="headerlink" title="4.1 闭包循环强引用实例"></a>4.1 闭包循环强引用实例</h3><pre><code>class HTMLElement &#123;    let name: String    let text: String?    lazy var asHTML: () -&gt; String = &#123;        if let text = self.text &#123;            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;        &#125; else &#123;            return &quot;&lt;\(self.name) /&gt;&quot;        &#125;    &#125;    init(name: String, text: String? = nil) &#123;        self.name = name        self.text = text    &#125;    deinit &#123;        print(&quot;\(name) is being deinitialized&quot;)    &#125;&#125;</code></pre><p>创建实例并打印消息：</p><pre><code>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)print(paragraph!.asHTML())// 打印“&lt;p&gt;hello, world&lt;/p&gt;”</code></pre><p>然而上面写的 <code>HTMLElement</code> 类产生了类实例和作为 <code>asHTML</code> 默认值的闭包之间的循环强引用。循环强引用如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB8.png"></p><blockquote><p>实例的 <code>asHTML</code> 属性持有闭包的强引用。但是，闭包在其闭包体内使用了 <code>self</code>（引用了 <code>self.name</code> 和 <code>self.text</code>），因此闭包捕获了 <code>self</code>，这意味着闭包又反过来持有了 <code>HTMLElement</code> 实例的强引用。这样两个对象就产生了循环强引用</p></blockquote><p>如果设置 <code>paragraph</code> 变量为 <code>nil</code>，打破它持有的 <code>HTMLElement</code> 实例的强引用，<code>HTMLElement</code> 实例和它的闭包都不会被销毁，也是因为循环强引用：</p><pre><code>paragraph = nil</code></pre><p><code>HTMLElement</code> 的析构器中的消息并没有被打印，证明了 <code>HTMLElement</code> 实例并没有被销毁。</p><h3 id="4-2-解决闭包的循环强引用"><a href="#4-2-解决闭包的循环强引用" class="headerlink" title="4.2 解决闭包的循环强引用"></a>4.2 解决闭包的循环强引用</h3><p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。</p><p>捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p><blockquote><p>Swift 有如下要求：只要在闭包内使用 <code>self</code> 的成员，就要用 <code>self.someProperty</code> 或者 <code>self.someMethod()</code>（而不只是 <code>someProperty</code> 或 <code>someMethod()</code>）。这提醒你可能会一不小心就捕获了 <code>self</code>。</p></blockquote><h4 id="4-2-1-定义捕获列表"><a href="#4-2-1-定义捕获列表" class="headerlink" title="4.2.1 定义捕获列表"></a>4.2.1 定义捕获列表</h4><p>捕获列表中的每一项都由一对元素组成:</p><ul><li>一个元素是 <code>weak</code> 或 <code>unowned</code> 关键字，</li><li>另一个元素是类实例的引用（例如 self）或初始化过的变量（如 <code>delegate = self.delegate</code>）。</li></ul><p>这些项在方括号中用逗号分开，如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p><pre><code>lazy var someClosure = &#123;    [unowned self, weak delegate = self.delegate]    (index: Int, stringToProcess: String) -&gt; String in    // 这里是闭包的函数体&#125;</code></pre><p>如果闭包没有指明参数列表或者返回类型，它们会通过上下文推断，那么可以把捕获列表和关键字 in 放在闭包最开始的地方：</p><pre><code>lazy var someClosure = &#123;    [unowned self, weak delegate = self.delegate] in    // 这里是闭包的函数体&#125;</code></pre><h4 id="4-2-2-弱引用和无主引用"><a href="#4-2-2-弱引用和无主引用" class="headerlink" title="4.2.2 弱引用和无主引用"></a>4.2.2 弱引用和无主引用</h4><p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 <code>无主引用</code>。</p><p>在被捕获的引用可能会变为 <code>nil</code> 时，将闭包内的捕获定义为 <code>弱引用</code>。<strong>弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为 nil</strong></p><blockquote><p>如果被捕获的引用绝对不会变为 nil，应该用无主引用，而不是弱引用。</p></blockquote><p>前面的 <code>HTMLElement</code> 例子中，无主引用是正确的解决循环强引用的方法。这样编写 <code>HTMLElement</code> 类来避免循环强引用：</p><pre><code>class HTMLElement &#123;    let name: String    let text: String?    lazy var asHTML: () -&gt; String = &#123;        // 将 self 捕获为无主引用而不是强引用        [unowned self] in        if let text = self.text &#123;            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;        &#125; else &#123;            return &quot;&lt;\(self.name) /&gt;&quot;        &#125;    &#125;    init(name: String, text: String? = nil) &#123;        self.name = name        self.text = text    &#125;    deinit &#123;        print(&quot;\(name) is being deinitialized&quot;)    &#125;&#125;</code></pre><p>和之前一样，我们可以创建并打印 <code>HTMLElement</code> 实例：</p><pre><code>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)print(paragraph!.asHTML())// 打印“&lt;p&gt;hello, world&lt;/p&gt;”</code></pre><p>使用捕获列表后引用关系如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0_%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB9.png"></p><p>这一次，闭包以无主引用的形式捕获 <code>self</code>，并不会持有 <code>HTMLElement</code> 实例的强引用。如果将 <code>paragraph</code> 赋值为 <code>nil</code>，<code>HTMLElement</code> 实例将会被销毁，并能看到它的析构器打印出的消息：</p><pre><code>paragraph = nil// 打印“p is being deinitialized”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 不透明类型</title>
      <link href="posts/3146898703.html"/>
      <url>posts/3146898703.html</url>
      
        <content type="html"><![CDATA[<p>具有不透明返回类型的函数或方法会隐藏返回值的类型信息。函数不再提供具体的类型作为返回类型，而是根据它支持的协议来描述返回值。在处理模块和调用代码之间的关系时，隐藏类型信息非常有用，因为返回的底层数据类型仍然可以保持私有。而且不同于返回协议类型，不透明类型能保证类型一致性 —— 编译器能获取到类型信息，同时模块使用者却不能获取到。</p><h2 id="1-不透明类型解决的问题"><a href="#1-不透明类型解决的问题" class="headerlink" title="1.不透明类型解决的问题"></a>1.不透明类型解决的问题</h2><p>下面是绘制 <code>ASCII</code> 符号构成的几何图形，通过 <code>draw()</code> 方法，会返回一个代表最终几何图形的字符串：</p><pre><code>protocol Shape &#123;    func draw() -&gt; String&#125;struct Triangle: Shape &#123;    var size: Int    func draw() -&gt; String &#123;        var result = [String]()        for length in 1...size &#123;            result.append(String(repeating: &quot;*&quot;, count: length))        &#125;        return result.joined(separator: &quot;\n&quot;)    &#125;&#125;let smallTriangle = Triangle(size: 3)print(smallTriangle.draw())// *// **// ***</code></pre><p>将上面绘制的图形利用泛型来实现垂直翻转（<strong>翻转操作的结果会暴露我们用于构造结果的泛型类型</strong>），具体实现为：</p><pre><code>struct FlippedShape&lt;T: Shape&gt;: Shape &#123;    var shape: T    func draw() -&gt; String &#123;        let lines = shape.draw().split(separator: &quot;\n&quot;)        return lines.reversed().joined(separator: &quot;\n&quot;)    &#125;&#125;let flippedTriangle = FlippedShape(shape: smallTriangle)print(flippedTriangle.draw())// ***// **// *</code></pre><p>将上面绘制的两个图形拼接起来，可以通过定义一个 <code>JoinedShape&lt;T: Shape, U: Shape&gt;</code> 结构体来实现：</p><pre><code>struct JoinedShape&lt;T: Shape, U: Shape&gt;: Shape &#123;    var top: T    var bottom: U    func draw() -&gt; String &#123;        return top.draw() + &quot;\n&quot; + bottom.draw()    &#125;&#125;let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)print(joinedTriangles.draw())// *// **// ***// ***// **// *</code></pre><p>暴露构造所用的具体类型会造成类型信息的泄露，因为 <code>ASCII</code> 几何图形模块的部分公开接口必须声明完整的返回类型，而实际上这些类型信息并不应该被公开声明。输出同一种几何图形，模块内部可能有多种实现方式，而外部使用时，应该与内部各种变换顺序的实现逻辑无关。诸如 <code>JoinedShape</code> 和 <code>FlippedShape</code> 这样包装后的类型，模块使用者并不关心，它们也不应该可见。模块的公开接口应该由拼接、翻转等基础操作组成，这些操作也应该返回独立的 <code>Shape</code> 类型的值。</p><h2 id="2-返回不透明类型"><a href="#2-返回不透明类型" class="headerlink" title="2.返回不透明类型"></a>2.返回不透明类型</h2><p>泛型允许调用一个方法时，为这个方法的形参和返回值指定一个与实现无关的类型，比如函数的返回值类型就由它的调用者决定：</p><pre><code>func max&lt;T&gt;(_ x: T, _ y: T) -&gt; T where T: Comparable &#123; ... &#125;</code></pre><p>而在返回不透明类型的函数中，上述角色发生了互换。不透明类型允许函数实现时，选择一个与调用代码无关的返回类型。比如，下面的例子返回了一个梯形，却没直接输出梯形的底层类型：</p><pre><code>struct Square: Shape &#123;    var size: Int    func draw() -&gt; String &#123;        let line = String(repeating: &quot;*&quot;, count: size)        let result = Array&lt;String&gt;(repeating: line, count: size)        return result.joined(separator: &quot;\n&quot;)    &#125;&#125;func makeTrapezoid() -&gt; some Shape &#123;    let top = Triangle(size: 2)    let middle = Square(size: 2)    let bottom = FlippedShape(shape: top)    let trapezoid = JoinedShape(        top: top,        bottom: JoinedShape(top: middle, bottom: bottom)    )    return trapezoid&#125;let trapezoid = makeTrapezoid()print(trapezoid.draw())// *// **// **// **// **// *</code></pre><blockquote><p>这个例子凸显了不透明返回类型和泛型的相反之处。<code>makeTrapezoid()</code> 中代码可以返回任意它需要的类型，只要这个类型是遵循 <code>Shape</code> 协议的，就像调用泛型函数时可以使用任何需要的类型一样。这个函数的调用代码需要采用通用的方式，就像泛型函数的实现代码一样，这样才能让 <code>makeTrapezoid()</code> 返回的任何 <code>Shape</code> 类型的值都能被正常使用。</p></blockquote><p>也可以将不透明返回类型和泛型结合起来，下面的两个泛型函数也都返回了遵循 <code>Shape</code> 协议的不透明类型:</p><pre><code>func flip&lt;T: Shape&gt;(_ shape: T) -&gt; some Shape &#123;    return FlippedShape(shape: shape)&#125;func join&lt;T: Shape, U: Shape&gt;(_ top: T, _ bottom: U) -&gt; some Shape &#123;    JoinedShape(top: top, bottom: bottom)&#125;let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))print(opaqueJoinedTriangles.draw())// *// **// ***// ***// **// *</code></pre><blockquote><p><code>flip(-:)</code> 和 <code>join(-:-:)</code> 将对泛型参数的操作后的返回结果包装成了不透明类型，这样保证了在结果中泛型参数类型不可见。两个函数都是泛型函数，因为他们都依赖于泛型参数，而泛型参数又将 <code>FlippedShape</code> 和 <code>JoinedShape</code> 所需要的类型信息传递给它们。</p></blockquote><p>如果函数中有多个地方返回了不透明类型，那么所有可能的返回值都必须是同一类型。即使对于泛型函数，不透明返回类型可以使用泛型参数，但仍需保证返回类型唯一。比如，下面就是一个非法示例 —— 包含针对 <code>Square</code> 类型进行特殊处理的翻转函数。</p><pre><code>func invalidFlip&lt;T: Shape&gt;(_ shape: T) -&gt; some Shape &#123;    if shape is Square &#123;        return shape // 错误：返回类型不一致    &#125;    return FlippedShape(shape: shape) // 错误：返回类型不一致&#125;</code></pre><p>如果你调用这个函数时传入一个 <code>Square</code> 类型，那么它会返回 <code>Square</code> 类型；否则，它会返回一个 <code>FlippedShape</code> 类型。这违反了返回值类型唯一的要求，所以 <code>invalidFlip(_:)</code> 不正确。修正 <code>invalidFlip(_:)</code> 的方法之一就是将针对 <code>Square</code> 的特殊处理移入到 <code>FlippedShape</code> 的实现中去，这样就能保证这个函数始终返回 <code>FlippedShape</code>：</p><pre><code>struct FlippedShape&lt;T: Shape&gt;: Shape &#123;    var shape: T    func draw() -&gt; String &#123;        if shape is Square &#123;            return shape.draw()        &#125;        let lines = shape.draw().split(separator: &quot;\n&quot;)        return lines.reversed().joined(separator: &quot;\n&quot;)    &#125;&#125;</code></pre><p>返回类型始终唯一的要求，并不会影响在返回的不透明类型中使用泛型。比如下面的函数，就是在返回的底层类型中使用了泛型参数：</p><pre><code>func `repeat`&lt;T: Shape&gt;(shape: T, count: Int) -&gt; some Collection &#123;    return Array&lt;T&gt;(repeating: shape, count: count)&#125;</code></pre><p>这种情况下，返回的底层类型会根据 <code>T</code> 的不同而发生变化：但无论什么形状被传入，<code>repeat(shape:count:)</code> 都会创建并返回一个元素为相应形状的数组。尽管如此，返回值始终还是同样的底层类型 [<code>T</code>]， 所以这符合不透明返回类型始终唯一的要求。</p><h2 id="3-不透明类型和协议类型的区别"><a href="#3-不透明类型和协议类型的区别" class="headerlink" title="3.不透明类型和协议类型的区别"></a>3.不透明类型和协议类型的区别</h2><p><strong>虽然使用不透明类型作为函数返回值，看起来和返回协议类型非常相似，但这两者有一个主要区别，就在于是否需要保证类型一致性</strong>。一个不透明类型只能对应一个具体的类型，即便函数调用者并不能知道是哪一种类型；协议类型可以同时对应多个类型，只要它们都遵循同一协议。总的来说，协议类型更具灵活性，底层类型可以存储更多样的值，而不透明类型对这些底层类型有更强的限定。</p><p>比如，<code>flip(_:)</code> 方法不采用不透明类型，而采用返回协议类型：</p><pre><code>func protoFlip&lt;T: Shape&gt;(_ shape: T) -&gt; Shape &#123;    return FlippedShape(shape: shape)&#125;</code></pre><p>这个版本的 <code>protoFlip(_:)</code> 和 <code>flip(_:)</code> 有相同的函数体，并且它也始终返回唯一类型。但不同于 <code>flip(_:)</code>，<code>protoFlip(_:)</code> 返回值其实不需要始终返回唯一类型 —— 返回类型只需要遵循 <code>Shape</code> 协议即可。换句话说，<code>protoFlip(_:)</code> 比起 <code>flip(_:)</code> 对 API 调用者的约束更加松散。它保留了返回多种不同类型的灵活性：</p><pre><code>func protoFlip&lt;T: Shape&gt;(_ shape: T) -&gt; Shape &#123;    if shape is Square &#123;        return shape    &#125;    return FlippedShape(shape: shape)&#125;</code></pre><p>修改后的代码根据代表形状的参数的不同，可能返回 <code>Square</code> 实例或者 <code>FlippedShape</code> 实例，所以同样的函数可能返回完全不同的两个类型。当翻转相同形状的多个实例时，此函数的其他有效版本也可能返回完全不同类型的结果。<code>protoFlip(_:)</code> 返回类型的不确定性，意味着很多依赖返回类型信息的操作也无法执行了。举个例子，这个函数的返回结果就不能用 == 运算符进行比较了。</p><pre><code>let protoFlippedTriangle = protoFlip(smallTriangle)let sameThing = protoFlip(smallTriangle)protoFlippedTriangle == sameThing  // 错误</code></pre><p>上面的例子中，最后一行的错误来源于多个原因。最直接的问题在于，<code>Shape</code> 协议中并没有包含对 <code>==</code> 运算符的声明。如果你尝试加上这个声明，那么你会遇到新的问题，就是 <code>==</code> 运算符需要知道左右两侧参数的类型。这类运算符通常会使用 <code>Self</code> 类型作为参数，用来匹配符合协议的具体类型，但是由于将协议当成类型使用时会发生类型擦除，所以并不能给协议加上对 <code>Self</code> 的实现要求。</p><p>将协议类型作为函数的返回类型能更加灵活，函数只要返回遵循协议的类型即可。然而，更具灵活性导致牺牲了对返回值执行某些操作的能力。上面的例子就说明了为什么不能使用 <code>==</code> 运算符 —— 它依赖于具体的类型信息，而这正是使用协议类型所无法提供的。</p><p>这种方法的另一个问题在于，变换形状的操作不能嵌套。翻转三角形的结果是一个 <code>Shape</code> 类型的值，而 <code>protoFlip(_:)</code> 方法的则将遵循 <code>Shape</code> 协议的类型作为形参，然而协议类型的值并不遵循这个协议；<code>protoFlip(_:)</code> 的返回值也并不遵循 <code>Shape</code> 协议。这就是说 <code>protoFlip(protoFlip(smallTriange))</code> 这样的多重变换操作是非法的，因为经过翻转操作后的结果类型并不能作为 <code>protoFlip(_:)</code> 的形参。</p><p>相比之下，不透明类型则保留了底层类型的唯一性。Swift 能够推断出关联类型，这个特点使得作为函数返回值，不透明类型比协议类型有更大的使用场景。比如，下面这个例子是 <code>泛型</code> 中讲到的 <code>Container</code> 协议：</p><pre><code>protocol Container &#123;    associatedtype Item    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;&#125;extension Array: Container &#123; &#125;</code></pre><p>你不能将 <code>Container</code> 作为方法的返回类型，因为此协议有一个关联类型。你也不能将它用于对泛型返回类型的约束，因为函数体之外并没有暴露足够多的信息来推断泛型类型。</p><pre><code>// 错误：有关联类型的协议不能作为返回类型。func makeProtocolContainer&lt;T&gt;(item: T) -&gt; Container &#123;    return [item]&#125;// 错误：没有足够多的信息来推断 C 的类型。func makeProtocolContainer&lt;T, C: Container&gt;(item: T) -&gt; C &#123;    return [item]&#125;</code></pre><p>而使用不透明类型 <code>some Container</code> 作为返回类型，就能够明确地表达所需要的 API 契约 —— 函数会返回一个集合类型，但并不指明它的具体类型：</p><pre><code>func makeOpaqueContainer&lt;T&gt;(item: T) -&gt; some Container &#123;    return [item]&#125;let opaqueContainer = makeOpaqueContainer(item: 12)let twelve = opaqueContainer[0]print(type(of: twelve))// 输出 &quot;Int&quot;</code></pre><p><code>twelve</code> 的类型可以被推断出为 <code>Int</code>， 这说明了类型推断适用于不透明类型。在 <code>makeOpaqueContainer(item:)</code> 的实现中，底层类型是不透明集合 [<code>T</code>]。在上述这种情况下，<code>T</code> 就是 <code>Int</code> 类型，所以返回值就是整数数组，而关联类型 <code>Item</code> 也被推断出为 <code>Int</code>。<code>Container</code> 协议中的 <code>subscipt</code> 方法会返回 <code>Item</code>，这也意味着 <code>twelve</code> 的类型也被能推断出为 <code>Int</code>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 泛型</title>
      <link href="posts/1236725232.html"/>
      <url>posts/1236725232.html</url>
      
        <content type="html"><![CDATA[<p><code>泛型</code>代码让你能根据自定义的需求，编写出适用于任意类型的、灵活可复用的函数及类型。你可避免编写重复的代码，而是用一种清晰抽象的方式来表达代码的意图。</p><p>泛型是 Swift 最强大的特性之一，很多 Swift 标准库是基于泛型代码构建的。实际上，即使你没有意识到，你也一直在语言指南中使用泛型。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 类型数组，也可创建一个 <code>String</code> 类型数组，甚至可以是任意其他 Swift 类型的数组。同样，你也可以创建一个存储任意指定类型的字典，并对该类型没有限制。</p><h2 id="1-泛型解决的问题"><a href="#1-泛型解决的问题" class="headerlink" title="1.泛型解决的问题"></a>1.泛型解决的问题</h2><p>非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p><pre><code>func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)// 打印“someInt is now 107, and anotherInt is now 3”</code></pre><p><code>swapTwoInts(_:_:)</code> 函数只能作用于 <code>Int</code> 类型。如果你想交换两个 <code>String</code> 类型值，或者 <code>Double</code> 类型值，你必须编写对应的函数，类似下面 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 函数：</p><pre><code>func swapTwoStrings(_ a: inout String, _ b: inout String) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;</code></pre><p>其实三个函数的函数体是一样的，但是接受的参数类型不一样，利用泛型代码就可以实现一个更实用更灵活的函数来交换两个任意类型的值。</p><blockquote><p>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型必须相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p></blockquote><h2 id="2-泛型函数"><a href="#2-泛型函数" class="headerlink" title="2.泛型函数"></a>2.泛型函数</h2><p>泛型函数可适用于任意类型，泛型函数和非泛型函数的区别：</p><ul><li>泛型函数名后面跟着占位类型名（<code>T</code>），并用尖括号括起来（<code>&lt;T&gt;</code>）</li><li>泛型函数接收任意类型的参数时，也需使用占位符类型名 <code>T</code></li></ul><pre><code>func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoValues(&amp;someInt, &amp;anotherInt)// someInt 现在是 107，anotherInt 现在是 3var someString = &quot;hello&quot;var anotherString = &quot;world&quot;swapTwoValues(&amp;someString, &amp;anotherString)// someString 现在是“world”，anotherString 现在是“hello”</code></pre><h2 id="3-类型参数"><a href="#3-类型参数" class="headerlink" title="3.类型参数"></a>3.类型参数</h2><p>上面 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是一个类型参数的例子，类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p><p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p><p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p><h2 id="4-命名类型参数"><a href="#4-命名类型参数" class="headerlink" title="4.命名类型参数"></a>4.命名类型参数</h2><p>大多情况下，类型参数具有描述下的名称，例如字典 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code> 及数组 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这能告诉阅读代码的人这些参数类型与泛型类型或函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字符来表示，例如 <code>T</code>、<code>U</code>、<code>V</code>，例如上面演示函数 <code>swapTwoValues(_:_:)</code> 中的 <code>T</code>。</p><blockquote><p>请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p></blockquote><h2 id="5-泛型类型"><a href="#5-泛型类型" class="headerlink" title="5.泛型类型"></a>5.泛型类型</h2><p>除了泛型函数，Swift 还允许自定义泛型类型。这些自定义类、结构体和枚举可以适用于任意类型，类似于 <code>Array</code> 和 <code>Dictionary</code>。</p><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%9E%8B_%E9%9D%9E%E6%B3%9B%E5%9E%8B%E5%85%A5%E6%A0%88%E5%87%BA%E6%A0%88.png"><br>与上图所对应的非泛型的栈的实现为，以 <code>Int</code> 的栈为例：</p><pre><code>struct IntStack &#123;    var items = [Int]()    mutating func push(_ item: Int) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Int &#123;        return items.removeLast()    &#125;&#125;</code></pre><p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理任意类型的值:</p><pre><code>struct Stack&lt;Element&gt; &#123;    var items = [Element]()    mutating func push(_ item: Element) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Element &#123;        return items.removeLast()    &#125;&#125;var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(&quot;uno&quot;)stackOfStrings.push(&quot;dos&quot;)stackOfStrings.push(&quot;tres&quot;)stackOfStrings.push(&quot;cuatro&quot;)// 栈中现在有 4 个字符串</code></pre><p>下图展示了 <code>stackOfStrings</code> 如何将这四个值压栈：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%9E%8B_%E6%B3%9B%E5%9E%8B%E5%85%A5%E6%A0%88.png"></p><p>移除并返回栈顶部的值“cuatro”，即出栈：</p><pre><code>let fromTheTop = stackOfStrings.pop()// fromTheTop 的值为“cuatro”，现在栈中还有 3 个字符串</code></pre><p>下图展示了如何将顶部的值出栈：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%9B%E5%9E%8B_%E6%B3%9B%E5%9E%8B%E5%87%BA%E6%A0%88.png"></p><h2 id="6-泛型扩展"><a href="#6-泛型扩展" class="headerlink" title="6.泛型扩展"></a>6.泛型扩展</h2><p>当对泛型类型进行扩展时，你并不需要提供类型参数列表作为定义的一部分。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p><pre><code>extension Stack &#123;    var topItem: Element? &#123;        return items.isEmpty ? nil : items[items.count - 1]    &#125;&#125;if let topItem = stackOfStrings.topItem &#123;    print(&quot;The top item on the stack is \(topItem).&quot;)&#125;// 打印“The top item on the stack is tres.”</code></pre><blockquote><p>注意：这个扩展并没有定义类型参数列表。相反的，Stack 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p></blockquote><h2 id="7-类型约束"><a href="#7-类型约束" class="headerlink" title="7.类型约束"></a>7.类型约束</h2><p><code>类型约束</code>：指定类型参数必须继承自指定类、遵循特定的协议或协议组合。</p><blockquote><p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在字典的描述中，字典键的类型必须是<code>可哈希（hashable）</code>的。也就是说，必须有一种方法能够唯一地表示它。字典键之所以要是可哈希的，是为了便于检查字典中是否已经包含某个特定键的值。若没有这个要求，字典将无法判断是否可以插入或替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p></blockquote><h3 id="7-1-类型约束语法"><a href="#7-1-类型约束语法" class="headerlink" title="7.1 类型约束语法"></a>7.1 类型约束语法</h3><p>在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束:</p><pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123;    // 这里是泛型函数的函数体部分&#125;</code></pre><p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code> 必须是 <code>SomeClass</code> 子类；第二个类型参数 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议。</p><h3 id="7-2-类型约束实践"><a href="#7-2-类型约束实践" class="headerlink" title="7.2 类型约束实践"></a>7.2 类型约束实践</h3><p>在一个 <code>String</code> 数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，函数返回该字符串在数组中的索引值，否则返回 <code>nil</code>，代码具体实现为：</p><pre><code>func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? &#123;    for (index, value) in array.enumerated() &#123;        if value == valueToFind &#123;            return index        &#125;    &#125;    return nil&#125;let strings = [&quot;cat&quot;, &quot;dog&quot;, &quot;llama&quot;, &quot;parakeet&quot;, &quot;terrapin&quot;]if let foundIndex = findIndex(ofString: &quot;llama&quot;, in: strings) &#123;    print(&quot;The index of llama is \(foundIndex)&quot;)&#125;// 打印“The index of llama is 2”</code></pre><p><code>findIndex(ofString:in:)</code> 函数只能查找字符串在数组中的索引，但可以相同功能的泛型函数：</p><pre><code>func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123;    for (index, value) in array.enumerated() &#123;        if value == valueToFind &#123;            return index        &#125;    &#125;    return nil&#125;</code></pre><blockquote><p>上面函数无法通过编译，问题出在相等性检查上，即 “if value == valueToFind”。不是所有的 Swift 类型都可以用等式符（==）进行比较。例如，如果你自定义类或结构体来描述复杂的数据模型，对于这个类或结构体而言，Swift 无法明确知道“相等”意味着什么。正因如此，这部分代码无法保证适用于任意类型 <code>T</code>，当你试图编译这部分代码时就会出现相应的错误</p></blockquote><p>Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何遵循该协议的类型必须实现等式符（<code>==</code>）及不等符（<code>!=</code>），从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议，因此 <code>findIndex(of:in:)</code> 函数可以修改为：</p><pre><code>func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123;    for (index, value) in array.enumerated() &#123;        if value == valueToFind &#123;            return index        &#125;    &#125;    return nil&#125;</code></pre><p><code>findIndex(of:in:)</code> 函数现在可以成功编译了，并且适用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p><pre><code>let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中let stringIndex = findIndex(of: &quot;Andrea&quot;, in: [&quot;Mike&quot;, &quot;Malcolm&quot;, &quot;Andrea&quot;])// stringIndex 类型为 Int?，其值为 2</code></pre><h2 id="8-关联类型"><a href="#8-关联类型" class="headerlink" title="8.关联类型"></a>8.关联类型</h2><p>关联类型为协议中的某个类型提供了一个占位符名称，其代表的实际类型在协议被遵循时才会被指定。关联类型通过 <code>associatedtype</code> 关键字来指定。</p><h3 id="8-1-关联类型实践"><a href="#8-1-关联类型实践" class="headerlink" title="8.1 关联类型实践"></a>8.1 关联类型实践</h3><pre><code>protocol Container &#123;    associatedtype Item    mutating func append(_ item: Item)    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;&#125;</code></pre><p>任何遵从 <code>Container</code> 协议的类型必须提供以下三个功能：</p><ul><li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li><li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 <code>Int</code> 值。</li><li>必须可以通过索引值类型为 <code>Int</code> 的下标检索到容器中的每一个元素。</li></ul><p>遵循 <code>Container</code> 协议的非泛型版本 <code>IntStack</code> 类型：</p><pre><code>struct IntStack: Container &#123;    // IntStack 的原始实现部分    var items = [Int]()    mutating func push(_ item: Int) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Int &#123;        return items.removeLast()    &#125;    // Container 协议的实现部分    typealias Item = Int    mutating func append(_ item: Int) &#123;        self.push(item)    &#125;    var count: Int &#123;        return items.count    &#125;    subscript(i: Int) -&gt; Int &#123;        return items[i]    &#125;&#125;</code></pre><p>泛型 <code>Stack</code> 结构体遵循 <code>Container</code> 协议的实现版本：</p><pre><code>struct Stack&lt;Element&gt;: Container &#123;    // Stack&lt;Element&gt; 的原始实现部分    var items = [Element]()    mutating func push(_ item: Element) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; Element &#123;        return items.removeLast()    &#125;    // Container 协议的实现部分    mutating func append(_ item: Element) &#123;        self.push(item)    &#125;    var count: Int &#123;        return items.count    &#125;    subscript(i: Int) -&gt; Element &#123;        return items[i]    &#125;&#125;</code></pre><h3 id="8-2-扩展现有类型来指定关联类型"><a href="#8-2-扩展现有类型来指定关联类型" class="headerlink" title="8.2 扩展现有类型来指定关联类型"></a>8.2 扩展现有类型来指定关联类型</h3><p>Swift 的 <code>Array</code> 类型已经提供 <code>append(_:)</code> 方法，<code>count</code> 属性，以及带有 <code>Int</code> 索引的下标来检索其元素。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你只需声明 <code>Array</code> 遵循<code>Container</code> 协议，就可以扩展 <code>Array</code>，使其遵从 <code>Container</code> 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：</p><pre><code>extension Array: Container &#123;&#125;</code></pre><p>Array 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>Item</code> 具体类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 <code>Container</code> 来使用。</p><h3 id="8-3-给关联类型添加约束"><a href="#8-3-给关联类型添加约束" class="headerlink" title="8.3 给关联类型添加约束"></a>8.3 给关联类型添加约束</h3><p>在协议里给关联类型添加约束来要求遵循的类型满足约束:</p><pre><code>protocol Container &#123;    associatedtype Item: Equatable    mutating func append(_ item: Item)    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;&#125;//要遵守 Container 协议，Item 类型也必须遵守 Equatable 协议。</code></pre><h3 id="8-4-在关联类型约束里使用协议"><a href="#8-4-在关联类型约束里使用协议" class="headerlink" title="8.4 在关联类型约束里使用协议"></a>8.4 在关联类型约束里使用协议</h3><p>协议可以作为它自身的要求出现。例如，有一个协议细化了 <code>Container</code> 协议，添加了一个 <code>suffix(_:)</code> 方法。<code>suffix(_:)</code> 方法返回容器中从后往前给定数量的元素，并把它们存储在一个 <code>Suffix</code> 类型的实例里。</p><pre><code>protocol SuffixableContainer: Container &#123;    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item    func suffix(_ size: Int) -&gt; Suffix&#125;</code></pre><p>在这个协议里，<code>Suffix</code> 是一个关联类型，<code>Suffix</code> 拥有两个约束：</p><ul><li>它必须遵循 <code>SuffixableContainer</code> 协议（就是当前定义的协议）;</li><li>它的 <code>Item</code> 类型必须是和容器里的 <code>Item</code> 类型相同，<code>Item</code> 的约束是一个 <code>where</code> 分句</li></ul><p>下面是 泛型类型 中 <code>Stack</code> 类型的扩展，它遵循了 <code>SuffixableContainer</code> 协议：</p><pre><code>extension Stack: SuffixableContainer &#123;    func suffix(_ size: Int) -&gt; Stack &#123;        var result = Stack()        for index in (count-size)..&lt;count &#123;            result.append(self[index])        &#125;        return result    &#125;    // 推断 suffix 结果是Stack。&#125;var stackOfInts = Stack&lt;Int&gt;()stackOfInts.append(10)stackOfInts.append(20)stackOfInts.append(30)let suffix = stackOfInts.suffix(2)// suffix 包含 20 和 30</code></pre><p>在上面的例子中，<code>Suffix</code> 是 <code>Stack</code> 的关联类型，也是 <code>Stack</code> ，所以 <code>Stack</code> 的后缀运算返回另一个 <code>Stack</code> 。另外，遵循 <code>SuffixableContainer</code> 的类型可以拥有一个与它自己不同的 <code>Suffix</code> 类型——也就是说后缀运算可以返回不同的类型。比如说，这里有一个非泛型 <code>IntStack</code> 类型的扩展，它遵循了 <code>SuffixableContainer</code> 协议，使用 <code>Stack&lt;Int&gt;</code> 作为它的后缀类型而不是 <code>IntStack</code>：</p><pre><code>extension IntStack: SuffixableContainer &#123;    func suffix(_ size: Int) -&gt; Stack&lt;Int&gt; &#123;        var result = Stack&lt;Int&gt;()        for index in (count-size)..&lt;count &#123;            result.append(self[index])        &#125;        return result    &#125;    // 推断 suffix 结果是 Stack&lt;Int&gt;。&#125;</code></pre><h2 id="9-泛型-Where-语句"><a href="#9-泛型-Where-语句" class="headerlink" title="9.泛型 Where 语句"></a>9.泛型 Where 语句</h2><p>可以通过定义一个泛型 <code>where</code> 子句，来对关联类型添加约束。将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 <code>where</code> 子句。</p><pre><code>//用来检查两个 Container 实例是否包含相同顺序的相同元素func allItemsMatch&lt;C1: Container, C2: Container&gt;    (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool    where C1.Item == C2.Item, C1.Item: Equatable &#123;        // 检查两个容器含有相同数量的元素        if someContainer.count != anotherContainer.count &#123;            return false        &#125;        // 检查每一对元素是否相等        for i in 0..&lt;someContainer.count &#123;            if someContainer[i] != anotherContainer[i] &#123;                return false            &#125;        &#125;        // 所有元素都匹配，返回 true        return true&#125;</code></pre><p>这个函数的类型参数列表还定义了对两个类型参数的要求：</p><ul><li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li><li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li><li><code>C1</code> 的 <code>Item</code> 必须和 <code>C2</code> 的 <code>Item</code> 类型相同（写作 <code>C1.Item == C2.Item</code>）。</li><li><code>C1</code> 的 <code>Item</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.Item: Equatable</code>）。</li></ul><p>这些要求意味着：</p><ul><li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li><li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li><li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li><li><code>someContainer</code> 中的元素可以通过不等于操作符（<code>!=</code>）来检查它们是否相同。</li></ul><p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p><p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们的容器类型不同。</p><p>下面是 <code>allItemsMatch(_:_:)</code> 函数的示例：</p><pre><code>var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(&quot;uno&quot;)stackOfStrings.push(&quot;dos&quot;)stackOfStrings.push(&quot;tres&quot;)var arrayOfStrings = [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;]if allItemsMatch(stackOfStrings, arrayOfStrings) &#123;    print(&quot;All items match.&quot;)&#125; else &#123;    print(&quot;Not all items match.&quot;)&#125;// 打印“All items match.”</code></pre><h2 id="10-具有泛型-Where-子句的扩展"><a href="#10-具有泛型-Where-子句的扩展" class="headerlink" title="10.具有泛型 Where 子句的扩展"></a>10.具有泛型 Where 子句的扩展</h2><h3 id="10-1-使用泛型-where-子句作为扩展的一部分"><a href="#10-1-使用泛型-where-子句作为扩展的一部分" class="headerlink" title="10.1 使用泛型 where 子句作为扩展的一部分"></a>10.1 使用泛型 where 子句作为扩展的一部分</h3><pre><code>extension Stack where Element: Equatable &#123;    // 检查这个栈是不是空的    func isTop(_ item: Element) -&gt; Bool &#123;        guard let topItem = items.last else &#123;            return false        &#125;        return topItem == item    &#125;&#125;// 调用：if stackOfStrings.isTop(&quot;tres&quot;) &#123;    print(&quot;Top element is tres.&quot;)&#125; else &#123;    print(&quot;Top element is something else.&quot;)&#125;// 打印“Top element is tres.”</code></pre><p>如果尝试在其元素不符合 <code>Equatable</code> 协议的栈上调用 <code>isTop(_:)</code> 方法，则会收到编译时错误。</p><pre><code>struct NotEquatable &#123; &#125;var notEquatableStack = Stack&lt;NotEquatable&gt;()let notEquatableValue = NotEquatable()notEquatableStack.push(notEquatableValue)notEquatableStack.isTop(notEquatableValue)  // 报错</code></pre><h3 id="10-2-使用泛型-where-子句去扩展协议"><a href="#10-2-使用泛型-where-子句去扩展协议" class="headerlink" title="10.2 使用泛型 where 子句去扩展协议"></a>10.2 使用泛型 where 子句去扩展协议</h3><p><code>startsWith(_:)</code> 方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等:</p><pre><code>extension Container where Item: Equatable &#123;    func startsWith(_ item: Item) -&gt; Bool &#123;        return count &gt;= 1 &amp;&amp; self[0] == item    &#125;&#125;if [9, 9, 9].startsWith(42) &#123;    print(&quot;Starts with 42.&quot;)&#125; else &#123;    print(&quot;Starts with something else.&quot;)&#125;// 打印“Starts with something else.”</code></pre><p>上述示例中的泛型 <code>where</code> 子句要求 <code>Item</code> 遵循协议，但也可以编写一个泛型 <code>where</code> 子句去要求 <code>Item</code> 为特定类型。例如：</p><pre><code>extension Container where Item == Double &#123;    func average() -&gt; Double &#123;        var sum = 0.0        for index in 0..&lt;count &#123;            sum += self[index]        &#125;        return sum / Double(count)    &#125;&#125;print([1260.0, 1200.0, 98.6, 37.0].average())// 打印“648.9”</code></pre><blockquote><p>可以在一个泛型 <code>where</code> 子句中包含多个条件作为扩展的一部分。用逗号分隔列表中的每个条件。</p></blockquote><h2 id="11-包含上下文关系的-where-分句"><a href="#11-包含上下文关系的-where-分句" class="headerlink" title="11.包含上下文关系的 where 分句"></a>11.包含上下文关系的 where 分句</h2><p>当你使用泛型时，可以为没有独立类型约束的声明添加 <code>where</code> 分句。例如，你可以使用 <code>where</code> 分句为泛型添加下标，或为扩展方法添加泛型约束。<code>Container</code> 结构体是个泛型，下面的例子通过 <code>where</code> 分句让新的方法声明其调用所需要满足的类型约束。</p><pre><code>extension Container &#123;    func average() -&gt; Double where Item == Int &#123;        var sum = 0.0        for index in 0..&lt;count &#123;            sum += Double(self[index])        &#125;        return sum / Double(count)    &#125;    func endsWith(_ item: Item) -&gt; Bool where Item: Equatable &#123;        return count &gt;= 1 &amp;&amp; self[count-1] == item    &#125;&#125;let numbers = [1260, 1200, 98, 37]print(numbers.average())// 输出 &quot;648.75&quot;print(numbers.endsWith(37))// 输出 &quot;true&quot;</code></pre><p>如果不使用包含上下文关系的 <code>where</code> 分句，需要写两个扩展，并为每个扩展分别加上 <code>where</code> 分句。下面的例子和上面的具有相同效果。</p><pre><code>extension Container where Item == Int &#123;    func average() -&gt; Double &#123;        var sum = 0.0        for index in 0..&lt;count &#123;            sum += Double(self[index])        &#125;        return sum / Double(count)    &#125;&#125;extension Container where Item: Equatable &#123;    func endsWith(_ item: Item) -&gt; Bool &#123;        return count &gt;= 1 &amp;&amp; self[count-1] == item    &#125;&#125;</code></pre><p>在包含上下文关系的 <code>where</code> 分句的例子中，由于每个方法的 <code>where</code> 分句各自声明了需要满足的条件，因此 <code>average()</code> 和 <code>endsWith(_:)</code> 的实现能放在同一个扩展里。而将 <code>where</code> 分句放在扩展进行声明也能起到同样的效果，但每一个扩展只能有一个必备条件。</p><h2 id="12-具有泛型-Where-子句的关联类型"><a href="#12-具有泛型-Where-子句的关联类型" class="headerlink" title="12.具有泛型 Where 子句的关联类型"></a>12.具有泛型 Where 子句的关联类型</h2><p>你可以在关联类型后面加上具有泛型 <code>where</code> 的子句。例如，建立一个包含迭代器（Iterator）的容器，就像是标准库中使用的 <code>Sequence</code> 协议那样。你应该这么写：</p><pre><code>protocol Container &#123;    associatedtype Item    mutating func append(_ item: Item)    var count: Int &#123; get &#125;    subscript(i: Int) -&gt; Item &#123; get &#125;    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item    func makeIterator() -&gt; Iterator&#125;// 迭代器（Iterator）的泛型 where 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。makeIterator() 则提供了容器的迭代器的访问接口。</code></pre><p>一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 <code>where</code> 子句，来添加了一个约束到被继承协议的关联类型。例如，下面的代码声明了一个 <code>ComparableContainer</code> 协议，它要求所有的 <code>Item</code> 必须是 <code>Comparable</code> 的:</p><pre><code>protocol ComparableContainer: Container where Item: Comparable &#123; &#125;</code></pre><h2 id="13-泛型下标"><a href="#13-泛型下标" class="headerlink" title="13.泛型下标"></a>13.泛型下标</h2><p>下标可以是泛型，它们能够包含泛型 <code>where</code> 子句。你可以在 <code>subscript</code> 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 <code>where</code> 子句。例如：</p><pre><code>extension Container &#123;    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]        where Indices.Iterator.Element == Int &#123;            var result = [Item]()            for index in indices &#123;                result.append(self[index])            &#125;            return result    &#125;&#125;</code></pre><p>这个 <code>Container</code> 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：</p><ul><li>在尖括号中的泛型参数 <code>Indices</code>，必须是符合标准库中的 <code>Sequence</code> 协议的类型。</li><li>下标使用的单一的参数，<code>indices</code>，必须是 <code>Indices</code> 的实例。</li><li>泛型 where 子句要求 <code>Sequence</code>（Indices）的迭代器，其所有的元素都是 <code>Int</code> 类型。这样就能确保在序列（Sequence）中的索引和容器（Container）里面的索引类型是一致的。</li></ul><p>综合一下，这些约束意味着，传入到 <code>indices</code> 下标，是一个整型的序列。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 协议</title>
      <link href="posts/2463246486.html"/>
      <url>posts/2463246486.html</url>
      
        <content type="html"><![CDATA[<p>关于<code>协议</code>：规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。</p><p>关于遵循协议的类型：</p><ul><li>类、结构体或枚举都可以遵循协议</li><li>必须为协议定义的要求提供具体实现</li><li>可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能</li></ul><h2 id="1-协议语法"><a href="#1-协议语法" class="headerlink" title="1.协议语法"></a>1.协议语法</h2><p>协议的定义方式与类、结构体和枚举的定义非常相似：</p><pre><code>protocol SomeProtocol &#123;    // 这里是协议的定义部分&#125;</code></pre><p>自定义类型遵循某个协议，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔。遵循多个协议时，各协议之间用逗号（<code>,</code>）分隔：</p><pre><code>struct SomeStructure: FirstProtocol, AnotherProtocol &#123;    // 这里是结构体的定义部分&#125;</code></pre><p>若一个拥有父类的类在遵循协议时，应该<strong>将父类名放在协议名之前</strong>，以逗号分隔：</p><pre><code>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;    // 这里是类的定义部分&#125;</code></pre><h2 id="2-属性要求"><a href="#2-属性要求" class="headerlink" title="2.属性要求"></a>2.属性要求</h2><p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。</p><blockquote><p>注意：</p><ul><li>协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型</li><li>协议还指定属性是<code>可读</code>的还是<code>可读写</code>的</li><li>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</li></ul></blockquote><p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>&#123; set get &#125;</code> 来表示属性是可读可写的，可读属性则用 <code>&#123; get &#125;</code> 来表示：</p><pre><code>protocol SomeProtocol &#123;    var mustBeSettable: Int &#123; get set &#125;    var doesNotNeedToBeSettable: Int &#123; get &#125;&#125;</code></pre><p>在协议中定义类型属性时，使用 <code>static</code> 关键字作为前缀，当类类型遵循协议时，还可以使用 <code>class</code> 关键字来声明类型属性：</p><pre><code>protocol AnotherProtocol &#123;    static var someTypeProperty: Int &#123; get set &#125;&#125;</code></pre><p>举例：只含有一个实例属性要求的协议，这个协议表示，任何遵循 <code>FullyNamed</code> 的类型，都必须有一个可读的 <code>String</code> 类型的实例属性 <code>fullName</code></p><pre><code>protocol FullyNamed &#123;    var fullName: String &#123; get &#125;&#125;</code></pre><p>遵循 <code>FullyNamed</code> 协议的简单结构体：</p><pre><code>struct Person: FullyNamed &#123;    var fullName: String&#125;let john = Person(fullName: &quot;John Appleseed&quot;)// john.fullName 为 &quot;John Appleseed&quot;</code></pre><p>遵循 <code>FullyNamed</code> 协议的复杂类：</p><pre><code>class Starship: FullyNamed &#123;    var prefix: String?    var name: String    init(name: String, prefix: String? = nil) &#123;        self.name = name        self.prefix = prefix    &#125;    var fullName: String &#123;        return (prefix != nil ? prefix! + &quot; &quot; : &quot;&quot;) + name    &#125;&#125;var ncc1701 = Starship(name: &quot;Enterprise&quot;, prefix: &quot;USS&quot;)// ncc1701.fullName 为 &quot;USS Enterprise&quot;</code></pre><h2 id="3-方法要求"><a href="#3-方法要求" class="headerlink" title="3.方法要求"></a>3.方法要求</h2><p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法，这些方法：</p><ul><li>放在协议的定义中，但是不需要大括号和方法体</li><li>可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同</li><li>不支持为协议中的方法提供默认参数</li></ul><p>在协议中定义方法，类方法用 <code>class</code> 或者 <code>static</code> 关键字:</p><pre><code>protocol SomeProtocol &#123;    static func someTypeMethod()        func someInstanceMethod()&#125;</code></pre><p>举例：线性同余生成器（linear congruential generator） 的伪随机数算法：</p><pre><code>protocol RandomNumberGenerator &#123;    func random() -&gt; Double&#125;class LinearCongruentialGenerator: RandomNumberGenerator &#123;    var lastRandom = 42.0    let m = 139968.0    let a = 3877.0    let c = 29573.0    func random() -&gt; Double &#123;        //truncatingRemainder 浮点数取余        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))        return lastRandom / m    &#125;&#125;</code></pre><h2 id="4-异变方法要求"><a href="#4-异变方法要求" class="headerlink" title="4.异变方法要求"></a>4.异变方法要求</h2><p>定义协议时在方法前加 <code>mutating</code> 关键字，表示该方法会改变遵循该协议的类型的实例：</p><pre><code>protocol Togglable &#123;    mutating func toggle()&#125;enum OnOffSwitch: Togglable &#123;    case off, on    mutating func toggle() &#123;        switch self &#123;        case .off:            self = .on        case .on:            self = .off        &#125;    &#125;&#125;var lightSwitch = OnOffSwitch.offlightSwitch.toggle()// lightSwitch 现在的值为 .on</code></pre><blockquote><p>注意：实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p></blockquote><h2 id="5-构造器要求"><a href="#5-构造器要求" class="headerlink" title="5.构造器要求"></a>5.构造器要求</h2><p>协议可以要求遵循协议的类型实现指定的构造器，你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p><pre><code>protocol SomeProtocol &#123;    init(someParameter: Int)&#125;</code></pre><h3 id="5-1-协议构造器要求的类实现"><a href="#5-1-协议构造器要求的类实现" class="headerlink" title="5.1 协议构造器要求的类实现"></a>5.1 协议构造器要求的类实现</h3><p>可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p><pre><code>class SomeClass: SomeProtocol &#123;    required init(someParameter: Int) &#123;        // 这里是构造器的实现部分    &#125;&#125;</code></pre><p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。</p><blockquote><p>注意：如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。</p></blockquote><p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p><pre><code>protocol SomeProtocol &#123;    init()&#125;class SomeSuperClass &#123;    init() &#123;        // 这里是构造器的实现部分    &#125;&#125;class SomeSubClass: SomeSuperClass, SomeProtocol &#123;    // 因为遵循协议，需要加上 required    // 因为继承自父类，需要加上 override    required override init() &#123;        // 这里是构造器的实现部分    &#125;&#125;</code></pre><h3 id="5-2-可失败构造器要求"><a href="#5-2-可失败构造器要求" class="headerlink" title="5.2 可失败构造器要求"></a>5.2 可失败构造器要求</h3><p>协议还可以为遵循协议的类型定义可失败构造器要求</p><p>遵循协议的类型可以通过可失败构造器（<code>init?</code>）或非可失败构造器（<code>init</code>）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（<code>init</code>）或隐式解包可失败构造器（<code>init!</code>）来满足。</p><h2 id="6-协议作为类型"><a href="#6-协议作为类型" class="headerlink" title="6.协议作为类型"></a>6.协议作为类型</h2><p>协议可以像其他普通类型一样使用，使用场景如下：</p><ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ul><p>下面是将协议作为类型使用的例子：</p><pre><code>class Dice &#123;    let sides: Int    let generator: RandomNumberGenerator    init(sides: Int, generator: RandomNumberGenerator) &#123;        self.sides = sides        self.generator = generator    &#125;    func roll() -&gt; Int &#123;        return Int(generator.random() * Double(sides)) + 1    &#125;&#125;</code></pre><p><code>generator</code> 属性的类型为 <code>RandomNumberGenerator</code>，因此任何遵循了 <code>RandomNumberGenerator</code> 协议的类型的实例都可以赋值给 <code>generator</code>，除此之外并无其他要求。</p><pre><code>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())for _ in 1...5 &#123;    print(&quot;Random dice roll is \(d6.roll())&quot;)&#125;// Random dice roll is 3// Random dice roll is 5// Random dice roll is 4// Random dice roll is 5// Random dice roll is 4</code></pre><h2 id="7-委托"><a href="#7-委托" class="headerlink" title="7.委托"></a>7.委托</h2><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：<strong>定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能</strong>。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p><p>下面的例子定义了两个基于骰子游戏的协议：</p><pre><code>protocol DiceGame &#123;    var dice: Dice &#123; get &#125;    func play()&#125;protocol DiceGameDelegate &#123;    func gameDidStart(_ game: DiceGame)    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)    func gameDidEnd(_ game: DiceGame)&#125;</code></pre><p><a href="/posts/2571907037.html">控制流</a> 中蛇和梯子小游戏可以通过协议改写：</p><pre><code>class SnakesAndLadders: DiceGame &#123;    let finalSquare = 25    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())    var square = 0    var board: [Int]    init() &#123;        board = Array(repeating: 0, count: finalSquare + 1)        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08    &#125;    var delegate: DiceGameDelegate?    func play() &#123;        square = 0        delegate?.gameDidStart(self)        gameLoop: while square != finalSquare &#123;            let diceRoll = dice.roll()            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)            switch square + diceRoll &#123;            case finalSquare:                break gameLoop            case let newSquare where newSquare &gt; finalSquare:                continue gameLoop            default:                square += diceRoll                square += board[square]            &#125;        &#125;        delegate?.gameDidEnd(self)    &#125;&#125;class DiceGameTracker: DiceGameDelegate &#123;    var numberOfTurns = 0    func gameDidStart(_ game: DiceGame) &#123;        numberOfTurns = 0        if game is SnakesAndLadders &#123;            print(&quot;Started a new game of Snakes and Ladders&quot;)        &#125;        print(&quot;The game is using a \(game.dice.sides)-sided dice&quot;)    &#125;    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) &#123;        numberOfTurns += 1        print(&quot;Rolled a \(diceRoll)&quot;)    &#125;    func gameDidEnd(_ game: DiceGame) &#123;        print(&quot;The game lasted for \(numberOfTurns) turns&quot;)    &#125;&#125;let tracker = DiceGameTracker()let game = SnakesAndLadders()game.delegate = trackergame.play()// Started a new game of Snakes and Ladders// The game is using a 6-sided dice// Rolled a 3// Rolled a 5// Rolled a 4// Rolled a 5// The game lasted for 4 turns</code></pre><h2 id="8-在扩展里添加协议遵循"><a href="#8-在扩展里添加协议遵循" class="headerlink" title="8.在扩展里添加协议遵循"></a>8.在扩展里添加协议遵循</h2><p>可以通过扩展令已有类型遵循并符合协议，通过扩展遵循协议，和在原始定义中遵循协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p><pre><code>protocol TextRepresentable &#123;    var textualDescription: String &#123; get &#125;&#125;extension Dice: TextRepresentable &#123;    var textualDescription: String &#123;        return &quot;A \(sides)-sided dice&quot;    &#125;&#125;let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())print(d12.textualDescription)// 打印 “A 12-sided dice”</code></pre><h2 id="9-有条件地遵循协议"><a href="#9-有条件地遵循协议" class="headerlink" title="9.有条件地遵循协议"></a>9.有条件地遵循协议</h2><p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议，在你采纳协议的名字后面写泛型 <code>where</code> 分句：</p><pre><code>// 只要在存储遵循 TextRepresentable 协议的元素时就遵循 TextRepresentable 协议extension Array: TextRepresentable where Element: TextRepresentable &#123;    var textualDescription: String &#123;        let itemsAsText = self.map &#123; $0.textualDescription &#125;        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;    &#125;&#125;let myDice = [d6, d12]print(myDice.textualDescription)// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</code></pre><h2 id="10-在扩展里声明采纳协议"><a href="#10-在扩展里声明采纳协议" class="headerlink" title="10.在扩展里声明采纳协议"></a>10.在扩展里声明采纳协议</h2><p>当一个类型已经遵循了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空的扩展来让它采纳该协议：</p><pre><code>struct Hamster &#123;    var name: String       var textualDescription: String &#123;        return &quot;A hamster named \(name)&quot;    &#125;&#125;extension Hamster: TextRepresentable &#123;&#125; //Hamster 的实例可以作为 TextRepresentable 类型使用let simonTheHamster = Hamster(name: &quot;Simon&quot;)let somethingTextRepresentable: TextRepresentable = simonTheHamsterprint(somethingTextRepresentable.textualDescription)// 打印 “A hamster named Simon”</code></pre><blockquote><p>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p></blockquote><h2 id="11-使用合成实现来采纳协议"><a href="#11-使用合成实现来采纳协议" class="headerlink" title="11.使用合成实现来采纳协议"></a>11.使用合成实现来采纳协议</h2><p>Swift 可以自动提供一些简单场景下遵循 <code>Equatable</code>、<code>Hashable</code> 和 <code>Comparable</code> 协议的实现。在使用这些合成实现之后，无需再编写重复的代码来实现这些协议所要求的方法。</p><h3 id="11-1-Equatable"><a href="#11-1-Equatable" class="headerlink" title="11.1 Equatable"></a>11.1 Equatable</h3><p>Swift 为以下几种自定义类型提供了 <code>Equatable</code> 协议的合成实现：</p><ul><li>遵循 <code>Equatable</code> 协议且只有存储属性的结构体。</li><li>遵循 <code>Equatable</code> 协议且只有关联类型的枚举</li><li>没有任何关联类型的枚举</li></ul><p>在包含类型原始声明的文件中声明对 <code>Equatable</code> 协议的遵循，可以得到 <code>==</code> 操作符的合成实现，且无需自己编写任何关于 <code>==</code> 的实现代码。<code>Equatable</code> 协议同时包含 <code>!=</code> 操作符的默认实现。</p><pre><code>struct Vector3D: Equatable &#123;    var x = 0.0, y = 0.0, z = 0.0&#125;let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)if twoThreeFour == anotherTwoThreeFour &#123;    print(&quot;These two vectors are also equivalent.&quot;)&#125;// 打印 &quot;These two vectors are also equivalent.&quot;</code></pre><h3 id="11-2-Hashable"><a href="#11-2-Hashable" class="headerlink" title="11.2 Hashable"></a>11.2 Hashable</h3><p>Swift 为以下几种自定义类型提供了 <code>Hashable</code> 协议的合成实现：</p><ul><li>遵循 <code>Hashable</code> 协议且只有存储属性的结构体。</li><li>遵循 <code>Hashable</code> 协议且只有关联类型的枚举</li><li>没有任何关联类型的枚举</li></ul><p>在包含类型原始声明的文件中声明对 <code>Hashable</code> 协议的遵循，可以得到 <code>hash(into:)</code> 的合成实现，且无需自己编写任何关于 <code>hash(into:)</code> 的实现代码。</p><h3 id="11-3-Comparable"><a href="#11-3-Comparable" class="headerlink" title="11.3 Comparable"></a>11.3 Comparable</h3><p>Swift 为没有原始值的枚举类型提供了 <code>Comparable</code> 协议的合成实现。如果枚举类型包含关联类型，那这些关联类型也必须同时遵循 <code>Comparable</code> 协议。在包含原始枚举类型声明的文件中声明其对 <code>Comparable</code> 协议的遵循，可以得到 <code>&lt;</code> 操作符的合成实现，且无需自己编写任何关于 <code>&lt;</code> 的实现代码。<code>Comparable</code> 协议同时包含 <code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 操作符的默认实现</p><pre><code>enum SkillLevel: Comparable &#123;    case beginner    case intermediate    case expert(stars: Int)&#125;var levels = [SkillLevel.intermediate, SkillLevel.beginner,              SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]for level in levels.sorted() &#123;    print(level)&#125;// 打印 &quot;beginner&quot;// 打印 &quot;intermediate&quot;// 打印 &quot;expert(stars: 3)&quot;// 打印 &quot;expert(stars: 5)&quot;</code></pre><h2 id="12-协议类型的集合"><a href="#12-协议类型的集合" class="headerlink" title="12.协议类型的集合"></a>12.协议类型的集合</h2><p>协议类型可以在数组或者字典这样的集合中使用:</p><pre><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]for thing in things &#123;    print(thing.textualDescription)&#125;// A game of Snakes and Ladders with 25 squares// A 12-sided dice// A hamster named Simon</code></pre><h2 id="13-协议的继承"><a href="#13-协议的继承" class="headerlink" title="13.协议的继承"></a>13.协议的继承</h2><p>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p><pre><code>protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123;    // 这里是协议的定义部分&#125;</code></pre><pre><code>protocol PrettyTextRepresentable: TextRepresentable &#123;    var prettyTextualDescription: String &#123; get &#125;&#125;extension SnakesAndLadders: PrettyTextRepresentable &#123;    var prettyTextualDescription: String &#123;        var output = textualDescription + &quot;:\n&quot;        for index in 1...finalSquare &#123;            switch board[index] &#123;            case let ladder where ladder &gt; 0:                output += &quot;▲ &quot;            case let snake where snake &lt; 0:                output += &quot;▼ &quot;            default:                output += &quot;○ &quot;            &#125;        &#125;        return output    &#125;&#125;print(game.prettyTextualDescription)// A game of Snakes and Ladders with 25 squares:// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</code></pre><h2 id="14-类专属的协议"><a href="#14-类专属的协议" class="headerlink" title="14.类专属的协议"></a>14.类专属的协议</h2><p>添加 <code>AnyObject</code> 关键字到协议的继承列表，就可以限制协议只能被类类型采纳（以及非结构体或者非枚举的类型）</p><pre><code>protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123;    // 这里是类专属协议的定义部分&#125;</code></pre><blockquote><p>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议</p></blockquote><h2 id="15-协议合成"><a href="#15-协议合成" class="headerlink" title="15.协议合成"></a>15.协议合成</h2><p>一个类型同时遵循多个协议，可以使用 <code>SomeProtocol &amp; AnotherProtocol</code> 协议组合的形式，协议组合不定义任何新的协议类型</p><pre><code>protocol Named &#123;    var name: String &#123; get &#125;&#125;protocol Aged &#123;    var age: Int &#123; get &#125;&#125;struct Person: Named, Aged &#123;    var name: String    var age: Int&#125;func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;   //任何同时遵循 Named 和 Aged 的协议 即可    print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)&#125;let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)wishHappyBirthday(to: birthdayPerson)// 打印 “Happy birthday Malcolm - you&#39;re 21!”</code></pre><p>除了协议列表，协议组合也能包含类类型，这允许你标明一个需要的父类：</p><pre><code>class Location &#123;    var latitude: Double    var longitude: Double    init(latitude: Double, longitude: Double) &#123;        self.latitude = latitude        self.longitude = longitude    &#125;&#125;class City: Location, Named &#123;    var name: String    init(name: String, latitude: Double, longitude: Double) &#123;        self.name = name        super.init(latitude: latitude, longitude: longitude)    &#125;&#125;func beginConcert(in location: Location &amp; Named) &#123;    print(&quot;Hello, \(location.name)!&quot;)&#125;let seattle = City(name: &quot;Seattle&quot;, latitude: 47.6, longitude: -122.3)beginConcert(in: seattle)// 打印 &quot;Hello, Seattle!&quot;</code></pre><h2 id="16-检查协议一致性"><a href="#16-检查协议一致性" class="headerlink" title="16.检查协议一致性"></a>16.检查协议一致性</h2><p>可以使用 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否遵循某协议，并且可以转换到指定的协议类型。检查和转换协议的语法与检查和转换类型是完全一样的：</p><ul><li><code>is</code> 用来检查实例是否遵循某个协议，若遵循则返回 <code>true</code>，否则返回 <code>false</code>；</li><li><code>as?</code> 返回一个可选值，当实例遵循某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>；</li><li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，将触发运行时错误。</li></ul><pre><code>protocol HasArea &#123;    var area: Double &#123; get &#125;&#125;class Circle: HasArea &#123;    let pi = 3.1415927    var radius: Double    var area: Double &#123; return pi * radius * radius &#125;    init(radius: Double) &#123; self.radius = radius &#125;&#125;class Country: HasArea &#123;    var area: Double    init(area: Double) &#123; self.area = area &#125;&#125;class Animal &#123;    var legs: Int    init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [    Circle(radius: 2.0),    Country(area: 243_610),    Animal(legs: 4)]for object in objects &#123;    if let objectWithArea = object as? HasArea &#123;        print(&quot;Area is \(objectWithArea.area)&quot;)    &#125; else &#123;        print(&quot;Something that doesn&#39;t have an area&quot;)    &#125;&#125;// Area is 12.5663708// Area is 243610.0// Something that doesn&#39;t have an area</code></pre><h2 id="17-可选的协议要求"><a href="#17-可选的协议要求" class="headerlink" title="17.可选的协议要求"></a>17.可选的协议要求</h2><p>协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上 <code>@objc</code> 属性。标记 <code>@objc</code> 特性的协议只能被继承自 Objective-C 类的类或者 <code>@objc</code> 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p><p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p><p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求</p><pre><code>@objc protocol CounterDataSource &#123;    @objc optional func increment(forCount count: Int) -&gt; Int    @objc optional var fixedIncrement: Int &#123; get &#125;&#125;class Counter &#123;    var count = 0    var dataSource: CounterDataSource?    func increment() &#123;        if let amount = dataSource?.increment?(forCount: count) &#123;            count += amount        &#125; else if let amount = dataSource?.fixedIncrement &#123;            count += amount        &#125;    &#125;&#125;</code></pre><ul><li>遵循协议，实现可选属性：</li></ul><pre><code>class ThreeSource: NSObject, CounterDataSource &#123;    let fixedIncrement = 3&#125;var counter = Counter()counter.dataSource = ThreeSource()for _ in 1...4 &#123;    counter.increment()    print(counter.count)&#125;// 3// 6// 9// 12</code></pre><ul><li>遵循协议，实现可选方法:</li></ul><pre><code>class TowardsZeroSource: NSObject, CounterDataSource &#123;    func increment(forCount count: Int) -&gt; Int &#123;        if count == 0 &#123;            return 0        &#125; else if count &lt; 0 &#123;            return 1        &#125; else &#123;            return -1        &#125;    &#125;&#125;counter.count = -4counter.dataSource = TowardsZeroSource()for _ in 1...5 &#123;    counter.increment()    print(counter.count)&#125;// -3// -2// -1// 0// 0</code></pre><h2 id="18-协议扩展"><a href="#18-协议扩展" class="headerlink" title="18.协议扩展"></a>18.协议扩展</h2><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p><pre><code>extension RandomNumberGenerator &#123;    func randomBool() -&gt; Bool &#123;        return random() &gt; 0.5    &#125;&#125;</code></pre><p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现而无需任何额外修改：</p><pre><code>let generator = LinearCongruentialGenerator()print(&quot;Here&#39;s a random number: \(generator.random())&quot;)// 打印 “Here&#39;s a random number: 0.37464991998171”print(&quot;And here&#39;s a random Boolean: \(generator.randomBool())&quot;)// 打印 “And here&#39;s a random Boolean: true”</code></pre><p>协议扩展可以为遵循协议的类型增加实现，但不能声明该协议继承自另一个协议。协议的继承只能在协议声明处进行指定。</p><h3 id="18-1-提供默认实现"><a href="#18-1-提供默认实现" class="headerlink" title="18.1 提供默认实现"></a>18.1 提供默认实现</h3><p>可以通过协议扩展来为协议要求的方法、计算属性提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p><blockquote><p>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p></blockquote><pre><code>extension PrettyTextRepresentable  &#123;    var prettyTextualDescription: String &#123;        return textualDescription    &#125;&#125;</code></pre><h3 id="18-2-为协议扩展添加限制条件"><a href="#18-2-为协议扩展添加限制条件" class="headerlink" title="18.2 为协议扩展添加限制条件"></a>18.2 为协议扩展添加限制条件</h3><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述:</p><pre><code>// 扩展 Collection 协议，适用于集合中的元素遵循了 Equatable 协议的情况。// 通过限制集合元素遵循 Equatable 协议， 作为标准库的一部分， 你可以使用 == 和 != 操作符来检查两个元素的等价性和非等价性extension Collection where Element: Equatable &#123;    func allEqual() -&gt; Bool &#123;        for element in self &#123;            if element != self.first &#123;                return false            &#125;        &#125;        return true    &#125;&#125;let equalNumbers = [100, 100, 100, 100, 100]let differentNumbers = [100, 100, 200, 100, 200]print(equalNumbers.allEqual())// 打印 &quot;true&quot;print(differentNumbers.allEqual())// 打印 &quot;false&quot;</code></pre><blockquote><p>如果一个遵循的类型满足了为同一方法或属性提供实现的多个限制型扩展的要求， Swift 会使用最匹配限制的实现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 扩展</title>
      <link href="posts/269908211.html"/>
      <url>posts/269908211.html</url>
      
        <content type="html"><![CDATA[<p>扩展可以给一个现有的类，结构体，枚举，还有协议添加新的功能。它还拥有不需要访问被扩展类型源代码就能完成扩展的能力（即逆向建模）。扩展和 Objective-C 的分类很相似。</p><p>Swift 中的扩展可以：</p><ul><li>添加计算型实例属性和计算型类属性</li><li>定义实例方法和类方法</li><li>提供新的构造器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使已经存在的类型遵循（conform）一个协议</li></ul><p>在 Swift 中，还可以扩展协议以提供其需要的实现，或添加额外功能给遵循的类型所使用。</p><blockquote><p>注意：扩展可以给一个类型添加新的功能，但是不能重写已经存在的功能。</p></blockquote><h2 id="1-扩展的语法"><a href="#1-扩展的语法" class="headerlink" title="1.扩展的语法"></a>1.扩展的语法</h2><p>使用 <code>extension</code> 关键字声明扩展：</p><pre><code>extension SomeType &#123;  // 在这里给 SomeType 添加新的功能&#125;</code></pre><p>扩展可以扩充一个现有的类型，给它添加一个或多个协议。协议名称的写法和类或者结构体一样：</p><pre><code>extension SomeType: SomeProtocol, AnotherProtocol &#123;  // 协议所需要的实现写在这里&#125;</code></pre><blockquote><p>注意：对一个现有的类型，如果你定义了一个扩展来添加新的功能，那么这个类型的所有实例都可以使用这个新功能，包括那些在扩展定义之前就存在的实例。</p></blockquote><h2 id="2-计算型属性"><a href="#2-计算型属性" class="headerlink" title="2.计算型属性"></a>2.计算型属性</h2><p>扩展可以给现有类型添加计算型实例属性和计算型类属性。下面这个例子给 Swift 内建的 <code>Double</code> 类型添加了五个计算型实例属性：</p><pre><code>extension Double &#123;    var km: Double &#123; return self * 1_000.0 &#125;    var m: Double &#123; return self &#125;    var cm: Double &#123; return self / 100.0 &#125;    var mm: Double &#123; return self / 1_000.0 &#125;    var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mmprint(&quot;One inch is \(oneInch) meters&quot;)// 打印“One inch is 0.0254 meters”let threeFeet = 3.ftprint(&quot;Three feet is \(threeFeet) meters&quot;)// 打印“Three feet is 0.914399970739201 meters”</code></pre><p>这些属性都是只读的计算型属性，所以为了简便，它们的表达式里面都不包含 <code>get</code> 关键字。它们使用 <code>Double</code> 作为返回值类型，并可用于所有接受 <code>Double</code> 类型的数学计算中：</p><pre><code>let aMarathon = 42.km + 195.mprint(&quot;A marathon is \(aMarathon) meters long&quot;)// 打印“A marathon is 42195.0 meters long”</code></pre><blockquote><p>注意：扩展可以添加新的计算属性，但是它们不能添加存储属性，或向现有的属性添加属性观察者。</p></blockquote><h2 id="3-构造器"><a href="#3-构造器" class="headerlink" title="3.构造器"></a>3.构造器</h2><p><strong>扩展可以给现有的类型添加新的构造器</strong>。它可以把自定义类型作为参数来供其他类型的构造器使用，或者在类型的原始实现上添加额外的构造选项。</p><p><strong>扩展可以给一个类添加新的便利构造器，但是它们不能给类添加新的指定构造器或者析构器。指定构造器和析构器必须始终由类的原始实现提供</strong>。</p><p>如果使用扩展给一个值类型添加构造器只是用于给所有的存储属性提供默认值，并且没有定义任何自定义构造器，那么可以在该值类型扩展的构造器中使用默认构造器和成员构造器。如果把构造器写到了值类型的原始实现中，那么就不属于在扩展中添加构造器。</p><p>如果使用扩展给另一个模块中定义的结构体添加构造器，那么新的构造器直到定义模块中使用一个构造器之前，不能访问 <code>self</code>。</p><pre><code>struct Size &#123;    var width = 0.0, height = 0.0&#125;struct Point &#123;    var x = 0.0, y = 0.0&#125;struct Rect &#123;    var origin = Point()    var size = Size()&#125;let defaultRect = Rect()let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),   size: Size(width: 5.0, height: 5.0))</code></pre><pre><code>extension Rect &#123;    init(center: Point, size: Size) &#123;        let originX = center.x - (size.width / 2)        let originY = center.y - (size.height / 2)        self.init(origin: Point(x: originX, y: originY), size: size)    &#125;&#125;let centerRect = Rect(center: Point(x: 4.0, y: 4.0),                      size: Size(width: 3.0, height: 3.0))// centerRect 的 origin 是 (2.5, 2.5) 并且它的 size 是 (3.0, 3.0)</code></pre><blockquote><p>注意：如果通过扩展提供一个新的构造器，那么必须确保每个通过该构造器创建的实例都是初始化完整的。</p></blockquote><h2 id="4-方法"><a href="#4-方法" class="headerlink" title="4.方法"></a>4.方法</h2><p>扩展可以给现有类型添加新的实例方法和类方法。在下面的例子中，给 <code>Int</code> 类型添加了一个新的实例方法叫做 <code>repetitions</code>：</p><pre><code>extension Int &#123;    func repetitions(task: () -&gt; Void) &#123;        for _ in 0..&lt;self &#123;            task()        &#125;    &#125;&#125;3.repetitions &#123;    print(&quot;Hello!&quot;)&#125;// Hello!// Hello!// Hello!</code></pre><h3 id="4-1-可变实例方法"><a href="#4-1-可变实例方法" class="headerlink" title="4.1 可变实例方法"></a>4.1 可变实例方法</h3><p>通过扩展添加的实例方法同样也可以修改（或 <code>mutating</code>）实例本身。结构体和枚举的方法，若是可以修改 <code>self</code> 或者它自己的属性，则必须将这个实例方法标记为 <code>mutating</code>，就像是改变了方法的原始实现。</p><pre><code>extension Int &#123;    mutating func square() &#123;        self = self * self    &#125;&#125;var someInt = 3someInt.square()// someInt 现在是 9</code></pre><h2 id="5-下标"><a href="#5-下标" class="headerlink" title="5.下标"></a>5.下标</h2><p>扩展可以给现有的类型添加新的下标。下面的例子中，对 Swift 的 <code>Int</code> 类型添加了一个整数类型的下标。下标 <code>[n]</code> 从数字右侧开始，返回小数点后的第 <code>n</code> 位：</p><ul><li><code>123456789[0]</code> 返回 <code>9</code></li><li><code>123456789[1]</code> 返回 <code>8</code></li></ul><p>……以此类推：</p><pre><code>extension Int &#123;    subscript(digitIndex: Int) -&gt; Int &#123;        var decimalBase = 1        for _ in 0..&lt;digitIndex &#123;            decimalBase *= 10        &#125;        return (self / decimalBase) % 10    &#125;&#125;746381295[0]// 返回 5746381295[1]// 返回 9746381295[2]// 返回 2746381295[8]// 返回 7</code></pre><p>如果操作的 <code>Int</code> 值没有足够的位数满足所请求的下标，那么下标的现实将返回 <code>0</code>，将好像在数字的左边补上了 <code>0</code>：</p><pre><code>746381295[9]// 返回 0，就好像你进行了这个请求：0746381295[9]</code></pre><h2 id="6-嵌套类型"><a href="#6-嵌套类型" class="headerlink" title="6.嵌套类型"></a>6.嵌套类型</h2><p>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型：</p><pre><code>extension Int &#123;    enum Kind &#123;        case negative, zero, positive    &#125;    var kind: Kind &#123;        switch self &#123;        case 0:            return .zero        case let x where x &gt; 0:            return .positive        default:            return .negative        &#125;    &#125;&#125;func printIntegerKinds(_ numbers: [Int]) &#123;    for number in numbers &#123;        switch number.kind &#123;        case .negative:            print(&quot;- &quot;, terminator: &quot;&quot;)        case .zero:            print(&quot;0 &quot;, terminator: &quot;&quot;)        case .positive:            print(&quot;+ &quot;, terminator: &quot;&quot;)        &#125;    &#125;    print(&quot;&quot;)&#125;printIntegerKinds([3, 19, -27, 0, -6, 0, 7])// 打印“+ + - 0 - 0 + ”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 嵌套类型</title>
      <link href="posts/3352431388.html"/>
      <url>posts/3352431388.html</url>
      
        <content type="html"><![CDATA[<p>枚举常被用于为特定类或结构体实现某些功能。类似地，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许定义<code>嵌套类型</code>，可以在支持的类型中定义嵌套的枚举、类和结构体。</p><p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的 <code>&#123;&#125;</code> 内，而且可以根据需要定义多级嵌套。</p><h2 id="1-嵌套类型实践"><a href="#1-嵌套类型实践" class="headerlink" title="1.嵌套类型实践"></a>1.嵌套类型实践</h2><pre><code>struct BlackjackCard &#123;    // 嵌套的 Suit 枚举    enum Suit: Character &#123;        case spades = &quot;♠&quot;, hearts = &quot;♡&quot;, diamonds = &quot;♢&quot;, clubs = &quot;♣&quot;    &#125;    // 嵌套的 Rank 枚举    enum Rank: Int &#123;        case two = 2, three, four, five, six, seven, eight, nine, ten        case jack, queen, king, ace        struct Values &#123;            let first: Int, second: Int?        &#125;        var values: Values &#123;            switch self &#123;            case .ace:                return Values(first: 1, second: 11)            case .jack, .queen, .king:                return Values(first: 10, second: nil)            default:                return Values(first: self.rawValue, second: nil)            &#125;        &#125;    &#125;    // BlackjackCard 的属性和方法    let rank: Rank, suit: Suit    var description: String &#123;        var output = &quot;suit is \(suit.rawValue),&quot;        output += &quot; value is \(rank.values.first)&quot;        if let second = rank.values.second &#123;            output += &quot; or \(second)&quot;        &#125;        return output    &#125;&#125;</code></pre><p>虽然 <code>BlackjackCard</code> 没有自定义构造器，但结构体有默认的成员构造器，所以可以用默认的构造器去初始化新常量 <code>theAceOfSpades</code>：</p><pre><code>let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)// 打印“theAceOfSpades: suit is ♠, value is 1 or 11”</code></pre><h2 id="2-引用嵌套类型"><a href="#2-引用嵌套类型" class="headerlink" title="2.引用嵌套类型"></a>2.引用嵌套类型</h2><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p><pre><code>let heartsSymbol = BlackjackCard.Suit.hearts.rawValue// 红心符号为“♡”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 类型转换</title>
      <link href="posts/2981466500.html"/>
      <url>posts/2981466500.html</url>
      
        <content type="html"><![CDATA[<p>类型转换可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。</p><p>类型转换在 Swift 中使用 <code>is</code> 和 <code>as</code> 操作符实现。这两个操作符分别提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p><p>也可以用它来检查一个类型是否遵循了某个协议</p><h2 id="1-为类型转换定义类层次"><a href="#1-为类型转换定义类层次" class="headerlink" title="1.为类型转换定义类层次"></a>1.为类型转换定义类层次</h2><p>可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。</p><p>下面三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子：</p><pre><code>class MediaItem &#123;    var name: String    init(name: String) &#123;        self.name = name    &#125;&#125;</code></pre><pre><code>class Movie: MediaItem &#123;    var director: String    init(name: String, director: String) &#123;        self.director = director        super.init(name: name)    &#125;&#125;class Song: MediaItem &#123;    var artist: String    init(name: String, artist: String) &#123;        self.artist = artist        super.init(name: name)    &#125;&#125;</code></pre><pre><code>let library = [    Movie(name: &quot;Casablanca&quot;, director: &quot;Michael Curtiz&quot;),    Song(name: &quot;Blue Suede Shoes&quot;, artist: &quot;Elvis Presley&quot;),    Movie(name: &quot;Citizen Kane&quot;, director: &quot;Orson Welles&quot;),    Song(name: &quot;The One And Only&quot;, artist: &quot;Chesney Hawkes&quot;),    Song(name: &quot;Never Gonna Give You Up&quot;, artist: &quot;Rick Astley&quot;)]// 数组 library 的类型被推断为 [MediaItem]</code></pre><p><code>library</code> 里存储的是 <code>Movie</code> 和 <code>Song</code> 类型的。<code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code>，所以推断出 <code>[MediaItem]</code> 类作为 <code>library</code> 的类型。若迭代它，依次取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型。</p><h2 id="2-检查类型"><a href="#2-检查类型" class="headerlink" title="2.检查类型"></a>2.检查类型</h2><p>用类型检查操作符（<code>is</code>）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code>，否则返回 <code>false</code>:</p><pre><code>var movieCount = 0var songCount = 0for item in library &#123;    if item is Movie &#123;        movieCount += 1    &#125; else if item is Song &#123;        songCount += 1    &#125;&#125;print(&quot;Media library contains \(movieCount) movies and \(songCount) songs&quot;)// 打印“Media library contains 2 movies and 3 songs”</code></pre><h2 id="3-向下转型"><a href="#3-向下转型" class="headerlink" title="3.向下转型"></a>3.向下转型</h2><p>某类型的一个常量或变量可能属于一个子类。当确定是这种情况时，可以向下转型到它的子类型。因为向下转型可能会失败，类型转型操作符带有两种不同形式：</p><ul><li><code>as?</code>：不确定向下转型可以成功时，使用此类型</li><li><code>as!</code>：可以确定向下转型一定会成功时，使用此类型</li></ul><pre><code>for item in library &#123;    if let movie = item as? Movie &#123;        print(&quot;Movie: \(movie.name), dir. \(movie.director)&quot;)    &#125; else if let song = item as? Song &#123;        print(&quot;Song: \(song.name), by \(song.artist)&quot;)    &#125;&#125;// Movie: Casablanca, dir. Michael Curtiz// Song: Blue Suede Shoes, by Elvis Presley// Movie: Citizen Kane, dir. Orson Welles// Song: The One And Only, by Chesney Hawkes// Song: Never Gonna Give You Up, by Rick Astley</code></pre><blockquote><p>注意：转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p></blockquote><h2 id="4-Any-和-AnyObject-的类型转换"><a href="#4-Any-和-AnyObject-的类型转换" class="headerlink" title="4.Any 和 AnyObject 的类型转换"></a>4.Any 和 AnyObject 的类型转换</h2><p>Swift 为不确定类型提供了两种特殊的类型别名：</p><ul><li><code>Any</code> 可以表示任何类型，包括函数类型。</li><li><code>AnyObject</code> 可以表示任何类类型的实例。</li></ul><p>只有当你确实需要它们的行为和功能时才使用 <code>Any</code> 和 <code>AnyObject</code>。最好还是在代码中指明需要使用的类型</p><pre><code>var things = [Any]()things.append(0)things.append(0.0)things.append(42)things.append(3.14159)things.append(&quot;hello&quot;)things.append((3.0, 5.0))things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;))things.append(&#123; (name: String) -&gt; String in &quot;Hello, \(name)&quot; &#125;)</code></pre><p>可以在 <code>switch</code> 表达式的 <code>case</code> 中使用 <code>is</code> 和 <code>as</code> 操作符来找出只知道是 <code>Any</code> 或 <code>AnyObject</code> 类型的常量或变量的具体类型。</p><pre><code>for thing in things &#123;    switch thing &#123;    case 0 as Int:        print(&quot;zero as an Int&quot;)    case 0 as Double:        print(&quot;zero as a Double&quot;)    case let someInt as Int:        print(&quot;an integer value of \(someInt)&quot;)    case let someDouble as Double where someDouble &gt; 0:        print(&quot;a positive double value of \(someDouble)&quot;)    case is Double:        print(&quot;some other double value that I don&#39;t want to print&quot;)    case let someString as String:        print(&quot;a string value of \&quot;\(someString)\&quot;&quot;)    case let (x, y) as (Double, Double):        print(&quot;an (x, y) point at \(x), \(y)&quot;)    case let movie as Movie:        print(&quot;a movie called \(movie.name), dir. \(movie.director)&quot;)    case let stringConverter as (String) -&gt; String:        print(stringConverter(&quot;Michael&quot;))    default:        print(&quot;something else&quot;)    &#125;&#125;// zero as an Int// zero as a Double// an integer value of 42// a positive double value of 3.14159// a string value of &quot;hello&quot;// an (x, y) point at 3.0, 5.0// a movie called Ghostbusters, dir. Ivan Reitman// Hello, Michael</code></pre><blockquote><p>注意：<code>Any</code> 类型可以表示所有类型的值，包括可选类型。Swift 会在你用 <code>Any</code> 类型来表示一个可选值的时候，给一个警告。如果确实想使用 <code>Any</code> 类型来承载可选值，可以使用 <code>as</code> 操作符显式转换为 <code>Any</code>。</p></blockquote><pre><code>let optionalNumber: Int? = 3things.append(optionalNumber)        // 警告things.append(optionalNumber as Any) // 没有警告</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 错误处理</title>
      <link href="posts/293116127.html"/>
      <url>posts/293116127.html</url>
      
        <content type="html"><![CDATA[<p><code>错误处理</code>（Error handling） 是响应错误以及从错误中恢复的过程。Swift 在运行时提供了<code>抛出</code>、<code>捕获</code>、<code>传递</code>和<code>操作</code>可恢复错误（recoverable errors）的一等支持。</p><h2 id="1-表示与抛出错误"><a href="#1-表示与抛出错误" class="headerlink" title="1.表示与抛出错误"></a>1.表示与抛出错误</h2><p>在 Swift 中，错误用遵循 <code>Error</code> 协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。</p><p><strong>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息</strong>。例如，在游戏中操作自动贩卖机时，你可以这样表示可能会出现的错误状态：</p><pre><code>enum VendingMachineError: Error &#123;    case invalidSelection                     //选择无效    case insufficientFunds(coinsNeeded: Int) //金额不足    case outOfStock                             //缺货&#125;</code></pre><p>抛出错误使用 <code>throw</code> 语句：</p><pre><code>throw VendingMachineError.insufficientFunds(coinsNeeded: 5)</code></pre><h2 id="2-处理错误"><a href="#2-处理错误" class="headerlink" title="2.处理错误"></a>2.处理错误</h2><p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。Swift 中有 <code>4</code> 种处理错误的方式：</p><h3 id="2-1-用-throwing-函数传递错误"><a href="#2-1-用-throwing-函数传递错误" class="headerlink" title="2.1 用 throwing 函数传递错误"></a>2.1 用 throwing 函数传递错误</h3><p>在函数声明的参数之后加上 <code>throws</code> 关键字，表示一个函数、方法或构造器可以抛出错误。一个标有 <code>throws</code> 关键字的函数被称作 <code>throwing 函数</code>。如果这个函数指明了返回值类型，<code>throws</code> 关键词需要写在返回箭头（<code>-&gt;</code>）的前面。</p><pre><code>func canThrowErrors() throws -&gt; Stringfunc cannotThrowErrors() -&gt; String</code></pre><p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p><blockquote><p>只有 <code>throwing</code> 函数可以传递错误。任何在某个非 <code>throwing</code> 函数内部抛出的错误只能在函数内部处理。</p></blockquote><pre><code>struct Item &#123;    var price: Int    var count: Int&#125;class VendingMachine &#123;    var inventory = [        &quot;Candy Bar&quot;: Item(price: 12, count: 7),        &quot;Chips&quot;: Item(price: 10, count: 4),        &quot;Pretzels&quot;: Item(price: 7, count: 11)    ]    var coinsDeposited = 0    func vend(itemNamed name: String) throws &#123;        guard let item = inventory[name] else &#123;            throw VendingMachineError.invalidSelection        &#125;        guard item.count &gt; 0 else &#123;            throw VendingMachineError.outOfStock        &#125;        guard item.price &lt;= coinsDeposited else &#123;            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)        &#125;        coinsDeposited -= item.price        var newItem = item        newItem.count -= 1        inventory[name] = newItem        print(&quot;Dispensing \(name)&quot;)    &#125;&#125;</code></pre><p>因为 <code>vend(itemNamed:)</code> 方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用 <code>do-catch</code> 语句，<code>try?</code> 或 <code>try!</code>；要么继续将这些错误传递下去。</p><pre><code>let favoriteSnacks = [    &quot;Alice&quot;: &quot;Chips&quot;,    &quot;Bob&quot;: &quot;Licorice&quot;,    &quot;Eve&quot;: &quot;Pretzels&quot;,]func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123;    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;    try vendingMachine.vend(itemNamed: snackName)&#125;</code></pre><p><code>throwing</code> 构造器能像 <code>throwing</code> 函数一样传递错误。例如下面代码中的 <code>PurchasedSnack</code> 构造器在构造过程中调用了 <code>throwing</code> 函数，并且通过传递到它的调用者来处理这些错误。</p><pre><code>struct PurchasedSnack &#123;    let name: String    init(name: String, vendingMachine: VendingMachine) throws &#123;        try vendingMachine.vend(itemNamed: name)        self.name = name    &#125;&#125;</code></pre><h3 id="2-2-用-Do-Catch-处理错误"><a href="#2-2-用-Do-Catch-处理错误" class="headerlink" title="2.2 用 Do-Catch 处理错误"></a>2.2 用 Do-Catch 处理错误</h3><p>你可以使用一个 <code>do-catch</code> 语句运行一段闭包代码来处理错误。如果在 <code>do</code> 子句中的代码抛出了一个错误，这个错误会与 <code>catch</code> 子句做匹配，从而决定哪条子句能处理它。</p><p><code>do-catch</code> 语句的一般形式：</p><pre><code>do &#123;    try expression    statements&#125; catch pattern 1 &#123;    statements&#125; catch pattern 2 where condition &#123;    statements&#125; catch &#123;    statements&#125;</code></pre><p>在 <code>catch</code> 后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条 <code>catch</code> 子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为 <code>error</code> 的局部常量。</p><pre><code>var vendingMachine = VendingMachine()vendingMachine.coinsDeposited = 8do &#123;    try buyFavoriteSnack(person: &quot;Alice&quot;, vendingMachine: vendingMachine)    print(&quot;Success! Yum.&quot;)&#125; catch VendingMachineError.invalidSelection &#123;    print(&quot;Invalid Selection.&quot;)&#125; catch VendingMachineError.outOfStock &#123;    print(&quot;Out of Stock.&quot;)&#125; catch VendingMachineError.insufficientFunds(let coinsNeeded) &#123;    print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)&#125; catch &#123;    print(&quot;Unexpected error: \(error).&quot;)&#125;// 打印“Insufficient funds. Please insert an additional 2 coins.”</code></pre><p><code>catch</code> 子句不必将 <code>do</code> 子句中的代码所抛出的每一个可能的错误都作处理。如果所有 <code>catch</code> 子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的。在不会抛出错误的函数中，必须用 <code>do-catch</code> 语句处理错误。而能够抛出错误的函数既可以使用 <code>do-catch</code> 语句处理，也可以让调用方来处理错误。如果错误传递到了顶层作用域却依然没有被处理，你会得到一个运行时错误。</p><pre><code>func nourish(with item: String) throws &#123;    do &#123;        try vendingMachine.vend(itemNamed: item)    &#125; catch is VendingMachineError &#123;        print(&quot;Invalid selection, out of stock, or not enough money.&quot;)    &#125;&#125;do &#123;    try nourish(with: &quot;Beet-Flavored Chips&quot;)&#125; catch &#123;    print(&quot;Unexpected non-vending-machine-related error: \(error)&quot;)&#125;// 打印“Invalid selection, out of stock, or not enough money.”</code></pre><p>另一种捕获多个相关错误的方式是将它们放在 <code>catch</code> 后，通过逗号分隔:</p><pre><code>func eat(item: String) throws &#123;    do &#123;        try vendingMachine.vend(itemNamed: item)    &#125; catch VendingMachineError.invalidSelection, VendingMachineError.insufficientFunds, VendingMachineError.outOfStock &#123;        print(&quot;Invalid selection, out of stock, or not enough money.&quot;)    &#125;&#125;</code></pre><h3 id="2-3-将错误转换成可选值"><a href="#2-3-将错误转换成可选值" class="headerlink" title="2.3 将错误转换成可选值"></a>2.3 将错误转换成可选值</h3><p>可以使用 <code>try?</code> 通过将错误转换成一个可选值来处理错误。如果是在计算 <code>try?</code> 表达式时抛出错误，该表达式的结果就为 <code>nil</code>。</p><pre><code>func someThrowingFunction() throws -&gt; Int &#123;    // ...&#125;let x = try? someThrowingFunction()let y: Int?do &#123;    y = try someThrowingFunction()&#125; catch &#123;    y = nil&#125;</code></pre><p>如果你想对所有的错误都采用同样的方式来处理，用 <code>try?</code> 就可以让你写出简洁的错误处理代码：</p><pre><code>func fetchData() -&gt; Data? &#123;    if let data = try? fetchDataFromDisk() &#123; return data &#125;    if let data = try? fetchDataFromServer() &#123; return data &#125;    return nil&#125;</code></pre><h3 id="2-4-禁用错误传递"><a href="#2-4-禁用错误传递" class="headerlink" title="2.4 禁用错误传递"></a>2.4 禁用错误传递</h3><p>有时某个 <code>throwing</code> 函数实际上在运行时是不会抛出错误的，在这种情况下，可以在表达式前面写 <code>try!</code> 来禁用错误传递，这会把调用包装在一个不会有错误抛出的运行时断言中。如果真的抛出了错误，会得到一个运行时错误。</p><pre><code>let photo = try! loadImage(atPath: &quot;./Resources/John Appleseed.jpg&quot;)</code></pre><h2 id="3-指定清理操作"><a href="#3-指定清理操作" class="headerlink" title="3.指定清理操作"></a>3.指定清理操作</h2><p>可以使用 <code>defer</code> 语句在即将离开当前代码块时执行一系列语句。该语句能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，或是由于诸如 <code>return</code>、<code>break</code> 的语句。例如，可以用 <code>defer</code> 语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p><p><code>defer</code> 语句将代码的执行延迟到当前的作用域退出之前。该语句由 <code>defer</code> 关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如 <code>break</code>、<code>return</code> 语句，或是抛出一个错误。延迟执行的操作会按照它们声明的顺序从后往前执行——也就是说，第一条 <code>defer</code> 语句中的代码最后才执行，第二条 <code>defer</code> 语句中的代码倒数第二个执行，以此类推。最后一条语句会第一个执行。</p><pre><code>func processFile(filename: String) throws &#123;    if exists(filename) &#123;        let file = open(filename)        defer &#123;            close(file)        &#125;        while let line = try file.readline() &#123;            // 处理文件。        &#125;        // close(file) 会在这里被调用，即作用域的最后。    &#125;&#125;</code></pre><blockquote><p>注意：即使没有涉及到错误处理的代码，你也可以使用 <code>defer</code> 语句</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 可选链</title>
      <link href="posts/3859367755.html"/>
      <url>posts/3859367755.html</url>
      
        <content type="html"><![CDATA[<p><strong>可选链式调用</strong>是一种可以在当前值可能为 <code>nil</code> 的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用成功；如果可选值是 <code>nil</code> ，那么调用将返回 <code>nil</code> 。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为 <code>nil</code> ，整个调用链都会失败，即返回 <code>nil</code> 。</p><blockquote><p>注意：Swift 的可选链式调用和 Objective-C 中向 <code>nil</code> 发送消息有些相像，但是 Swift 的可选链式调用可以用于任意类型，并且能检查调用是否成功。</p></blockquote><h2 id="1-使用可选链式调用代替强制解包"><a href="#1-使用可选链式调用代替强制解包" class="headerlink" title="1.使用可选链式调用代替强制解包"></a>1.使用可选链式调用代替强制解包</h2><p>通过在想调用的属性、方法，或下标的可选值后面放一个问号（<code>?</code>），可以定义一个可选链。这一点很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p><p><strong>可选链式调用返回结果是一个可选值，与原本的返回结果具有相同的类型</strong>，可以根据返回值判断可选链式调用是否成功，如果调用有返回值则说明调用成功，返回 <code>nil</code> 则说明调用失败。</p><p>可选链式调用和强制展开的不同：</p><pre><code>class Person &#123;    var residence: Residence?&#125;class Residence &#123;    var numberOfRooms = 1&#125;let john = Person()</code></pre><p><code>john</code> 实例的 <code>residence</code> 属性由于是可选类型而被初始化为 <code>nil</code>，如果使用强制解析获得这个属性的 <code>numberOfRooms</code> 值，则会触发运行时错误：</p><pre><code>let roomCount = john.residence!.numberOfRooms// 这会引发运行时错误</code></pre><p>可选链式调用则是使用（<code>?</code>）来替代原来的（<code>!</code>），就会在 <code>residence</code> 不为 <code>nil</code> 的情况下访问 <code>numberOfRooms</code>：</p><pre><code>if let roomCount = john.residence?.numberOfRooms &#123;    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the number of rooms.&quot;)&#125;// 打印“Unable to retrieve the number of rooms.”</code></pre><p>将一个 <code>Residence</code> 的实例赋给 <code>john.residence</code>，可选链式调用访问也成立：</p><pre><code>john.residence = Residence()if let roomCount = john.residence?.numberOfRooms &#123;    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the number of rooms.&quot;)&#125;// 打印“John&#39;s residence has 1 room(s).”</code></pre><h2 id="2-为可选链式调用定义模型类"><a href="#2-为可选链式调用定义模型类" class="headerlink" title="2.为可选链式调用定义模型类"></a>2.为可选链式调用定义模型类</h2><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法和下标。</p><p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用：</p><pre><code>class Person &#123;    var residence: Residence?&#125;class Residence &#123;    var rooms = [Room]()    var numberOfRooms: Int &#123;        return rooms.count    &#125;    subscript(i: Int) -&gt; Room &#123;        get &#123;            return rooms[i]        &#125;        set &#123;            rooms[i] = newValue        &#125;    &#125;    func printNumberOfRooms() &#123;        print(&quot;The number of rooms is \(numberOfRooms)&quot;)    &#125;    var address: Address?&#125;class Room &#123;    let name: String    init(name: String) &#123; self.name = name &#125;&#125;class Address &#123;    var buildingName: String?    var buildingNumber: String?    var street: String?    func buildingIdentifier() -&gt; String? &#123;        if buildingName != nil &#123;            return buildingName        &#125; else if let buildingNumber = buildingNumber, let street = street &#123;            return &quot;\(buildingNumber) \(street)&quot;        &#125; else &#123;            return nil        &#125;    &#125;&#125;</code></pre><h2 id="3-通过可选链式调用访问属性"><a href="#3-通过可选链式调用访问属性" class="headerlink" title="3.通过可选链式调用访问属性"></a>3.通过可选链式调用访问属性</h2><ul><li>可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功：</li></ul><pre><code>let john = Person()if let roomCount = john.residence?.numberOfRooms &#123;    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the number of rooms.&quot;)&#125;// 打印“Unable to retrieve the number of rooms.”</code></pre><ul><li>可以通过可选链式调用来设置属性值：</li></ul><pre><code>let someAddress = Address()someAddress.buildingNumber = &quot;29&quot;someAddress.street = &quot;Acacia Road&quot;john.residence?.address = someAddress//john.residence 当前为 nil，所以通过 john.residence 来设定 address 属性会失败</code></pre><ul><li>赋值过程中，可选链式调用失败，等号右侧代码不会被执行，验证过程如下：</li></ul><pre><code>func createAddress() -&gt; Address &#123;    print(&quot;Function was called.&quot;)    let someAddress = Address()    someAddress.buildingNumber = &quot;29&quot;    someAddress.street = &quot;Acacia Road&quot;    return someAddress&#125;john.residence?.address = createAddress()</code></pre><p>没有任何打印消息，可以看出 <code>createAddress()</code> 函数并未被执行。</p><h2 id="4-通过可选链式调用来调用方法"><a href="#4-通过可选链式调用来调用方法" class="headerlink" title="4.通过可选链式调用来调用方法"></a>4.通过可选链式调用来调用方法</h2><p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。</p><pre><code>if john.residence?.printNumberOfRooms() != nil &#123;    print(&quot;It was possible to print the number of rooms.&quot;)&#125; else &#123;    print(&quot;It was not possible to print the number of rooms.&quot;)&#125;// 打印“It was not possible to print the number of rooms.”</code></pre><blockquote><p><code>printNumberOfRooms</code>这个方法没有返回值，然而，没有返回值的方法具有隐式的返回类型 <code>Void</code>，这意味着没有返回值的方法也会返回 <code>()</code>，或者说空的元组。所以可以通过判断返回值是否为 nil 可以判断调用是否成功。</p></blockquote><p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功：</p><pre><code>if (john.residence?.address = someAddress) != nil &#123;    print(&quot;It was possible to set the address.&quot;)&#125; else &#123;    print(&quot;It was not possible to set the address.&quot;)&#125;// 打印“It was not possible to set the address.”</code></pre><h2 id="5-通过可选链式调用访问下标"><a href="#5-通过可选链式调用访问下标" class="headerlink" title="5.通过可选链式调用访问下标"></a>5.通过可选链式调用访问下标</h2><p>通过可选链式调用，可以在一个可选值上访问下标，并且判断下标调用是否成功。</p><blockquote><p>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p></blockquote><pre><code>if let firstRoomName = john.residence?[0].name &#123;    print(&quot;The first room name is \(firstRoomName).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the first room name.&quot;)&#125;// 打印“Unable to retrieve the first room name.”</code></pre><p>也可以通过下标，用可选链式调用来赋值：</p><pre><code>john.residence?[0] = Room(name: &quot;Bathroom&quot;)  //失败</code></pre><p>如果创建一个 <code>Residence</code> 实例，并为其 <code>rooms</code> 数组添加一些 <code>Room</code> 实例，然后将 <code>Residence</code> 实例赋值给 <code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素：</p><pre><code>let johnsHouse = Residence()johnsHouse.rooms.append(Room(name: &quot;Living Room&quot;))johnsHouse.rooms.append(Room(name: &quot;Kitchen&quot;))john.residence = johnsHouseif let firstRoomName = john.residence?[0].name &#123;    print(&quot;The first room name is \(firstRoomName).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the first room name.&quot;)&#125;// 打印“The first room name is Living Room.”</code></pre><h3 id="5-1-访问可选类型的下标"><a href="#5-1-访问可选类型的下标" class="headerlink" title="5.1 访问可选类型的下标"></a>5.1 访问可选类型的下标</h3><p>如果下标返回可选类型值，比如 Swift 中 <code>Dictionary</code> 类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p><pre><code>var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]testScores[&quot;Dave&quot;]?[0] = 91testScores[&quot;Bev&quot;]?[0] += 1testScores[&quot;Brian&quot;]?[0] = 72// &quot;Dave&quot; 数组现在是 [91, 82, 84]，&quot;Bev&quot; 数组现在是 [80, 94, 81]// testScores 字典中没有 &quot;Brian&quot; 这个键，所以第三个调用失败</code></pre><h2 id="6-连接多层可选链式调用"><a href="#6-连接多层可选链式调用" class="headerlink" title="6.连接多层可选链式调用"></a>6.连接多层可选链式调用</h2><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。也就是说：</p><ul><li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li><li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li></ul><p>因此：</p><ul><li>通过可选链式调用访问一个 <code>Int</code> 值，将会返回 <code>Int?</code>，无论使用了多少层可选链式调用</li><li>类似的，通过可选链式调用访问 <code>Int?</code> 值，依旧会返回 <code>Int?</code> 值，并不会返回 <code>Int??</code>。</li></ul><pre><code>if let johnsStreet = john.residence?.address?.street &#123;    print(&quot;John&#39;s street name is \(johnsStreet).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the address.&quot;)&#125;// 打印“Unable to retrieve the address.”</code></pre><p><code>john.residence</code> 现在包含一个有效的 <code>Residence</code> 实例。然而，<code>john.residence.address</code> 的值当前为 <code>nil</code>。因此，调用 <code>john.residence?.address?.street</code> 会失败。而且 <code>street</code> 的属性为 <code>String?</code>。<code>john.residence?.address?.street</code> 的返回值也依然是 <code>String?</code>，即使已经使用了两层可选链式调用。</p><p>如果为 <code>john.residence.address</code> 赋值一个 <code>Address</code> 实例，并且为 <code>address</code> 中的 <code>street</code> 属性设置一个有效值，我们就能过通过可选链式调用来访问 <code>street</code> 属性：</p><pre><code>let johnsAddress = Address()johnsAddress.buildingName = &quot;The Larches&quot;johnsAddress.street = &quot;Laurel Street&quot;john.residence?.address = johnsAddressif let johnsStreet = john.residence?.address?.street &#123;    print(&quot;John&#39;s street name is \(johnsStreet).&quot;)&#125; else &#123;    print(&quot;Unable to retrieve the address.&quot;)&#125;// 打印“John&#39;s street name is Laurel Street.”</code></pre><h2 id="7-在方法的可选返回值上进行可选链式调用"><a href="#7-在方法的可选返回值上进行可选链式调用" class="headerlink" title="7.在方法的可选返回值上进行可选链式调用"></a>7.在方法的可选返回值上进行可选链式调用</h2><ul><li>在一个可选值上通过可选链式调用来调用方法：</li></ul><pre><code>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;    print(&quot;John&#39;s building identifier is \(buildingIdentifier).&quot;)&#125;// 打印“John&#39;s building identifier is The Larches.”</code></pre><ul><li>在方法的可选返回值上进行可选链式调用，在方法的圆括号后面加上问号：</li></ul><pre><code>if let beginsWithThe =    john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) &#123;        if beginsWithThe &#123;            print(&quot;John&#39;s building identifier begins with \&quot;The\&quot;.&quot;)        &#125; else &#123;            print(&quot;John&#39;s building identifier does not begin with \&quot;The\&quot;.&quot;)        &#125;&#125;// 打印“John&#39;s building identifier begins with &quot;The&quot;.”</code></pre><blockquote><p>在上面的例子中，在方法的圆括号后面加上问号是因为你要在 <code>buildingIdentifier()</code> 方法的可选返回值上进行可选链式调用，而不是 <code>buildingIdentifier()</code> 方法本身。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 析构过程</title>
      <link href="posts/3783019282.html"/>
      <url>posts/3783019282.html</url>
      
        <content type="html"><![CDATA[<p>析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字 <code>deinit</code> 来标示，类似于构造器要用 <code>init</code> 来标示。</p><h2 id="1-析构过程原理"><a href="#1-析构过程原理" class="headerlink" title="1.析构过程原理"></a>1.析构过程原理</h2><p>在类的定义中，每个类最多只能有一个析构器，析构器语法：</p><pre><code>deinit &#123;    // 执行析构过程&#125;</code></pre><p>析构器是在实例释放发生前被自动调用的。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p><p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p><h2 id="2-析构器实践"><a href="#2-析构器实践" class="headerlink" title="2.析构器实践"></a>2.析构器实践</h2><pre><code>class Bank &#123;    // 跟踪它当前拥有的硬币数量    static var coinsInBank = 10_000    // 硬币的分发    static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int &#123;        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)        coinsInBank -= numberOfCoinsToVend        return numberOfCoinsToVend    &#125;    // 硬币的收集    static func receive(coins: Int) &#123;        coinsInBank += coins    &#125;&#125;// 玩家class Player &#123;    // 玩家拥有的硬币    var coinsInPurse: Int    // 初始拥有硬币    init(coins: Int) &#123;        coinsInPurse = Bank.distribute(coins: coins)    &#125;    // 通过游戏获得之后拥有硬币    func win(coins: Int) &#123;        coinsInPurse += Bank.distribute(coins: coins)    &#125;    // 玩家离开    deinit &#123;        Bank.receive(coins: coinsInPurse)    &#125;&#125;var playerOne: Player? = Player(coins: 100)print(&quot;A new player has joined the game with \(playerOne!.coinsInPurse) coins&quot;)// 打印“A new player has joined the game with 100 coins”print(&quot;There are now \(Bank.coinsInBank) coins left in the bank&quot;)// 打印“There are now 9900 coins left in the bank”playerOne!.win(coins: 2_000)print(&quot;PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins&quot;)// 打印“PlayerOne won 2000 coins &amp; now has 2100 coins”print(&quot;The bank now only has \(Bank.coinsInBank) coins left&quot;)// 打印“The bank now only has 7900 coins left”playerOne = nil // deinit会被自动调用print(&quot;PlayerOne has left the game&quot;)// 打印“PlayerOne has left the game”print(&quot;The bank now has \(Bank.coinsInBank) coins&quot;)// 打印“The bank now has 10000 coins”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 构造过程</title>
      <link href="posts/1111727047.html"/>
      <url>posts/1111727047.html</url>
      
        <content type="html"><![CDATA[<p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例使用前有个过程是必须的，它包括设置实例中每个存储属性的初始值和执行其他必须的设置或构造过程。</p><p>构造过程通过构造器来实现，swift的构造器没有返回值，构造器的主要任务是保证某种类型的新实例在第一次使用前完成正确的初始化。</p><h2 id="1-存储属性的初始赋值"><a href="#1-存储属性的初始赋值" class="headerlink" title="1.存储属性的初始赋值"></a>1.存储属性的初始赋值</h2><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p><blockquote><p>当你为存储型属性分配默认值或者在构造器中设置初始值时，它们的值是被直接设置的，不会触发任何属性观察者。</p></blockquote><h3 id="1-1-构造器"><a href="#1-1-构造器" class="headerlink" title="1.1 构造器"></a>1.1 构造器</h3><p> <code>构造器</code> 关键字 <code>init</code>命名，最简单形式类似一个不带任何形参的实例方法：</p><pre><code>init() &#123;    // 在此处执行构造过程&#125;</code></pre><p>在 <code>构造器</code> 中为存储属性赋初始值：</p><pre><code>struct Fahrenheit &#123;    var temperature: Double    init() &#123;        temperature = 32.0    &#125;&#125;var f = Fahrenheit()print(&quot;The default temperature is \(f.temperature)° Fahrenheit&quot;)// 打印“The default temperature is 32.0° Fahrenheit”</code></pre><h3 id="1-2-默认属性值"><a href="#1-2-默认属性值" class="headerlink" title="1.2 默认属性值"></a>1.2 默认属性值</h3><p>可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值：</p><pre><code>struct Fahrenheit &#123;    var temperature = 32.0&#125;</code></pre><h2 id="2-自定义构造过程"><a href="#2-自定义构造过程" class="headerlink" title="2.自定义构造过程"></a>2.自定义构造过程</h2><h3 id="2-1-形参的构造过程"><a href="#2-1-形参的构造过程" class="headerlink" title="2.1 形参的构造过程"></a>2.1 形参的构造过程</h3><p>自定义构造过程时，可以在定义中提供构造形参，指定其值的类型和名字。构造形参的功能和语法跟函数和方法的形参相同。</p><pre><code>struct Celsius &#123;    var temperatureInCelsius: Double    init(fromFahrenheit fahrenheit: Double) &#123;        temperatureInCelsius = (fahrenheit - 32.0) / 1.8    &#125;    init(fromKelvin kelvin: Double) &#123;        temperatureInCelsius = kelvin - 273.15    &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius 是 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15)// freezingPointOfWater.temperatureInCelsius 是 0.0</code></pre><blockquote><p><code>fromFahrenheit</code> 和 <code>fromKelvin</code> 为实参标签，<code>fahrenheit</code> 和 <code>kelvin</code> 为形参。</p></blockquote><h3 id="2-2-形参命名和实参标签"><a href="#2-2-形参命名和实参标签" class="headerlink" title="2.2 形参命名和实参标签"></a>2.2 形参命名和实参标签</h3><p>跟函数和方法形参相同，构造形参可以同时使用在构造器里使用的形参命名和一个外部调用构造器时使用的实参标签。</p><pre><code>struct Color &#123;    let red, green, blue: Double  //构造器1    init(red: Double, green: Double, blue: Double) &#123;        self.red   = red        self.green = green        self.blue  = blue    &#125;  //构造器2    init(white: Double) &#123;        red   = white        green = white        blue  = white    &#125;&#125;let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)let halfGray = Color(white: 0.5)</code></pre><blockquote><p>构造器并不像函数和方法那样在括号前有一个可辨别的方法名。因此在调用构造器时，主要通过构造器中形参命名和类型来确定应该被调用的构造器，如果在定义构造器时没有提供实参标签，Swift 会为构造器的每个形参自动生成一个实参标签。</p></blockquote><p>如果构造器定义了某个实参标签，就必须使用它，忽略它将导致编译期错误：</p><pre><code>let veryGreen = Color(0.0, 1.0, 0.0)// 报编译期错误-需要实参标签</code></pre><h3 id="2-3-不带实参标签的构造器形参"><a href="#2-3-不带实参标签的构造器形参" class="headerlink" title="2.3 不带实参标签的构造器形参"></a>2.3 不带实参标签的构造器形参</h3><p>如果不希望构造器的某个形参使用实参标签，可以使用下划线（<code>_</code>）来代替显式的实参标签来重写默认行为。</p><pre><code>struct Celsius &#123;    var temperatureInCelsius: Double    init(fromFahrenheit fahrenheit: Double) &#123;        temperatureInCelsius = (fahrenheit - 32.0) / 1.8    &#125;    init(fromKelvin kelvin: Double) &#123;        temperatureInCelsius = kelvin - 273.15    &#125;    init(_ celsius: Double)&#123;        temperatureInCelsius = celsius    &#125;&#125;let bodyTemperature = Celsius(37.0)// bodyTemperature.temperatureInCelsius 为 37.0</code></pre><h3 id="2-4-可选属性类型"><a href="#2-4-可选属性类型" class="headerlink" title="2.4 可选属性类型"></a>2.4 可选属性类型</h3><p>如果自定义的类型有一个逻辑上允许值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时机可以赋值为空——都需要将它声明为 <code>可选类型</code>。可选类型的属性将自动初始化为 <code>nil</code>，表示这个属性是特意在构造过程设置为空。</p><pre><code>class SurveyQuestion &#123;    var text: String    var response: String?    init(text: String) &#123;        self.text = text    &#125;    func ask() &#123;        print(text)    &#125;&#125;let cheeseQuestion = SurveyQuestion(text: &quot;Do you like cheese?&quot;)cheeseQuestion.ask()// 打印“Do you like cheese?”cheeseQuestion.response = &quot;Yes, I do like cheese.&quot;</code></pre><h3 id="2-5-构造过程中常量属性的赋值"><a href="#2-5-构造过程中常量属性的赋值" class="headerlink" title="2.5 构造过程中常量属性的赋值"></a>2.5 构造过程中常量属性的赋值</h3><p>可以在构造过程中的任意时间点给常量属性赋值，只要在构造过程结束时它设置成确定的值。一旦常量属性被赋值，它将永远不可更改。</p><pre><code>class SurveyQuestion &#123;    let text: String    var response: String?    //尽管 text 属性现在是常量，仍然可以在类的构造器中设置它的值：    init(text: String) &#123;        self.text = text    &#125;    func ask() &#123;        print(text)    &#125;&#125;let beetsQuestion = SurveyQuestion(text: &quot;How about beets?&quot;)beetsQuestion.ask()// 打印“How about beets?”beetsQuestion.response = &quot;I also like beets. (But not with cheese.)&quot;</code></pre><blockquote><p>注意：对于类的实例来说，常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p></blockquote><h2 id="3-默认构造器"><a href="#3-默认构造器" class="headerlink" title="3.默认构造器"></a>3.默认构造器</h2><p>如果结构体或类为所有属性提供了默认值，又没有提供任何自定义的构造器，那么 Swift 会给这些结构体或类提供一个<code>默认构造器</code>。这个默认构造器将简单地创建一个所有属性值都设置为它们默认值的实例。</p><pre><code>class ShoppingListItem &#123;    var name: String?    var quantity = 1    var purchased = false&#125;//使用默认构造器创造了一个 ShoppingListItem 类的实例var item = ShoppingListItem()</code></pre><h3 id="3-1-结构体的逐一成员构造器"><a href="#3-1-结构体的逐一成员构造器" class="headerlink" title="3.1 结构体的逐一成员构造器"></a>3.1 结构体的逐一成员构造器</h3><p>结构体如果没有定义任何自定义构造器，它们将自动获得一个逐一成员构造器。不像默认构造器，即使存储型属性没有默认值，结构体也能会获得逐一成员构造器。</p><pre><code>struct Size &#123;    var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0)</code></pre><p>当你调用一个逐一成员构造器时，可以省略任何一个有默认值的属性，对于被省略的属性，构造器会使用默认值：</p><pre><code>let zeroByTwo = Size(height: 2.0)print(zeroByTwo.width, zeroByTwo.height)// 打印 &quot;0.0 2.0&quot;let zeroByZero = Size()print(zeroByZero.width, zeroByZero.height)// 打印 &quot;0.0 0.0&quot;</code></pre><h2 id="4-值类型的构造器代理"><a href="#4-值类型的构造器代理" class="headerlink" title="4.值类型的构造器代理"></a>4.值类型的构造器代理</h2><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为<code>构造器代理</code>，它能避免多个构造器间的代码重复。</p><p>构造器代理的实现规则和形式在值类型和类类型中有所不同，在值类型中有以下特点：</p><ul><li>值类型（结构体和枚举类型）不支持继承，只能代理给自己的其它构造器。</li><li>对于值类型，可以使用 <code>self.init</code> 在自定义的构造器中引用相同类型中的其它构造器。并且只能在构造器内部调用 <code>self.init</code>。</li><li>如果为某个值类型定义了一个自定义的构造器，将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）</li></ul><blockquote><p>注意：如果希望默认构造器、逐一成员构造器以及自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展中，而不是写在值类型的原始定义中。</p></blockquote><pre><code>struct Size &#123;    var width = 0.0, height = 0.0&#125;struct Point &#123;    var x = 0.0, y = 0.0&#125;struct Rect &#123;    var origin = Point()    var size = Size()    init() &#123;&#125;    init(origin: Point, size: Size) &#123;        self.origin = origin        self.size = size    &#125;    init(center: Point, size: Size) &#123;        let originX = center.x - (size.width / 2)        let originY = center.y - (size.height / 2)        self.init(origin: Point(x: originX, y: originY), size: size)    &#125;&#125;</code></pre><p>上面例子中提供了三个自定义的构造器：</p><ul><li>构造器<code>init()</code>：在功能上跟没有自定义构造器时自动获得的默认构造器是一样的<pre><code>let basicRect = Rect()// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)</code></pre></li><li>构造器 <code>init(origin:size:)</code>：在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的<pre><code>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),  size: Size(width: 5.0, height: 5.0))// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)</code></pre></li><li>构造器 <code>init(center:size:) </code>先通过 <code>center</code> 和 <code>size</code> 的值计算出 <code>origin</code> 的坐标，然后再调用 <code>init(origin:size:)</code> 构造器来将新的 <code>origin</code> 和 <code>size</code> 值赋值到对应的属性<pre><code>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),  size: Size(width: 3.0, height: 3.0))// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)</code></pre></li></ul><h2 id="5-类的继承和构造过程"><a href="#5-类的继承和构造过程" class="headerlink" title="5.类的继承和构造过程"></a>5.类的继承和构造过程</h2><p>类里面所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设初始值。</p><p>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，分别为<code>指定构造器</code>和<code>便利构造器</code>。</p><h3 id="5-1-指定构造器和便利构造器"><a href="#5-1-指定构造器和便利构造器" class="headerlink" title="5.1 指定构造器和便利构造器"></a>5.1 指定构造器和便利构造器</h3><ul><li><p><code>指定构造器</code>：<br>1、类中最主要的构造器。<br>2、指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器让构造过程沿着父类链继续往上进行。<br>3、类倾向于拥有极少的指定构造器，普遍的是一个类只拥有一个指定构造器<br>4、每一个类都必须至少拥有一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p></li><li><p><code>便利构造器</code>：<br>1、便利构造器是类中比较次要的、辅助型的构造器。可以定义便利构造器来调用同一个类中的指定构造器，并为部分形参提供默认值。也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。<br>2、应当只在必要的时候为类提供便利构造器。</p></li></ul><h3 id="5-2-指定构造器和便利构造器的语法"><a href="#5-2-指定构造器和便利构造器的语法" class="headerlink" title="5.2 指定构造器和便利构造器的语法"></a>5.2 指定构造器和便利构造器的语法</h3><ul><li>类的<code>指定构造器</code>的语法与值类型简单构造器语法：<pre><code>init(parameters) &#123;  statements&#125;</code></pre></li><li><code>便利构造器</code>也采用相同样式的写法，但需要在 <code>init</code> 关键字之前放置 <code>convenience</code> 关键字，并使用空格将它们俩分开：<pre><code>convenience init(parameters) &#123;  statements&#125;</code></pre></li></ul><h3 id="5-3-类类型的构造器代理"><a href="#5-3-类类型的构造器代理" class="headerlink" title="5.3 类类型的构造器代理"></a>5.3 类类型的构造器代理</h3><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 构造器之间的代理调用遵循以下三条规则：</p><ul><li>指定构造器必须调用其直接父类的的指定构造器</li><li>便利构造器必须调用同类中定义的其它构造器</li><li>便利构造器最后必须调用指定构造器</li></ul><p>也可以这么记忆：</p><ul><li>指定构造器必须总是<code>向上代理</code></li><li>便利构造器必须总是<code>横向代理</code></li></ul><p>这些规则可以通过下面图例来说明：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_%E5%A4%8D%E6%9D%82%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E7%90%86%E5%9B%BE.png"></p><blockquote><p>注意：这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类的构造器如何实现。</p></blockquote><h3 id="5-4-两段式构造过程"><a href="#5-4-两段式构造过程" class="headerlink" title="5.4 两段式构造过程"></a>5.4 两段式构造过程</h3><p>Swift 中类的构造过程包含两个阶段：</p><ul><li>第一阶段：类中的每个存储型属性赋一个初始值</li><li>第二阶段：给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性</li></ul><p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p><blockquote><p>注意：Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 <code>1</code>，Objective-C 给每一个属性赋值 <code>0</code> 或空值（比如说 <code>0</code> 或 <code>nil</code>）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以 <code>0</code> 或 <code>nil</code> 作为合法默认值的情况。</p></blockquote><p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程不出错地完成：</p><ul><li>安全检查1：<code>指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器</code>。</li><li>安全检查2：<code>指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器</code>。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</li><li>安全检查3：<code>便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器</code>。如果没这么做，便利构造器赋予的新值将被该类的指定构造器所覆盖。</li><li>安全检查4：<code>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值</code>。</li></ul><p>类的实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，类的实例才是有效的，才能访问属性和调用方法。</p><p>以下是基于上述安全检查的两段式构造过程展示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E9%98%B6%E6%AE%B51.png"></p><ul><li>阶段1:<br>  1、类的某个指定构造器或便利构造器被调用<br>  2、完成类的新实例内存的分配，但此时内存还没有被初始化<br>  3、指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。<br>  4、指定构造器切换到父类的构造器，对其存储属性完成相同的任务。<br>  5、这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。<br>  6、当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li></ul><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E9%98%B6%E6%AE%B52.png"></p><ul><li>阶段2：<br>  1、从继承链顶部往下，继承链中每个类的指定构造器都有机会进一步自定义实例。构造器此时可以访问 <code>self</code>、修改它的属性并调用实例方法等等<br>  2、最终，继承链中任意的便利构造器有机会自定义实例和使用 <code>self</code></li></ul><h3 id="5-5-构造器的继承和重写"><a href="#5-5-构造器的继承和重写" class="headerlink" title="5.5 构造器的继承和重写"></a>5.5 构造器的继承和重写</h3><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，而在用来创建子类时的新实例时没有完全或错误被初始化。</p><p>假如希望自定义的子类中能提供一个或多个跟父类相同的构造器，可以在子类中提供这些构造器的自定义实现。</p><p>当在编写一个和父类中指定构造器相匹配的子类构造器时，实际上是在重写父类的这个指定构造器。因此，必须在定义子类构造器时带上 <code>override</code> 修饰符。即使重写的是系统自动提供的默认构造器，也需要带上 <code>override</code> 修饰符</p><pre><code>class Vehicle &#123;    var numberOfWheels = 0    var description: String &#123;        return &quot;\(numberOfWheels) wheel(s)&quot;    &#125;&#125;let vehicle = Vehicle()print(&quot;Vehicle: \(vehicle.description)&quot;)// Vehicle: 0 wheel(s)class Bicycle: Vehicle &#123;    override init() &#123;        super.init()        numberOfWheels = 2    &#125;&#125;</code></pre><p>如果子类的构造器没有在<code>阶段 2</code> 过程中做自定义操作，并且父类有一个无参数的指定构造器，你可以在所有子类的存储属性赋值之后省略 <code>super.init()</code> 的调用。</p><pre><code>class Hoverboard: Vehicle &#123;    var color: String    init(color: String) &#123;        self.color = color        // super.init() 在这里被隐式调用    &#125;    override var description: String &#123;        return &quot;\(super.description) in a beautiful \(color)&quot;    &#125;&#125;let hoverboard = Hoverboard(color: &quot;silver&quot;)print(&quot;Hoverboard: \(hoverboard.description)&quot;)// Hoverboard: 0 wheel(s) in a beautiful silver</code></pre><p>如果编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，子类并未对一个父类构造器提供重写。最后的结果就是，在子类中“重写”一个父类便利构造器时，不需要加 <code>override</code>修饰符。</p><blockquote><p>子类可以在构造过程修改继承来的变量属性，但是不能修改继承来的常量属性。</p></blockquote><h3 id="5-6-构造器的自动继承"><a href="#5-6-构造器的自动继承" class="headerlink" title="5.6 构造器的自动继承"></a>5.6 构造器的自动继承</h3><p>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。</p><p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则将适用：</p><ul><li>如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</li><li>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承父类所有的便利构造器。</li></ul><blockquote><p>注意：子类可以将父类的指定构造器实现为便利构造器来满足规则 2。</p></blockquote><h3 id="5-7-指定构造器和便利构造器实践"><a href="#5-7-指定构造器和便利构造器实践" class="headerlink" title="5.7 指定构造器和便利构造器实践"></a>5.7 指定构造器和便利构造器实践</h3><p>定义一个包含三个类 <code>Food</code>、<code>RecipeIngredient</code> 以及 <code>ShoppingListItem</code> 的层级结构，并将演示它们的构造器是如何相互作用的。</p><h4 id="5-7-1-Food类"><a href="#5-7-1-Food类" class="headerlink" title="5.7.1 Food类"></a>5.7.1 Food类</h4><p>基类 <code>Food</code>引入了一个叫做 <code>name</code> 的 <code>String</code> 类型的属性，并且提供了两个构造器来创建 <code>Food</code> 实例:</p><pre><code>class Food &#123;    var name: String    init(name: String) &#123;        self.name = name    &#125;    convenience init() &#123;        self.init(name: &quot;[Unnamed]&quot;)    &#125;&#125;</code></pre><p><code>Food</code> 的构造器链如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_Food%E6%9E%84%E9%80%A0%E5%99%A8%E9%93%BE.png"></p><pre><code>let namedMeat = Food(name: &quot;Bacon&quot;)// 指定构造器初始化，namedMeat 的名字是 &quot;Bacon&quot;let mysteryMeat = Food()// 便利构造器初始化，mysteryMeat 的名字是 [Unnamed]</code></pre><h4 id="5-7-2-RecipeIngredient类"><a href="#5-7-2-RecipeIngredient类" class="headerlink" title="5.7.2 RecipeIngredient类"></a>5.7.2 RecipeIngredient类</h4><p><code>RecipeIngredient</code>继承于<code>Food</code>，它引入了 <code>Int</code> 类型的属性 <code>quantity</code>（以及从 <code>Food</code> 继承过来的 <code>name</code> 属性），并且定义了两个构造器来创建实例：</p><pre><code>class RecipeIngredient: Food &#123;    var quantity: Int    init(name: String, quantity: Int) &#123;        self.quantity = quantity        super.init(name: name)    &#125;    override convenience init(name: String) &#123;        self.init(name: name, quantity: 1)    &#125;&#125;//定义了两个构造器，一个指定，一个便利，由于便利构造器重写了父类的指定构造器，所以需使用 override</code></pre><p><code>RecipeIngredient</code> 类的构造器链如下图所示：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_RecipeIngredient%E6%9E%84%E9%80%A0%E5%99%A8%E9%93%BE.png"></p><p>尽管 <code>RecipeIngredient</code> 将父类的指定构造器重写为了便利构造器，但是它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code> 会自动继承父类的所有便利构造器。</p><p><code>RecipeIngredient</code> 实例可以用以下三种方法来创建：</p><pre><code>//name:[Unnamed],quantity:1let oneMysteryItem = RecipeIngredient()//name:Bacon,quantity:1let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)//name:Eggs,quantity:6let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)</code></pre><h4 id="5-7-3-ShoppingListItem类"><a href="#5-7-3-ShoppingListItem类" class="headerlink" title="5.7.3 ShoppingListItem类"></a>5.7.3 ShoppingListItem类</h4><p><code>ShoppingListItem</code>继承 <code>RecipeIngredient</code>，引入了一个 <code>Boolean</code> 的属性 <code>purchased</code>，默认值是 <code>false</code>。<code>ShoppingListItem</code> 还添加了一个计算型属性 <code>description</code>，它提供了关于 <code>ShoppingListItem</code> 实例的一些文字描述：</p><pre><code>class ShoppingListItem: RecipeIngredient &#123;    var purchased = false    var description: String &#123;        var output = &quot;\(quantity) x \(name)&quot;        output += purchased ? &quot; ✔&quot; : &quot; ✘&quot;        return output    &#125;&#125;</code></pre><p>因为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code> 将自动继承所有父类中的指定构造器和便利构造器。下图展示了这三个类的构造器链：</p><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_%E4%B8%89%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E5%9B%BE.png"></p><p>可以使用三个继承来的构造器来创建 <code>ShoppingListItem</code> 的新实例：</p><pre><code>var breakfastList = [    ShoppingListItem(),    ShoppingListItem(name: &quot;Bacon&quot;),    ShoppingListItem(name: &quot;Eggs&quot;, quantity: 6),]breakfastList[0].name = &quot;Orange juice&quot;breakfastList[0].purchased = truefor item in breakfastList &#123;    print(item.description)&#125;// 1 x orange juice ✔// 1 x bacon ✘// 6 x eggs ✘</code></pre><h2 id="6-可失败构造器"><a href="#6-可失败构造器" class="headerlink" title="6.可失败构造器"></a>6.可失败构造器</h2><p><code>可失败构造器</code>：“失败”是指如给构造器传入无效的形参，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。其语法为在  <code>init</code> 关键字后面添加问号（<code>init?</code>）</p><blockquote><p>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p></blockquote><p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过 <code>return nil</code> 语句来表明可失败构造器在何种情况下应该 “失败”。</p><blockquote><p>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用 <code>return nil</code> 表明可失败构造器构造失败，而不要用关键字 <code>return</code> 来表明构造成功。</p></blockquote><ul><li>可失败构造器 <code>Int(exactly:)</code></li></ul><pre><code>let wholeNumber: Double = 12345.0let pi = 3.14159if let valueMaintained = Int(exactly: wholeNumber) &#123;    print(&quot;\(wholeNumber) conversion to Int maintains value of \(valueMaintained)&quot;)&#125;// 打印“12345.0 conversion to Int maintains value of 12345”let valueChanged = Int(exactly: pi)// valueChanged 是 Int? 类型，不是 Int 类型if valueChanged == nil &#123;    print(&quot;\(pi) conversion to Int does not maintain value&quot;)&#125;// 打印“3.14159 conversion to Int does not maintain value”</code></pre><ul><li>自定义可失败构造器：</li></ul><pre><code>struct Animal &#123;    let species: String    init?(species: String) &#123;        if species.isEmpty &#123;            return nil        &#125;        self.species = species    &#125;&#125;let someCreature = Animal(species: &quot;Giraffe&quot;)// someCreature 的类型是 Animal? 而不是 Animalif let giraffe = someCreature &#123;    print(&quot;An animal was initialized with a species of \(giraffe.species)&quot;)&#125;// 打印“An animal was initialized with a species of Giraffe”let anonymousCreature = Animal(species: &quot;&quot;)// anonymousCreature 的类型是 Animal?, 而不是 Animalif anonymousCreature == nil &#123;    print(&quot;The anonymous creature could not be initialized&quot;)&#125;// 打印“The anonymous creature could not be initialized”</code></pre><h3 id="6-1-枚举类型的可失败构造器"><a href="#6-1-枚举类型的可失败构造器" class="headerlink" title="6.1 枚举类型的可失败构造器"></a>6.1 枚举类型的可失败构造器</h3><p>可以通过一个带一个或多个形参的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的形参无法匹配任何枚举成员，则构造失败。</p><pre><code>enum TemperatureUnit &#123;    case Kelvin, Celsius, Fahrenheit    init?(symbol: Character) &#123;        switch symbol &#123;        case &quot;K&quot;:            self = .Kelvin        case &quot;C&quot;:            self = .Celsius        case &quot;F&quot;:            self = .Fahrenheit        default:            return nil        &#125;    &#125;&#125;let fahrenheitUnit = TemperatureUnit(symbol: &quot;F&quot;)if fahrenheitUnit != nil &#123;    print(&quot;This is a defined temperature unit, so initialization succeeded.&quot;)&#125;// 打印“This is a defined temperature unit, so initialization succeeded.”let unknownUnit = TemperatureUnit(symbol: &quot;X&quot;)//形参不能和任何枚举成员相匹配，构造失败if unknownUnit == nil &#123;    print(&quot;This is not a defined temperature unit, so initialization failed.&quot;)&#125;// 打印“This is not a defined temperature unit, so initialization failed.”</code></pre><h3 id="6-2-带原始值的枚举类型的可失败构造器"><a href="#6-2-带原始值的枚举类型的可失败构造器" class="headerlink" title="6.2 带原始值的枚举类型的可失败构造器"></a>6.2 带原始值的枚举类型的可失败构造器</h3><p>带原始值的枚举类型会自带一个可失败构造器 <code>init?(rawValue:)</code>，该可失败构造器有一个合适的原始值类型的 <code>rawValue</code> 形参，选择找到的相匹配的枚举成员，找不到则构造失败。</p><pre><code>enum TemperatureUnit: Character &#123;    case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;&#125;let fahrenheitUnit = TemperatureUnit(rawValue: &quot;F&quot;)if fahrenheitUnit != nil &#123;    print(&quot;This is a defined temperature unit, so initialization succeeded.&quot;)&#125;// 打印“This is a defined temperature unit, so initialization succeeded.”let unknownUnit = TemperatureUnit(rawValue: &quot;X&quot;)if unknownUnit == nil &#123;    print(&quot;This is not a defined temperature unit, so initialization failed.&quot;)&#125;// 打印“This is not a defined temperature unit, so initialization failed.”</code></pre><h3 id="6-3-构造失败的传递"><a href="#6-3-构造失败的传递" class="headerlink" title="6.3 构造失败的传递"></a>6.3 构造失败的传递</h3><p>类、结构体、枚举的可失败构造器可以横向代理到它们自己其他的可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p><p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p><pre><code>class Product &#123;    let name: String    init?(name: String) &#123;        if name.isEmpty &#123; return nil &#125;        self.name = name    &#125;&#125;class CartItem: Product &#123;    let quantity: Int    init?(name: String, quantity: Int) &#123;        if quantity &lt; 1 &#123; return nil &#125;        self.quantity = quantity        super.init(name: name)    &#125;&#125;</code></pre><p>对于 <code>CartItem</code> 的构造方法能否构造成功有三种情况：</p><ul><li>传入一个非空字符串 <code>name</code> 以及一个值大于等于 1 的 <code>quantity</code>，此时构造成功</li></ul><pre><code>if let twoSocks = CartItem(name: &quot;sock&quot;, quantity: 2) &#123;    print(&quot;Item: \(twoSocks.name), quantity: \(twoSocks.quantity)&quot;)&#125;// 打印“Item: sock, quantity: 2”</code></pre><ul><li>传入一个值为 <code>0</code> 的 <code>quantity</code>，构造失败，而且不会执行<code>Product</code>的构造方法</li></ul><pre><code>if let zeroShirts = CartItem(name: &quot;shirt&quot;, quantity: 0) &#123;    print(&quot;Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)&quot;)&#125; else &#123;    print(&quot;Unable to initialize zero shirts&quot;)&#125;// 打印“Unable to initialize zero shirts”</code></pre><ul><li>传入一个值为空字符串的 <code>name</code>，父类<code>Product</code>构造过程失败，导致<code>CartItem</code>构造失败</li></ul><pre><code>if let oneUnnamed = CartItem(name: &quot;&quot;, quantity: 1) &#123;    print(&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;)&#125; else &#123;    print(&quot;Unable to initialize one unnamed product&quot;)&#125;// 打印“Unable to initialize one unnamed product”</code></pre><h3 id="6-4-重写一个可失败构造器"><a href="#6-4-重写一个可失败构造器" class="headerlink" title="6.4 重写一个可失败构造器"></a>6.4 重写一个可失败构造器</h3><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p><blockquote><p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p></blockquote><pre><code>class Document &#123;    var name: String?    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例    init() &#123;&#125;    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例    init?(name: String) &#123;        if name.isEmpty &#123; return nil &#125;        self.name = name    &#125;&#125;class AutomaticallyNamedDocument: Document &#123;    override init() &#123;        super.init()        self.name = &quot;[Untitled]&quot;    &#125;    override init(name: String) &#123;        super.init()        if name.isEmpty &#123;            self.name = &quot;[Untitled]&quot;        &#125; else &#123;            self.name = name        &#125;    &#125;&#125;</code></pre><p>可以在子类的不可失败构造器中使用强制解包来调用父类的可失败构造器:</p><pre><code>class UntitledDocument: Document &#123;    override init() &#123;        super.init(name: &quot;[Untitled]&quot;)!    &#125;&#125;</code></pre><p>在这个例子中，如果在调用父类的可失败构造器 <code>init?(name:)</code> 时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过字符串常量来调用它，构造器不会失败，所以并不会发生运行时错误。</p><h3 id="6-5-init-可失败构造器"><a href="#6-5-init-可失败构造器" class="headerlink" title="6.5 init! 可失败构造器"></a>6.5 init! 可失败构造器</h3><p>通常来说我们通过在 <code>init</code> 关键字后添加问号的方式（<code>init?</code>）来定义一个可失败构造器，但你也可以通过在 <code>init</code> 后面添加感叹号的方式来定义一个可失败构造器（<code>init!</code>），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p><p>你可以在 <code>init?</code> 中代理到 <code>init!</code>，反之亦然。你也可以用 <code>init?</code> 重写 <code>init!</code>，反之亦然。你还可以用 <code>init</code> 代理到 <code>init!</code>，不过，一旦 <code>init!</code> 构造失败，则会触发一个断言。</p><h2 id="7-必要构造器"><a href="#7-必要构造器" class="headerlink" title="7.必要构造器"></a>7.必要构造器</h2><p>在类的构造器前添加 <code>required</code> 修饰符表明所有该类的子类都必须实现该构造器：</p><pre><code>class SomeClass &#123;    required init() &#123;        // 构造器的实现代码    &#125;&#125;</code></pre><p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加 <code>required</code> 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符：</p><pre><code>class SomeSubclass: SomeClass &#123;    required init() &#123;        // 构造器的实现代码    &#125;&#125;</code></pre><blockquote><p>注意：如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现</p></blockquote><h2 id="8-通过闭包或函数设置属性的默认值"><a href="#8-通过闭包或函数设置属性的默认值" class="headerlink" title="8.通过闭包或函数设置属性的默认值"></a>8.通过闭包或函数设置属性的默认值</h2><p>如果某个存储型属性的默认值需要一些自定义或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被构造时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p><p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p><p>用闭包为属性提供默认值:</p><pre><code>class SomeClass &#123;    let someProperty: SomeType = &#123;        // 在这个闭包中给 someProperty 创建一个默认值        // someValue 必须和 SomeType 类型相同        return someValue    &#125;()&#125;</code></pre><p>闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p><blockquote><p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 self 属性，或者调用任何实例方法。</p></blockquote><p>结构体 <code>Chessboard</code>，它构建了西洋跳棋游戏的棋盘，西洋跳棋游戏在一副黑白格交替的 8 x 8 的棋盘中进行的：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B_%E8%A5%BF%E6%B4%8B%E8%B7%B3%E6%A3%8B%E6%A3%8B%E7%9B%98.png"></p><pre><code>struct Chessboard &#123;    let boardColors: [Bool] = &#123;        var temporaryBoard = [Bool]()        var isBlack = false        for i in 1...8 &#123;            for j in 1...8 &#123;                temporaryBoard.append(isBlack)                isBlack = !isBlack            &#125;            isBlack = !isBlack        &#125;        return temporaryBoard    &#125;()    func squareIsBlackAt(row: Int, column: Int) -&gt; Bool &#123;        return boardColors[(row * 8) + column]    &#125;&#125;let board = Chessboard()print(board.squareIsBlackAt(row: 0, column: 1))// 打印“true”print(board.squareIsBlackAt(row: 7, column: 7))// 打印“false”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 继承</title>
      <link href="posts/773258487.html"/>
      <url>posts/773258487.html</url>
      
        <content type="html"><![CDATA[<p>一个类可以继承另一个类的方法、属性和其他特性。当一个类继承其他类时，继承类称为子类，被继承类称为父类。在Swift中继承是「类」区别其他类型的一个基本特征。</p><p>在 Swift 中，类可以调用和访问超类的方法、属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。</p><p>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p><h2 id="1-基类"><a href="#1-基类" class="headerlink" title="1.基类"></a>1.基类</h2><p>基类：不继承于其他类的类。定义类时如果不指定父类，则定义的类就自动称为基类。</p><pre><code>class Vehicle &#123;    var currentSpeed = 0.0    var description: String &#123;        return &quot;traveling at \(currentSpeed) miles per hour&quot;    &#125;    func makeNoise() &#123;    &#125;&#125;let someVehicle = Vehicle()print(&quot;Vehicle: \(someVehicle.description)&quot;)</code></pre><blockquote><p>Swift 中的类并不是从一个通用的基类继承而来的。如果你不为自己定义的类指定一个父类的话，这个类就会自动成为基类。</p></blockquote><h2 id="2-子类"><a href="#2-子类" class="headerlink" title="2.子类"></a>2.子类</h2><p>子类：在已有类的基础上创建的一个新类。</p><pre><code>class Bicycle: Vehicle &#123;    var hasBasket = false&#125;</code></pre><ul><li>子类自动继承父类的所有特性，比如属性和方法</li><li>子类可以添加新的特性</li><li>子类可以修改和查询继承自父类的属性</li></ul><pre><code>bicycle.currentSpeed = 15.0print(&quot;Bicycle: \(bicycle.description)&quot;)// 打印“Bicycle: traveling at 15.0 miles per hour”</code></pre><ul><li>子类可以继续被继承<pre><code>class Tandem: Bicycle &#123;  var currentNumberOfPassengers = 0&#125;let tandem = Tandem()tandem.hasBasket = truetandem.currentNumberOfPassengers = 2tandem.currentSpeed = 22.0print(&quot;Tandem: \(tandem.description)&quot;)// 打印：“Tandem: traveling at 22.0 miles per hour”</code></pre></li></ul><h2 id="3-重写"><a href="#3-重写" class="headerlink" title="3.重写"></a>3.重写</h2><p><code>重写</code>：子类为继承来的实例方法、类方法、实例属性、类属性、或下标提供自己定制的实现，用关键字 <code>override</code>来实现重写。</p><h3 id="3-1-访问超类的方法，属性及下标"><a href="#3-1-访问超类的方法，属性及下标" class="headerlink" title="3.1 访问超类的方法，属性及下标"></a>3.1 访问超类的方法，属性及下标</h3><p>使用 <code>super</code> 前缀访问父类的方法、属性和下标：</p><ul><li><code>super.someMethod()</code> 调用父类方法</li><li><code>super.someProperty</code>访问父类 <code>someProperty</code> 属性</li><li><code>super[someIndex]</code> 访问父类相同的下标</li></ul><h3 id="3-2-重写方法"><a href="#3-2-重写方法" class="headerlink" title="3.2 重写方法"></a>3.2 重写方法</h3><pre><code>class Train: Vehicle &#123;    override func makeNoise() &#123;        print(&quot;Choo Choo&quot;)    &#125;&#125;let train = Train()train.makeNoise()// 打印“Choo Choo”</code></pre><h3 id="3-3-重写属性"><a href="#3-3-重写属性" class="headerlink" title="3.3 重写属性"></a>3.3 重写属性</h3><p>可以重写继承来的实例属性或类型属性，提供自己定制的 <code>getter</code> 和 <code>setter</code>，或添加属性观察器，使重写的属性可以观察到底层的属性值什么时候发生改变。</p><h4 id="3-3-1-重写属性的-getter-和-setter"><a href="#3-3-1-重写属性的-getter-和-setter" class="headerlink" title="3.3.1 重写属性的 getter 和 setter"></a>3.3.1 重写属性的 <code>getter</code> 和 <code>setter</code></h4><pre><code>class Car: Vehicle &#123;    var gear = 1        override var description: String &#123;        return super.description + &quot; in gear \(gear)&quot;    &#125;&#125;let car = Car()car.currentSpeed = 25.0car.gear = 3print(&quot;Car: \(car.description)&quot;)// 打印“Car: traveling at 25.0 miles per hour in gear 3”</code></pre><blockquote><p>注意：</p><ul><li>子类可以重写任何一个继承来的属性（无论是存储型还是计算型），因为子类并不知道继承来的属性是存储属性还是计算属性，只知道继承来的属性有一个名字和类型</li><li>在重写一个属性时，必须将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与父类中同名同类型的属性相匹配的。</li><li>可以将一个继承来的只读属性重写为一个读写属性，但不可以将一个继承来的读写属性重写为一个只读属性。</li><li>如果你在重写属性中提供了 <code>setter</code>，那么你也一定要提供 <code>getter</code>。如果你不想在重写版本中的 <code>getter</code> 里修改继承来的属性值，你可以直接通过 <code>super.someProperty</code> 来返回继承来的值，其中 <code>someProperty</code> 是你要重写的属性的名字。</li></ul></blockquote><h4 id="3-3-2-重写属性观察器"><a href="#3-3-2-重写属性观察器" class="headerlink" title="3.3.2 重写属性观察器"></a>3.3.2 重写属性观察器</h4><p>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，无论被继承属性原本是如何实现的，当其属性值发生改变时，你就会被通知到。</p><pre><code>class AutomaticCar: Car &#123;    override var currentSpeed: Double &#123;        didSet &#123;            gear = Int(currentSpeed / 10.0) + 1        &#125;    &#125;&#125;let automatic = AutomaticCar()automatic.currentSpeed = 35.0print(&quot;AutomaticCar: \(automatic.description)&quot;)// 打印“AutomaticCar: traveling at 35.0 miles per hour in gear 4”</code></pre><blockquote><p>注意：</p><ul><li>不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器</li><li>不可以同时提供重写的 <code>setter</code> 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 <code>setter</code>，那么你在 <code>setter</code> 中就可以观察到任何值变化了。</li></ul></blockquote><h2 id="4-防止重写"><a href="#4-防止重写" class="headerlink" title="4.防止重写"></a>4.防止重写</h2><ul><li>把方法、属性或下标标记为 <code>final</code> 可以防止它们被重写，例如：<code>final var</code>、<code>final func</code>、<code>final class func</code> 以及 <code>final subscript</code></li><li>在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 <code>final</code>。</li><li>可以通过在关键字 <code>class</code> 前添加 <code>final</code> 来将整个类标记为 <code>final</code> 。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 下标</title>
      <link href="posts/1770177402.html"/>
      <url>posts/1770177402.html</url>
      
        <content type="html"><![CDATA[<p>下标可以定义在类、结构体和枚举中，是访问集合、列表或序列中元素的快捷方式。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。例如用下标访问一个 <code>Array</code> 实例中的元素可以写作 <code>someArray[index]</code>，访问 Dictionary 实例中的元素可以写作 <code>someDictionary[key]</code>。</p><p>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求。</p><h2 id="1-下标语法"><a href="#1-下标语法" class="headerlink" title="1.下标语法"></a>1.下标语法</h2><p>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合：</p><ul><li>定义下标使用 <code>subscript</code> 关键字，指定一个或多个输入参数和返回类型</li><li>下标可以设定为读写或只读</li><li>由 <code>getter</code> 和 <code>setter</code> 实现，有点类似计算型属性<pre><code>subscript(index: Int) -&gt; Int &#123;  get &#123;    // 返回一个适当的 Int 类型的值  &#125;  set(newValue) &#123;    // 执行适当的赋值操作  &#125;&#125;</code></pre></li><li>如果下标设定为只读，则可以省略 <code>get</code>关键字<pre><code>subscript(index: Int) -&gt; Int &#123;  // 返回一个适当的 Int 类型的值&#125;</code></pre>举例：定义了一个 <code>TimesTable</code> 结构体，用来表示传入整数的乘法表：<pre><code>struct TimesTable &#123;  let multiplier: Int  subscript(index: Int) -&gt; Int &#123;      return multiplier * index  &#125;&#125;let threeTimesTable = TimesTable(multiplier: 3)print(&quot;six times three is \(threeTimesTable[6])&quot;)// 打印“six times three is 18”</code></pre></li></ul><h2 id="2-下标用法"><a href="#2-下标用法" class="headerlink" title="2.下标用法"></a>2.下标用法</h2><p>下标通常作为访问集合，列表或序列中元素的快捷方式</p><pre><code>var numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]numberOfLegs[&quot;bird&quot;] = 2</code></pre><h2 id="3-下标选项"><a href="#3-下标选项" class="headerlink" title="3.下标选项"></a>3.下标选项</h2><p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用可变参数，并且可以提供默认参数数值，但是不能使用 <code>in-out</code> 参数。</p><p>一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配适合的下标，这就是<code>下标的重载</code>。</p><p>例子：定义了一个 <code>Matrix</code> 结构体，用于表示一个 <code>Double</code> 类型的二维矩阵。<code>Matrix</code> 结构体的下标接受两个整型参数：</p><pre><code>struct Matrix &#123;    let rows: Int, columns: Int    var grid: [Double]    init(rows: Int, columns: Int) &#123;        self.rows = rows        self.columns = columns        grid = Array(repeating: 0.0, count: rows * columns)    &#125;    //检查参数 row 和 column 的值是否在范围内    func indexIsValid(row: Int, column: Int) -&gt; Bool &#123;        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns    &#125;    subscript(row: Int, column: Int) -&gt; Double &#123;        get &#123;            assert(indexIsValid(row: row, column: column), &quot;Index out of range&quot;)            return grid[(row * columns) + column]        &#125;        set &#123;            assert(indexIsValid(row: row, column: column), &quot;Index out of range&quot;)            grid[(row * columns) + column] = newValue        &#125;    &#125;&#125;var matrix = Matrix(rows: 2, columns: 2)  //grid = [0.0, 0.0, 0.0, 0.0]</code></pre><p><img src="images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%8B%E6%A0%87_%E5%88%9D%E5%A7%8B%E7%9F%A9%E9%98%B5.png"></p><pre><code>matrix[0, 1] = 1.5matrix[1, 0] = 3.2  //grid = [0.0, 1.5, 3.2, 0.0]</code></pre><p><img src="images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%8B%E6%A0%87_%E7%9F%A9%E9%98%B5%E8%B5%8B%E5%80%BC.png"><br>断言在下标越界时触发：</p><pre><code>let someValue = matrix[2, 2]// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</code></pre><h2 id="4-类型下标"><a href="#4-类型下标" class="headerlink" title="4.类型下标"></a>4.类型下标</h2><p>在 <code>subscript</code> 关键字之前写下 <code>static</code> 关键字的方式来表示一个类型下标，类可以使用 <code>class</code> 关键字来允许子类重写父类中对那个下标的实现。</p><pre><code>enum Planet: Int &#123;    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune    static subscript(n: Int) -&gt; Planet &#123;        return Planet(rawValue: n)!    &#125;&#125;let mars = Planet[4]print(mars)</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 方法</title>
      <link href="posts/2463101924.html"/>
      <url>posts/2463101924.html</url>
      
        <content type="html"><![CDATA[<p>方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法和类型方法，可以分为：</p><ul><li><code>实例方法</code>：为给定类型的实例封装了具体的任务与功能</li><li><code>类型方法</code>：与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</li></ul><h2 id="1-实例方法"><a href="#1-实例方法" class="headerlink" title="1.实例方法"></a>1.实例方法</h2><p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p><pre><code>class Counter &#123;    var count = 0    //计数器按一递增    func increment() &#123;        count += 1    &#125;    //计数器按一个指定的整数值递增    func increment(by amount: Int) &#123;        count += amount    &#125;    //重置计数器    func reset() &#123;        count = 0    &#125;&#125;</code></pre><p>和调用属性一样，用<code>点语法</code>调用实例方法：</p><pre><code>let counter = Counter()// 初始计数值是0counter.increment()// 计数值现在是1counter.increment(by: 5)// 计数值现在是6counter.reset()// 计数值现在是0</code></pre><h3 id="1-1-self-属性"><a href="#1-1-self-属性" class="headerlink" title="1.1 self 属性"></a>1.1 self 属性</h3><p>类型的每一个实例都有一个隐含属性叫做 <code>self</code>，<code>self</code> 完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的 <code>self</code> 属性来引用当前实例。</p><pre><code>func increment() &#123;    self.count += 1&#125;</code></pre><p>实例方法的某个参数名称与实例的某个属性名称相同的时候，可以使用 <code>self</code> 属性来区分参数名称和属性名称。</p><pre><code>struct Point &#123;    var x = 0.0, y = 0.0    func isToTheRightOf(x: Double) -&gt; Bool &#123;        return self.x &gt; x    &#125;&#125;let somePoint = Point(x: 4.0, y: 5.0)if somePoint.isToTheRightOf(x: 1.0) &#123;    print(&quot;This point is to the right of the line where x == 1.0&quot;)&#125;// 打印“This point is to the right of the line where x == 1.0”</code></pre><p>如果不使用 <code>self</code> 前缀，Swift会认为 <code>x</code> 的两个用法都引用了名为 <code>x</code> 的方法参数。</p><h3 id="1-2-在实例方法中修改值类型"><a href="#1-2-在实例方法中修改值类型" class="headerlink" title="1.2 在实例方法中修改值类型"></a>1.2 在实例方法中修改值类型</h3><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在实例方法中被修改。如果确实需要修改结构体或者枚举的属性，要使用可变方法，将关键字 <code>mutating</code> 放到方法的 <code>func</code> 关键字之前:</p><pre><code>struct Point &#123;    var x = 0.0, y = 0.0    mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123;        x += deltaX        y += deltaY    &#125;&#125;var somePoint = Point(x: 1.0, y: 1.0)somePoint.moveBy(x: 2.0, y: 3.0)print(&quot;The point is now at (\(somePoint.x), \(somePoint.y))&quot;)// 打印“The point is now at (3.0, 4.0)”</code></pre><p>不能在结构体类型的常量上调用可变方法，即使属性是变量属性</p><pre><code>let fixedPoint = Point(x: 3.0, y: 3.0)fixedPoint.moveBy(x: 2.0, y: 3.0)// 这里将会报告一个错误</code></pre><h3 id="1-3-在可变方法中给-self-赋值"><a href="#1-3-在可变方法中给-self-赋值" class="headerlink" title="1.3 在可变方法中给 self 赋值"></a>1.3 在可变方法中给 self 赋值</h3><p>可变方法能够赋给隐含属性 <code>self</code> 一个全新的实例：</p><pre><code>struct Point &#123;    var x = 0.0, y = 0.0    mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123;        self = Point(x: x + deltaX, y: y + deltaY)    &#125;&#125;</code></pre><p>枚举的可变方法可以把 <code>self</code> 设置为同一枚举类型中不同的成员：</p><pre><code>enum TriStateSwitch &#123;    case off, low, high    mutating func next() &#123;        switch self &#123;        case .off:            self = .low        case .low:            self = .high        case .high:            self = .off        &#125;    &#125;&#125;var ovenLight = TriStateSwitch.lowovenLight.next()// ovenLight 现在等于 .highovenLight.next()// ovenLight 现在等于 .off</code></pre><h2 id="2-类型方法"><a href="#2-类型方法" class="headerlink" title="2.类型方法"></a>2.类型方法</h2><p>在方法的 <code>func</code> 关键字之前加上关键字 <code>static</code>，来指定类型方法，用关键字 <code>class</code> 来指定，从而允许子类重写父类该方法的实现</p><pre><code>class 类名 &#123;    static func 类方法名() &#123;        // 在这里实现类型方法    &#125;    class func 实例方法名() &#123;    &#125;&#125;</code></pre><p>类型方法和实例方法一样用点语法调用：</p><pre><code>class SomeClass &#123;    class func someTypeMethod() &#123;        // 在这里实现类型方法    &#125;&#125;SomeClass.someTypeMethod()</code></pre><blockquote><p>在类型方法的方法体（body）中，<code>self</code> 属性指向这个类型本身，而不是类型的某个实例。这意味着你可以用 self 来消除类型属性和类型方法参数之间的歧义。</p></blockquote><p>一般来说，在类型方法的方法体中，任何未限定的方法和属性名称，可以被本类中其他的类型方法和类型属性引用。一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称。类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p><pre><code>//LevelTracker 结构体监测玩家的游戏发展情况struct LevelTracker &#123;    static var highestUnlockedLevel = 1    var currentLevel = 1    //解锁等级    static func unlock(_ level: Int) &#123;        if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;    &#125;    //等级是否被解锁    static func isUnlocked(_ level: Int) -&gt; Bool &#123;        return level &lt;= highestUnlockedLevel    &#125;    @discardableResult    //在更新 currentLevel 之前检查所请求的新等级是否已经解锁    mutating func advance(to level: Int) -&gt; Bool &#123;        if LevelTracker.isUnlocked(level) &#123;            currentLevel = level            return true        &#125; else &#123;            return false        &#125;    &#125;&#125;//Player 类使用 LevelTracker 来监测和更新每个玩家的发展进度：class Player &#123;    var tracker = LevelTracker()    let playerName: String    //为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级    func complete(level: Int) &#123;        LevelTracker.unlock(level + 1)        tracker.advance(to: level + 1)    &#125;    init(name: String) &#123;        playerName = name    &#125;&#125;var player = Player(name: &quot;Argyrios&quot;)player.complete(level: 1)print(&quot;highest unlocked level is now \(LevelTracker.highestUnlockedLevel)&quot;)// 打印“highest unlocked level is now 2”player = Player(name: &quot;Beto&quot;)if player.tracker.advance(to: 6) &#123;    print(&quot;player is now on level 6&quot;)&#125; else &#123;    print(&quot;level 6 has not yet been unlocked&quot;)&#125;// 打印“level 6 has not yet been unlocked”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 属性</title>
      <link href="posts/1726206313.html"/>
      <url>posts/1726206313.html</url>
      
        <content type="html"><![CDATA[<p>属性将值与特定的类、结构体或枚举关联。属性可以分为：</p><ul><li>存储属性：将常量和变量存储为实例的一部分，只能用于类和结构体。</li><li>计算属性：直接计算值，可以用于类、结构体和枚举。</li></ul><p>存储属性和计算属性通常与特定类型的实例关联。但是，<strong>属性也可以直接与类型本身关联，这种属性称为类型属性</strong>。</p><p>另外，还可以定义属性观察器来监控属性值的变化，以此来触发自定义的操作。属性观察器可以添加到类本身定义的存储属性上，也可以添加到从父类继承的属性上。</p><h2 id="1-存储属性"><a href="#1-存储属性" class="headerlink" title="1.存储属性"></a>1.存储属性</h2><p>存储属性就是存储在特定类或结构体实例里的一个常量或变量。可以在定义存储属性的时候指定默认值，也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。</p><pre><code>struct FixedLengthRange &#123;    var firstValue: Int    let length: Int&#125;var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)// 该区间表示整数 0，1，2rangeOfThreeItems.firstValue = 6// 该区间现在表示整数 6，7，8</code></pre><h3 id="1-1-常量结构体实例的存储属性"><a href="#1-1-常量结构体实例的存储属性" class="headerlink" title="1.1 常量结构体实例的存储属性"></a>1.1 常量结构体实例的存储属性</h3><p>如果创建了一个结构体实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使被声明为可变属性也不行。</p><pre><code>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)// 该区间表示整数 0，1，2，3rangeOfFourItems.firstValue = 6// 尽管 firstValue 是个可变属性，但这里还是会报错</code></pre><p>这是由于结构体属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p><blockquote><p>属于引用类型的类则不一样。把一个引用类型的实例赋给一个常量后，依然可以修改该实例的可变属性。</p></blockquote><h3 id="1-2-延时加载存储属性"><a href="#1-2-延时加载存储属性" class="headerlink" title="1.2 延时加载存储属性"></a>1.2 延时加载存储属性</h3><p>延时加载存储属性是指当第一次被调用的时候才会计算其初始值的属性，在属性声明前使用 <code>lazy</code>来标示一个延时加载存储属性。</p><pre><code>class DataImporter &#123;    /*    DataImporter 是一个负责将外部文件中的数据导入的类。    这个类的初始化会消耗不少时间。    */    var fileName = &quot;data.txt&quot;    // 这里会提供数据导入功能&#125;class DataManager &#123;    lazy var importer = DataImporter()    var data = [String]()    // 这里会提供数据管理功能&#125;let manager = DataManager()manager.data.append(&quot;Some data&quot;)manager.data.append(&quot;Some more data&quot;)// DataImporter 实例的 importer 属性还没有被创建print(manager.importer.fileName)// DataImporter 实例的 importer 属性现在被创建了// 输出“data.txt”</code></pre><blockquote><p>注意：</p><ul><li>必须将延时加载属性声明成变量，因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延时加载。</li><li>如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</li></ul></blockquote><h3 id="1-3-存储属性和实例变量"><a href="#1-3-存储属性和实例变量" class="headerlink" title="1.3 存储属性和实例变量"></a>1.3 存储属性和实例变量</h3><p>Objective-C 为类实例存储值和引用提供两种方法，除了属性之外，还可以使用实例变量作为一个备份存储将变量值赋值给属性。</p><p>Swift 把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的备份存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——作为类型定义的一部分，都定义在一个地方。</p><h2 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2.计算属性"></a>2.计算属性</h2><p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 <code>getter</code> 和 一个可选的 <code>setter</code>，来间接获取和设置其他属性或变量的值。</p><pre><code>struct Point &#123;    var x = 0.0, y = 0.0&#125;struct Size &#123;    var width = 0.0, height = 0.0&#125;struct Rect &#123;    var origin = Point()    var size = Size()    var center: Point &#123;        get &#123;            let centerX = origin.x + (size.width / 2)            let centerY = origin.y + (size.height / 2)            return Point(x: centerX, y: centerY)        &#125;        set(newCenter) &#123;            origin.x = newCenter.x - (size.width / 2)            origin.y = newCenter.y - (size.height / 2)        &#125;    &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0),    size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)// 打印“square.origin is now at (10.0, 10.0)”</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%9E%E6%80%A7_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%AE%9E%E4%BE%8B.png"></p><h3 id="2-1-简化-Setter-声明"><a href="#2-1-简化-Setter-声明" class="headerlink" title="2.1 简化 Setter 声明"></a>2.1 简化 Setter 声明</h3><p>如果计算属性的 <code>setter</code> 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>:</p><pre><code>struct AlternativeRect &#123;    var origin = Point()    var size = Size()    var center: Point &#123;        get &#123;            let centerX = origin.x + (size.width / 2)            let centerY = origin.y + (size.height / 2)            return Point(x: centerX, y: centerY)        &#125;        set &#123;            origin.x = newValue.x - (size.width / 2)            origin.y = newValue.y - (size.height / 2)        &#125;    &#125;&#125;</code></pre><h3 id="2-2-简化-Getter-声明"><a href="#2-2-简化-Getter-声明" class="headerlink" title="2.2 简化 Getter 声明"></a>2.2 简化 Getter 声明</h3><p>如果整个 <code>getter</code> 是单一表达式，<code>getter</code> 会隐式地返回这个表达式结果:</p><pre><code>struct CompactRect &#123;    var origin = Point()    var size = Size()    var center: Point &#123;        get &#123;            Point(x: origin.x + (size.width / 2),                  y: origin.y + (size.height / 2))        &#125;        set &#123;            origin.x = newValue.x - (size.width / 2)            origin.y = newValue.y - (size.height / 2)        &#125;    &#125;&#125;</code></pre><blockquote><p>在 <code>getter</code> 中忽略 <code>return</code> 与在函数中忽略 <code>return</code> 的规则相同。</p></blockquote><h3 id="2-3-只读计算属性"><a href="#2-3-只读计算属性" class="headerlink" title="2.3 只读计算属性"></a>2.3 只读计算属性</h3><p>只有 <code>getter</code> 没有 <code>setter</code> 的计算属性叫<strong>只读计算属性</strong>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p><blockquote><p>必须使用 <code>var</code> 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。<code>let</code> 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p></blockquote><p>只读计算属性的声明可以去掉 <code>get</code> 关键字和花括号：</p><pre><code>struct Cuboid &#123;    var width = 0.0, height = 0.0, depth = 0.0    var volume: Double &#123;        return width * height * depth    &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)// 打印“the volume of fourByFiveByTwo is 40.0”</code></pre><h2 id="3-属性观察器"><a href="#3-属性观察器" class="headerlink" title="3.属性观察器"></a>3.属性观察器</h2><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p><p>可以在以下位置添加属性观察器：</p><ul><li>自定义的存储属性</li><li>继承的存储属性</li><li>继承的计算属性</li></ul><p>对于继承的属性，你可以在子类中通过重写属性的方式为它添加属性观察器。对于自定义的计算属性来说，使用它的 <code>setter</code> 监控和响应值的变化，而不是尝试创建观察器。</p><p>可以为属性添加观察器：</p><ul><li><code>willSet</code> 在新的值被设置之前调用，默认参数名称 <code>newValue</code></li><li><code>didSet</code> 在新的值被设置之后调用，默认参数名 <code>oldValue</code><pre><code>class StepCounter &#123;  var totalSteps: Int = 0 &#123;      willSet(newTotalSteps) &#123;          print(&quot;将 totalSteps 的值设置为 \(newTotalSteps)&quot;)      &#125;      didSet &#123;          if totalSteps &gt; oldValue  &#123;              print(&quot;增加了 \(totalSteps - oldValue) 步&quot;)          &#125;      &#125;  &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// 将 totalSteps 的值设置为 200// 增加了 200 步stepCounter.totalSteps = 360// 将 totalSteps 的值设置为 360// 增加了 160 步stepCounter.totalSteps = 896// 将 totalSteps 的值设置为 896// 增加了 536 步</code></pre><blockquote><p>注意：</p><ul><li>在父类初始化方法调用之后，在子类构造器中给父类的属性赋值时，会调用父类属性的 <code>willSet</code> 和 <code>didSet</code> 观察器。而在父类初始化方法调用之前，给子类的属性赋值时不会调用子类属性的观察器。</li><li>如果将带有观察器的属性通过 <code>in-out</code> 方式传入函数，<code>willSet</code> 和 <code>didSet</code> 也会调用。这是因为 <code>in-out</code> 参数采用了拷入拷出内存模式：即在函数内部使用的是参数的 <code>copy</code>，函数结束后，又对参数重新赋值。</li></ul></blockquote></li></ul><h2 id="4-属性包装器"><a href="#4-属性包装器" class="headerlink" title="4.属性包装器"></a>4.属性包装器</h2><p>属性包装器在管理属性如何存储和定义属性的代码之间添加了一个分隔层。举例来说，如果属性需要线程安全性检查或者需要在数据库中存储他们的基本数据，那么需要给每个属性添加同样的逻辑代码。当使用属性包装器时，只需在定义属性包装器时编写一次管理代码，然后应用到多个属性上来进行复用。</p><p>定义一个属性包装器，你需要创建一个定义 <code>wrappedValue</code> 属性的结构体、枚举或者类。</p><pre><code>// 这个结构体确保它包装的值始终是小于等于 12 的数字@propertyWrapperstruct TwelveOrLess &#123;    private var number: Int    init() &#123; self.number = 0 &#125;    var wrappedValue: Int &#123;        get &#123; return number &#125;        set &#123; number = min(newValue, 12) &#125;    &#125;&#125;</code></pre><blockquote><p>上面例子以 <code>private</code> 的方式声明 <code>number</code> 变量，这使得 <code>number</code> 仅在 <code>TwelveOrLess</code> 的实现中使用。写在其他地方的代码通过使用 <code>wrappedValue</code> 的 <code>getter</code> 和 <code>setter</code> 来获取这个值，但不能直接使用 <code>number</code>。</p></blockquote><p>通过在属性之前写上包装器名称作为特性的方式，你可以把一个包装器应用到一个属性上去：</p><pre><code>struct SmallRectangle &#123;    @TwelveOrLess var height: Int    @TwelveOrLess var width: Int&#125;var rectangle = SmallRectangle()print(rectangle.height)// 打印 &quot;0&quot;rectangle.height = 10print(rectangle.height)// 打印 &quot;10&quot;rectangle.height = 24print(rectangle.height)// 打印 &quot;12&quot;</code></pre><blockquote><p>这种情况是编译器将合成提供包装器存储空间和通过包装器访问属性的代码。（属性包装器只负责存储被包装值，所以没有合成这些代码。）</p></blockquote><p>对于上面的 <code>SmallRectangle</code>，也可以将其属性明确地包装在 <code>TwelveOrLess</code> 结构体中，而不是把 <code>@TwelveOrLess</code> 作为特性写下来：</p><pre><code>struct SmallRectangle &#123;    private var _height = TwelveOrLess()    private var _width = TwelveOrLess()    var height: Int &#123;        get &#123; return _height.wrappedValue &#125;        set &#123; _height.wrappedValue = newValue &#125;    &#125;    var width: Int &#123;        get &#123; return _width.wrappedValue &#125;        set &#123; _width.wrappedValue = newValue &#125;    &#125;&#125;</code></pre><p><code>_height</code> 和 <code>_width</code> 属性存着这个属性包装器的一个实例，即 <code>TwelveOrLess</code>。<code>height</code> 和 <code>width</code> 的 <code>getter</code> 和 <code>setter</code> 把对 <code>wrappedValue</code> 属性的访问包装起来。</p><h3 id="4-1-设置被包装属性的初始值"><a href="#4-1-设置被包装属性的初始值" class="headerlink" title="4.1 设置被包装属性的初始值"></a>4.1 设置被包装属性的初始值</h3><p>上面例子中的代码通过在 <code>TwelveOrLess</code> 的定义中赋予 <code>number</code> 一个初始值来设置被包装属性的初始值。使用这个属性包装器的代码没法为被 <code>TwelveOrLess</code> 包装的属性指定其他初始值。举例来说，<code>SmallRectangle</code> 的定义没法给 <code>height</code> 或者 <code>width</code> 一个初始值。为了支持设定一个初始值或者其他自定义操作，属性包装器需要添加一个构造器。这是 <code>TwelveOrLess</code> 的扩展版本，称为 <code>SmallNumber</code>。<code>SmallNumber</code> 定义了能设置被包装值和最大值的构造器：</p><pre><code>@propertyWrapperstruct SmallNumber &#123;    private var maximum: Int    private var number: Int    var wrappedValue: Int &#123;        get &#123; return number &#125;        set &#123; number = min(newValue, maximum) &#125;    &#125;    init() &#123;        maximum = 12        number = 0    &#125;    init(wrappedValue: Int) &#123;        maximum = 12        number = min(wrappedValue, maximum)    &#125;    init(wrappedValue: Int, maximum: Int) &#123;        self.maximum = maximum        number = min(wrappedValue, maximum)    &#125;&#125;</code></pre><p>当你把包装器应用于属性且没有设定初始值时，Swift 使用 <code>init()</code> 构造器来设置包装器。举个例子：</p><pre><code>struct ZeroRectangle &#123;    @SmallNumber var height: Int    @SmallNumber var width: Int&#125;var zeroRectangle = ZeroRectangle()print(zeroRectangle.height, zeroRectangle.width)// 打印 &quot;0 0&quot;</code></pre><p>当你为属性指定初始值时，Swift 使用 <code>init(wrappedValue:)</code> 构造器来设置包装器。举个例子：</p><pre><code>struct UnitRectangle &#123;    @SmallNumber var height: Int = 1    @SmallNumber var width: Int = 1&#125;var unitRectangle = UnitRectangle()print(unitRectangle.height, unitRectangle.width)// 打印 &quot;1 1&quot;</code></pre><p>当你在自定义特性后面把实参写在括号里时，Swift 使用接受这些实参的构造器来设置包装器。举例来说，如果你提供初始值和最大值，Swift 使用 <code>init(wrappedValue:maximum:)</code> 构造器:</p><pre><code>struct NarrowRectangle &#123;    @SmallNumber(wrappedValue: 2, maximum: 5) var height: Int    @SmallNumber(wrappedValue: 3, maximum: 4) var width: Int&#125;var narrowRectangle = NarrowRectangle()print(narrowRectangle.height, narrowRectangle.width)// 打印 &quot;2 3&quot;narrowRectangle.height = 100narrowRectangle.width = 100print(narrowRectangle.height, narrowRectangle.width)// 打印 &quot;5 4&quot;</code></pre><p>通过将实参包含到属性包装器中，你可以设置包装器的初始状态，或者在创建包装器时传递其他的选项。这种语法是使用属性包装器最通用的方法。你可以为这个属性提供任何所需的实参，且它们将被传递给构造器。</p><p>当包含属性包装器实参时，你也可以使用赋值来指定初始值。Swift 将赋值视为 <code>wrappedValue</code> 参数，且使用接受被包含的实参的构造器。</p><pre><code>struct MixedRectangle &#123;    @SmallNumber var height: Int = 1    @SmallNumber(maximum: 9) var width: Int = 2&#125;var mixedRectangle = MixedRectangle()print(mixedRectangle.height)// 打印 &quot;1&quot;mixedRectangle.height = 20print(mixedRectangle.height)// 打印 &quot;12&quot;</code></pre><h3 id="4-2-从属性包装器中呈现一个值"><a href="#4-2-从属性包装器中呈现一个值" class="headerlink" title="4.2 从属性包装器中呈现一个值"></a>4.2 从属性包装器中呈现一个值</h3><p>除了被包装值，属性包装器可以通过定义被呈现值暴露出其他功能。除了以货币符号<code>（$）</code>开头，被呈现值的名称和被包装值是一样的。</p><blockquote><p>代码不能定义以 $ 开头的属性，所以被呈现值永远不会与定义的属性有冲突。</p></blockquote><p>在之前 <code>SmallNumber</code> 的例子中，如果你尝试把这个属性设置为一个很大的数值，属性包装器会在存储这个数值之前调整这个数值。以下的代码把被呈现值添加到 <code>SmallNumber</code> 结构体中来追踪在存储新值之前属性包装器是否为这个属性调整了新值。</p><pre><code>@propertyWrapperstruct SmallNumber &#123;    private var number: Int    var projectedValue: Bool    init() &#123;        self.number = 0        self.projectedValue = false    &#125;    var wrappedValue: Int &#123;        get &#123; return number &#125;        set &#123;            if newValue &gt; 12 &#123;                number = 12                projectedValue = true            &#125; else &#123;                number = newValue                projectedValue = false            &#125;        &#125;    &#125;&#125;struct SomeStructure &#123;    @SmallNumber var someNumber: Int&#125;var someStructure = SomeStructure()someStructure.someNumber = 4print(someStructure.$someNumber)// 打印 &quot;false&quot;someStructure.someNumber = 55print(someStructure.$someNumber)// 打印 &quot;true&quot;</code></pre><p>属性包装器可以返回任何类型的值作为它的被呈现值。</p><blockquote><p>需要暴露出更多信息的包装器可以返回其他数据类型的实例，或者可以返回自身来暴露出包装器的实例，并把其作为它的被呈现值。</p></blockquote><p>当从类型的一部分代码中访问被呈现值，例如属性 <code>getter</code> 或实例方法，你可以在属性名称之前省略 <code>self.</code>，就像访问其他属性一样。以下示例中的代码用 <code>$height</code> 和 <code>$width</code> 引用包装器 <code>height</code> 和 <code>width</code> 的被呈现值：</p><pre><code>enum Size &#123;    case small, large&#125;struct SizedRectangle &#123;    @SmallNumber var height: Int    @SmallNumber var width: Int    mutating func resize(to size: Size) -&gt; Bool &#123;        switch size &#123;        case .small:            height = 10            width = 20        case .large:            height = 100            width = 100        &#125;        return $height || $width    &#125;&#125;var sizedRectangle = SizedRectangle()print(sizedRectangle.resize(to: .large))// true width 和 height的值被调整过</code></pre><h2 id="5-全局变量和局部变量"><a href="#5-全局变量和局部变量" class="headerlink" title="5.全局变量和局部变量"></a>5.全局变量和局部变量</h2><ul><li>计算属性和观察属性所描述的功能也可以用于全局变量和局部变量</li><li>全局的常量或变量都是延迟计算的，跟延时加载存储属性相似，不同的地方在于，全局的常量或变量不需要标记 <code>lazy</code>修饰符。</li><li>局部范围的常量和变量从不延迟计算</li></ul><h2 id="6-类型属性"><a href="#6-类型属性" class="headerlink" title="6.类型属性"></a>6.类型属性</h2><p>实例属性：属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p><p>类型属性：类型本身属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份，所有实例共享。比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）</p><blockquote><p>注意：</p><ul><li>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</li><li>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。</li><li>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 <code>lazy</code> 修饰符。</li></ul></blockquote><h3 id="6-1-类型属性语法"><a href="#6-1-类型属性语法" class="headerlink" title="6.1 类型属性语法"></a>6.1 类型属性语法</h3><p>使用关键字 <code>static</code> 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。</p><pre><code>struct SomeStructure &#123;    static var storedTypeProperty = &quot;Some value.&quot;    static var computedTypeProperty: Int &#123;        return 1    &#125;&#125;enum SomeEnumeration &#123;    static var storedTypeProperty = &quot;Some value.&quot;    static var computedTypeProperty: Int &#123;        return 6    &#125;&#125;class SomeClass &#123;    static var storedTypeProperty = &quot;Some value.&quot;    static var computedTypeProperty: Int &#123;        return 27    &#125;    class var overrideableComputedTypeProperty: Int &#123;        return 107    &#125;&#125;</code></pre><h3 id="6-2-获取和设置类型属性的值"><a href="#6-2-获取和设置类型属性的值" class="headerlink" title="6.2 获取和设置类型属性的值"></a>6.2 获取和设置类型属性的值</h3><p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例：</p><pre><code>print(SomeStructure.storedTypeProperty)// 打印“Some value.”SomeStructure.storedTypeProperty = &quot;Another value.&quot;print(SomeStructure.storedTypeProperty)// 打印“Another value.”print(SomeEnumeration.computedTypeProperty)// 打印“6”print(SomeClass.computedTypeProperty)// 打印“27”</code></pre><p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，把两个声道结合来模拟立体声的音量：<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B1%9E%E6%80%A7_%E5%A3%B0%E9%81%93%E6%A8%A1%E5%9E%8B.png"></p><pre><code>struct AudioChannel &#123;    static let thresholdLevel = 10    static var maxInputLevelForAllChannels = 0    var currentLevel: Int = 0 &#123;        didSet &#123;            if currentLevel &gt; AudioChannel.thresholdLevel &#123;                // 将当前音量限制在阈值之内                currentLevel = AudioChannel.thresholdLevel            &#125;            if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels &#123;                // 存储当前音量作为新的最大输入音量                AudioChannel.maxInputLevelForAllChannels = currentLevel            &#125;        &#125;    &#125;&#125;var leftChannel = AudioChannel()var rightChannel = AudioChannel()leftChannel.currentLevel = 7print(leftChannel.currentLevel)// 输出“7”print(AudioChannel.maxInputLevelForAllChannels)// 输出“7”rightChannel.currentLevel = 11print(rightChannel.currentLevel)// 输出“10”print(AudioChannel.maxInputLevelForAllChannels)// 输出“10”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 类和结构体</title>
      <link href="posts/1367898931.html"/>
      <url>posts/1367898931.html</url>
      
        <content type="html"><![CDATA[<p>与其他编程语言不用的是，Swift并不要求你为自定义的结构体和类的接口与实现代码分别创建文件。你只需在单一的文件中定义一个结构体或者类，系统将会自动生成面向其他代码的外部接口。</p><h2 id="1-结构体和类对比"><a href="#1-结构体和类对比" class="headerlink" title="1.结构体和类对比"></a>1.结构体和类对比</h2><p>Swift中结构体和类有很多共同点。两者都可以：</p><ul><li>定义属性用于存储值</li><li>定义方法用于提供功能</li><li>定义下标操作用于通过下标语法访问它们的值</li><li>定义构造器用于设置初始值</li><li>通过扩展以增加默认实现之外的功能</li><li>遵循协议以提供某种标准功能</li></ul><p>与结构体相比，类还有如下的附加功能：</p><ul><li>继承：允许一个类继承另一个类的特征</li><li>类型转换：允许在运行时检查和解释一个类实例的类型</li><li>析构器：允许一个类实例释放任何其所被分配的资源</li><li>引用计数：允许对一个类的多次引用<br>类支持的附加功能是以增加复杂性为代价的，作为一般准则，优先使用结构体。</li></ul><h3 id="1-1-类型定义的语法"><a href="#1-1-类型定义的语法" class="headerlink" title="1.1 类型定义的语法"></a>1.1 类型定义的语法</h3><p><code>struct</code> 关键字引入结构体，<code>class</code>关键字引入类：</p><pre><code>struct Resolution &#123;    var width = 0    var height = 0&#125;class VideoMode &#123;    var resolution = Resolution()    var interlaced = false    var frameRate = 0.0    var name: String?&#125;</code></pre><blockquote><p>类和结构体以 <code>大驼峰法</code> 命名，属性和方法用 <code>小驼峰法</code> 命名</p></blockquote><h3 id="1-2-结构体和类的实例"><a href="#1-2-结构体和类的实例" class="headerlink" title="1.2 结构体和类的实例"></a>1.2 结构体和类的实例</h3><p><strong>结构体和类都使用构造器语法来创建新的实例</strong>。构造器语法的最简单形式是在结构体或者类的类型名称后跟随 <code>()</code>。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。</p><pre><code>let someResolution = Resolution()let someVideoMode = VideoMode()</code></pre><h3 id="1-3-属性访问"><a href="#1-3-属性访问" class="headerlink" title="1.3 属性访问"></a>1.3 属性访问</h3><p>可以通过使用 <code>点语法</code> 访问实例的属性:</p><pre><code>print(&quot;The width of someResolution is \(someResolution.width)&quot;)// 打印 &quot;The width of someResolution is 0&quot;</code></pre><p>可以访问子属性，如 <code>VideoMode</code> 中 <code>resolution</code> 属性的 <code>width</code> 属性：</p><pre><code>print(&quot;The width of someVideoMode is \(someVideoMode.resolution.width)&quot;)// 打印 &quot;The width of someVideoMode is 0&quot;</code></pre><p>可以使用点语法为可变属性赋值：</p><pre><code>someVideoMode.resolution.width = 1280print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)// 打印 &quot;The width of someVideoMode is now 1280&quot;</code></pre><h3 id="1-4-结构体类型的成员逐一构造器"><a href="#1-4-结构体类型的成员逐一构造器" class="headerlink" title="1.4 结构体类型的成员逐一构造器"></a>1.4 结构体类型的成员逐一构造器</h3><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p><pre><code>let vga = Resolution(width: 640, height: 480)</code></pre><blockquote><p>与结构体不同，类实例没有默认的成员逐一构造器</p></blockquote><h2 id="2-结构体和枚举是值类型"><a href="#2-结构体和枚举是值类型" class="headerlink" title="2.结构体和枚举是值类型"></a>2.结构体和枚举是值类型</h2><p>值类型是这样一种类型，当它被赋值给一个变量、常量或者被传递给一个函数时，其值会被拷贝。</p><p>Swift中所有的基本类型：整型、浮点数、布尔值、字符串、数组和字典，都是值类型，其底层也是使用结构体实现的。</p><p><strong>Swift中所有的结构体和枚举类型都是值类型</strong>。这意味着它们的实例，以及实例中所包含的任何值类型的属性，在代码中传递的时候都会被复制。</p><pre><code>let hd = Resolution(width: 1920, height: 1080)var cinema = hdcinema.width = 2048print(&quot;cinema is now  \(cinema.width) pixels wide&quot;)// 打印 &quot;cinema is now 2048 pixels wide&quot;print(&quot;hd is still \(hd.width) pixels wide&quot;)// 打印 &quot;hd is still 1920 pixels wide&quot;</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%80%BC%E6%8B%B7%E8%B4%9D.png"><br>枚举也遵循相同的行为准则：</p><pre><code>enum CompassPoint &#123;    case north, south, east, west    mutating func turnNorth() &#123;        self = .north    &#125;&#125;var currentDirection = CompassPoint.westlet rememberedDirection = currentDirectioncurrentDirection.turnNorth()print(&quot;The current direction is \(currentDirection)&quot;)print(&quot;The remembered direction is \(rememberedDirection)&quot;)// 打印 &quot;The current direction is north&quot;// 打印 &quot;The remembered direction is west&quot;</code></pre><blockquote><p>注意：标准库定义的集合，例如数组、字典和字符串，都对复制进行了优化以降低性能成本。新集合不会立即复制，而是跟原集合共享同一份内存，共享同样的元素。在集合的某个副本要被修改前，才会复制它的元素。</p></blockquote><h2 id="3-类是引用类型"><a href="#3-类是引用类型" class="headerlink" title="3.类是引用类型"></a>3.类是引用类型</h2><p>与值类型不同，引用类型在被赋值到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，使用的是已存在实例的引用，而不是其拷贝。</p><pre><code>let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = &quot;1080i&quot;tenEighty.frameRate = 25.0let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0print(&quot;The frameRate property of tenEighty is now \(tenEighty.frameRate)&quot;)// 打印 &quot;The frameRate property of theEighty is now 30.0&quot;</code></pre><p><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B_%E5%AE%9E%E4%BE%8B%E5%BC%95%E7%94%A8.png"></p><blockquote><p>注意：<code>tenEighty</code>和<code>alseTenEighty</code>被声明为常量而不是变量，但是依然可以改变 <code>tenEighty.frameRate</code> 和 <code>alsoTenEighty.frameRate</code>，这是因为 <code>tenEighty</code> 和 <code>alsoTenEighty</code> 这两个常量的值并未改变。它们并不“存储”这个 <code>VideoMode</code> 实例，而仅仅是对 <code>VideoMode</code> 实例的引用。所以，改变的是底层 <code>VideoMode</code> 实例的 <code>frameRate</code> 属性，而不是指向 <code>VideoMode</code> 的常量引用的值。</p></blockquote><h3 id="3-1-恒等运算符"><a href="#3-1-恒等运算符" class="headerlink" title="3.1 恒等运算符"></a>3.1 恒等运算符</h3><p>判定两个常量或者变量是否引用同一个类实例，可以用恒等运算符：</p><ul><li>相同 （<code>===</code>）</li><li>不相同 （<code>!==</code>）<pre><code>if tenEighty === alsoTenEighty &#123;  print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;)&#125;// 打印 &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</code></pre><blockquote><p>“相同”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同。“相同”表示两个类类型（class type）的常量或者变量引用同一个类实例。“等于”表示两个实例的值“相等”或“等价”，判定时要遵照设计者定义的评判标准。</p></blockquote></li></ul><h3 id="3-2-指针"><a href="#3-2-指针" class="headerlink" title="3.2 指针"></a>3.2 指针</h3><p>Swift 中引用了某个引用类型实例的常量或变量，与 C 语言中的指针类似，不过它并不直接指向某个内存地址，也不要求你使用星号（<code>*</code>）来表明你在创建一个引用。相反，Swift 中引用的定义方式与其它的常量或变量的一样。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 枚举</title>
      <link href="posts/1559514128.html"/>
      <url>posts/1559514128.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-枚举语法"><a href="#1-枚举语法" class="headerlink" title="1.枚举语法"></a>1.枚举语法</h2><p>使用 <code>enum</code> 关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p><pre><code>enum SomeEnumeration &#123;    // 枚举定义放在这里&#125;</code></pre><p>例如：</p><pre><code>enum CompassPoint &#123;    case north    case south    case east    case west&#125;</code></pre><p>枚举中定义的值（如 <code>north</code>，<code>south</code>，<code>east</code> 和 <code>west</code>）是这个枚举的成员值（或成员），可以使用 <code>case</code> 关键字来定义一个新的枚举成员值。</p><blockquote><p>与 <code>C</code> 和 <code>Objective-C</code> 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的 <code>CompassPoint</code> 例子中，<code>north</code>，<code>south</code>，<code>east</code> 和 <code>west</code> 不会被隐式地赋值为 <code>0</code>，<code>1</code>，<code>2</code> 和 <code>3</code>。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的 <code>CompassPoint</code> 类型。</p></blockquote><p>多个成员值可以出现在同一行上，用逗号隔开：</p><pre><code>enum Planet &#123;    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#125;</code></pre><p>可以使用 <code>点语法</code> 将枚举成员值初始化成 常量 或变量</p><pre><code>var directionToHead = CompassPoint.west</code></pre><p>当 <code>directionToHead</code>类型已知时，再次赋值时可以省略枚举类型名</p><pre><code>directionToHead = .east</code></pre><h2 id="2-使用-Switch-语句匹配枚举值"><a href="#2-使用-Switch-语句匹配枚举值" class="headerlink" title="2.使用 Switch 语句匹配枚举值"></a>2.使用 Switch 语句匹配枚举值</h2><pre><code>directionToHead = .southswitch directionToHead &#123;case .north:    print(&quot;Lots of planets have a north&quot;)case .south:    print(&quot;Watch out for penguins&quot;)case .east:    print(&quot;Where the sun rises&quot;)case .west:    print(&quot;Where the skies are blue&quot;)&#125;// 打印“Watch out for penguins”</code></pre><h2 id="3-枚举成员的遍历"><a href="#3-枚举成员的遍历" class="headerlink" title="3.枚举成员的遍历"></a>3.枚举成员的遍历</h2><p>令枚举遵循 <code>CaseIterable</code> 协议，Swift会生成一个 <code>allCases</code> 属性，用于表示一个包含枚举所有成员的集合：</p><pre><code>enum Beverage: CaseIterable &#123;    case coffee, tea, juice&#125;let numberOfChoices = Beverage.allCases.countprint(&quot;\(numberOfChoices) beverages available&quot;)// 打印“3 beverages available”</code></pre><p>使用 <code>for</code> 循环来遍历所有枚举成员</p><pre><code>for beverage in Beverage.allCases &#123;    print(beverage)&#125;// coffee// tea// juice</code></pre><h2 id="4-关联值"><a href="#4-关联值" class="headerlink" title="4.关联值"></a>4.关联值</h2><p>可以为枚举成员值设置一个常量或者变量，并在赋值之后查看这个值。有时候把其他类型的值和成员值一起存储起来会很有用，这额外的信息称为<code>关联值</code>，并且在代码中使用枚举成员时，还可以修改这个关联值。</p><p>可以定义Swift枚举来存储任意类型的关联值，而且每个枚举成员的关联值类型可以各不相同：</p><pre><code>enum Barcode &#123;    case upc(Int, Int, Int, Int)    //具有 (Int，Int，Int，Int) 类型关联值    case qrCode(String)    //具有 String 类型关联值&#125;</code></pre><p>这个定义不提供任何 <code>Int</code> 或 <code>String</code> 类型的关联值，只是定义了，当 <code>Barcode</code>常量和变量等于 <code>Barcode.upc</code> 或 <code>Barcode.qrCode</code>时，可以存储的关联值的类型。<br>可以使用任意一种条形码类型创建新的条形码：</p><pre><code>var productBarcode = Barcode.upc(8, 85909, 51226, 3)</code></pre><p>同一个商品可以被分配一个不同类型的条形码，例如：</p><pre><code>productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)</code></pre><p>可以在 <code>switch</code> 的 <code>case</code> 分支代码中提取每个关联值作为一个常量（用 <code>let</code> 前缀）或者作为一个变量（用 <code>var</code> 前缀）来使用</p><pre><code>switch productBarcode &#123;case .upc(let numberSystem, let manufacturer, let product, let check):    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)case .qrCode(let productCode):    print(&quot;QR code: \(productCode).&quot;)&#125;// 打印“QR code: ABCDEFGHIJKLMNOP.”</code></pre><p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，那么可以只在成员名称前标注一个 <code>let</code> 或者 <code>var</code>：</p><pre><code>switch productBarcode &#123;case let .upc(numberSystem, manufacturer, product, check):    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)case let .qrCode(productCode):    print(&quot;QR code: \(productCode).&quot;)&#125;// 打印“QR code: ABCDEFGHIJKLMNOP.”</code></pre><h2 id="5-原始值"><a href="#5-原始值" class="headerlink" title="5.原始值"></a>5.原始值</h2><p>枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同：</p><pre><code>enum ASCIIControlCharacter: Character &#123;    case tab = &quot;\t&quot;    case lineFeed = &quot;\n&quot;    case carriageReturn = &quot;\r&quot;&#125;</code></pre><p>原始值可以是字符串、字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p><blockquote><p>注意：原始值和关联值是不同的，原始值是在定义枚举时被预先填充的值。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p></blockquote><h3 id="5-1-原始值的隐式赋值"><a href="#5-1-原始值的隐式赋值" class="headerlink" title="5.1 原始值的隐式赋值"></a>5.1 原始值的隐式赋值</h3><p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p><ul><li>当使用整数作为原始值时，隐式赋值的值依次递增 <code>1</code>。如果第一个枚举成员没有设置原始值，其原始值将为 <code>0</code></li></ul><pre><code>enum Planet: Int &#123;    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125;</code></pre><ul><li>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称:</li></ul><pre><code>enum CompassPoint: String &#123;    case north, south, east, west&#125;</code></pre><ul><li>使用枚举成员的 <code>rawValue</code> 属性可以访问该枚举成员的原始值：</li></ul><pre><code>let earthsOrder = Planet.earth.rawValue// earthsOrder 值为 3let sunsetDirection = CompassPoint.west.rawValue// sunsetDirection 值为 &quot;west&quot;</code></pre><h3 id="5-2-使用原始值初始化枚举实例"><a href="#5-2-使用原始值初始化枚举实例" class="headerlink" title="5.2 使用原始值初始化枚举实例"></a>5.2 使用原始值初始化枚举实例</h3><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个 <code>rawValue</code> 的参数，参数类型即为原始值类型，返回值则是枚举成员或 <code>nil</code>。可以使用这个初始化方法来创建一个新的枚举实例：</p><pre><code>let possiblePlanet = Planet(rawValue: 7)// possiblePlanet 类型为 Planet? 值为 Planet.uranus</code></pre><p>然而，并非所有 <code>Int</code> 值都可以找到一个匹配的枚举成员。因此，原始值构造器总是返回一个可选的枚举成员。在上面的例子中，<code>possiblePlanet</code> 是 <code>Planet?</code> 类型，或者说“可选的 Planet”。</p><blockquote><p>注意：原始值构造器是一个失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。</p></blockquote><pre><code>let positionToFind = 11if let somePlanet = Planet(rawValue: positionToFind) &#123;    switch somePlanet &#123;    case .earth:        print(&quot;Mostly harmless&quot;)    default:        print(&quot;Not a safe place for humans&quot;)    &#125;&#125; else &#123;    print(&quot;There isn&#39;t a planet at position \(positionToFind)&quot;)&#125;// 打印“There isn&#39;t a planet at position 11”</code></pre><h2 id="6-递归枚举"><a href="#6-递归枚举" class="headerlink" title="6.递归枚举"></a>6.递归枚举</h2><p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。</p><ul><li>可以在枚举成员前加上 <code>indirect</code> 来表示该成员可递归。</li></ul><pre><code>enum ArithmeticExpression &#123;    case number(Int)    indirect case addition(ArithmeticExpression, ArithmeticExpression)    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125;</code></pre><ul><li>在枚举类型开头加上 <code>indirect</code> 关键字来表明它的所有成员都是可递归的：</li></ul><pre><code>indirect enum ArithmeticExpression &#123;    case number(Int)    case addition(ArithmeticExpression, ArithmeticExpression)    case multiplication(ArithmeticExpression, ArithmeticExpression)&#125;</code></pre><p>使用 <code>ArithmeticExpression </code>创建表达式 <code>(5+4)*2</code>:</p><pre><code>let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))</code></pre><p>下面是一个对算数表达式求值的函数：</p><pre><code>func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123;    switch expression &#123;    case let .number(value):        return value    case let .addition(left, right):        return evaluate(left) + evaluate(right)    case let .multiplication(left, right):        return evaluate(left) * evaluate(right)    &#125;&#125;print(evaluate(product))// 打印“18”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 闭包</title>
      <link href="posts/1519021199.html"/>
      <url>posts/1519021199.html</url>
      
        <content type="html"><![CDATA[<p>闭包是自包含的函数代码块，可以在代码中被传递和使用，类似于OC和C里面的<code>Block</code>。</p><p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用，被称为包裹常量和变量。Swift会为你管理在捕获过程中涉及到的所有内存操作。</p><p>在 <a href="/posts/383577965.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采用如下三种形式之一：</p><ul><li>全局函数是一个有名字但不会捕获任何值的闭包</li><li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li><li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量的匿名闭包</li></ul><p>Swift的闭包表达式拥有简洁的风格，主要优化如下：</p><ul><li>利用上下文推断参数和返回值类型</li><li>隐式返回单表达式闭包，即单表达式闭包可以省略 <code>return</code> 关键字</li><li>参数名称缩写</li><li>尾随闭包语法</li></ul><h2 id="1-闭包表达式"><a href="#1-闭包表达式" class="headerlink" title="1.闭包表达式"></a>1.闭包表达式</h2><p>闭包表达式是一种构建内联闭包的方式，它的语法简洁。在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式。下面通过对 <code>sorted(by:)</code> 这一个案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同功能</p><h3 id="1-1-排序方法"><a href="#1-1-排序方法" class="headerlink" title="1.1 排序方法"></a>1.1 排序方法</h3><p>Swift 标准库提供了名为 <code>sorted(by:)</code> 的方法，它会基于你提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code> 方法会返回一个与旧数组类型大小相同类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被 <code>sorted(by:)</code> 方法修改</p><pre><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func backward(_ s1: String, _ s2: String) -&gt; Bool &#123;    return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</code></pre><h3 id="1-2-闭包表达式语法"><a href="#1-2-闭包表达式语法" class="headerlink" title="1.2 闭包表达式语法"></a>1.2 闭包表达式语法</h3><p>闭包表达式语法有如下的一般形式：</p><pre><code>&#123; (parameters) -&gt; return type in    statements&#125;</code></pre><p><code>reversedNames</code> 以闭包表达式语法的形式实现为：</p><pre><code>reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in    return s1 &gt; s2&#125;)</code></pre><p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p><pre><code>reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; )</code></pre><blockquote><p>闭包表达式参数可以是 <code>in-out</code> 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值</p></blockquote><h3 id="1-3-根据上下文推断类型"><a href="#1-3-根据上下文推断类型" class="headerlink" title="1.3 根据上下文推断类型"></a>1.3 根据上下文推断类型</h3><p>闭包作为函数或者方法的参数时，Swift可以通过上下文推断闭包的参数和返回值的类型，则参数类型、返回箭头(<code>-&gt;</code>)以及围绕在参数周围的括号也可以被省略：</p><pre><code>reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; )</code></pre><blockquote><p>虽然可以简化闭包语法，但是仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则更鼓励采用完整格式的闭包</p></blockquote><h3 id="1-4-单表达式闭包的隐式返回"><a href="#1-4-单表达式闭包的隐式返回" class="headerlink" title="1.4 单表达式闭包的隐式返回"></a>1.4 单表达式闭包的隐式返回</h3><p>单行表达式闭包可以通过省略 <code>return</code> 关键字来隐式返回单行表达式的结果:</p><pre><code>reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</code></pre><h3 id="1-5-参数名称缩写"><a href="#1-5-参数名称缩写" class="headerlink" title="1.5 参数名称缩写"></a>1.5 参数名称缩写</h3><p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数。</p><p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code> 关键字也同样可以被省略。</p><pre><code>reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; )</code></pre><blockquote><p><code>$0</code> 和 <code>$1</code> 表示闭包中第一个和第二个 String 类型的参数</p></blockquote><h3 id="1-6-运算符方法"><a href="#1-6-运算符方法" class="headerlink" title="1.6 运算符方法"></a>1.6 运算符方法</h3><p>Swift 的 <code>String</code> 类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个 <code>String</code> 类型的参数并返回 <code>Bool</code> 类型的值。而这正好与 <code>sorted(by:)</code> 方法的参数需要的函数类型相符合，因此，可以简单地传递一个大于号：</p><pre><code>reversedNames = names.sorted(by: &gt;)</code></pre><h2 id="2-尾随闭包"><a href="#2-尾随闭包" class="headerlink" title="2.尾随闭包"></a>2.尾随闭包</h2><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p><pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123;    // 函数体部分&#125;// 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: &#123;    // 闭包主体部分&#125;)// 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() &#123;    // 闭包主体部分&#125;</code></pre><p>字符串排序闭包可以作为尾随闭包的形式改写为：</p><pre><code>reversedNames = names.sorted() &#123; $0 &gt; $1 &#125;</code></pre><p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 <code>()</code> 省略掉：</p><pre><code>reversedNames = names.sorted &#123; $0 &gt; $1 &#125;</code></pre><p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的 <code>Array</code> 类型有一个 <code>map(_:)</code> 方法，这个方法获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p><p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code> 方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p><pre><code>let digitNames = [    0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,    5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;]let numbers = [16, 58, 510]let strings = numbers.map &#123;    (number) -&gt; String in    var number = number    var output = &quot;&quot;    repeat &#123;        output = digitNames[number % 10]! + output        number /= 10    &#125; while number &gt; 0    return output&#125;// strings 常量被推断为字符串类型数组，即 [String]// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code></pre><blockquote><p>注意：字典 <code>digitNames</code> 下标后跟着一个叹号（<code>!</code>），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定 <code>number % 10</code> 总是 <code>digitNames</code> 字典的有效下标，因此叹号可以用于强制解包（force-unwrap）存储在下标的可选类型的返回值中的 <code>String</code> 类型的值。</p></blockquote><h2 id="3-值捕获"><a href="#3-值捕获" class="headerlink" title="3.值捕获"></a>3.值捕获</h2><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p><p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p><pre><code>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123;    var runningTotal = 0    func incrementer() -&gt; Int &#123;        runningTotal += amount        return runningTotal    &#125;    return incrementer&#125;let incrementByTen = makeIncrementer(forIncrement: 10)incrementByTen()// 返回的值为10incrementByTen()// 返回的值为20incrementByTen()// 返回的值为30let incrementBySeven = makeIncrementer(forIncrement: 7)incrementBySeven()// 返回的值为7incrementByTen()// 返回的值为40</code></pre><blockquote><p>注意：如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用。</p></blockquote><h2 id="4-闭包是引用类型"><a href="#4-闭包是引用类型" class="headerlink" title="4.闭包是引用类型"></a>4.闭包是引用类型</h2><p>上面的例子中，<code>incrementBySeven</code> 和 <code>incrementByTen</code> 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。</p><p>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用 <code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p><p>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p><pre><code>let alsoIncrementByTen = incrementByTenalsoIncrementByTen()// 返回的值为50</code></pre><h2 id="5-逃逸闭包"><a href="#5-逃逸闭包" class="headerlink" title="5.逃逸闭包"></a>5.逃逸闭包</h2><p><code>逃逸闭包</code>：当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，用 <code>@ escaping </code>关键字来定义。</p><pre><code>//将闭包保存在函数外部定义的变量中var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;    completionHandlers.append(completionHandler)&#125;</code></pre><p><code>逃逸闭包</code>显式地引用 <code>self</code>，非逃逸闭包则可以隐式引用 <code>self</code>。</p><pre><code>func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123;    closure()&#125;class SomeClass &#123;    var x = 10    func doSomething() &#123;        someFunctionWithEscapingClosure &#123; self.x = 100 &#125;        someFunctionWithNonescapingClosure &#123; x = 200 &#125;    &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x)// 打印出“200”completionHandlers.first?()print(instance.x)// 打印出“100”</code></pre><h2 id="6-自动闭包"><a href="#6-自动闭包" class="headerlink" title="6.自动闭包"></a>6.自动闭包</h2><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值，这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显示的闭包。</p><p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code> 函数接受自动闭包作为它的 <code>condition</code> 参数和 <code>message</code> 参数；它的 <code>condition</code> 参数仅会在 <code>debug</code> 模式下被求值，它的 <code>message</code> 参数仅当 <code>condition</code> 参数为 <code>false</code> 时被计算求值。</p><p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。</p><pre><code>var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]print(customersInLine.count)// 打印出“5”//customerProvider 的类型不是 String，而是 () -&gt; Stringlet customerProvider = &#123; customersInLine.remove(at: 0) &#125;print(customersInLine.count)// 打印出“5”print(&quot;Now serving \(customerProvider())!&quot;)// Prints &quot;Now serving Chris!&quot;print(customersInLine.count)// 打印出“4”</code></pre><p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为：</p><pre><code>// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func serve(customer customerProvider: () -&gt; String) &#123;    print(&quot;Now serving \(customerProvider())!&quot;)&#125;serve(customer: &#123; customersInLine.remove(at: 0) &#125; )// 打印出“Now serving Alex!”</code></pre><p>通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包，而不是接受一个显示的闭包，也可以实现相同的效果：</p><pre><code>// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]func serve(customer customerProvider: @autoclosure () -&gt; String) &#123;    print(&quot;Now serving \(customerProvider())!&quot;)&#125;serve(customer: customersInLine.remove(at: 0))// 打印“Now serving Ewa!”</code></pre><blockquote><p>注意：过度使用 <code>autoclosures</code> 会让代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延时执行的。</p></blockquote><p>如果想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosures</code>和<code>@escaping</code>属性。</p><pre><code>// customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;]var customerProviders: [() -&gt; String] = []func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123;    customerProviders.append(customerProvider)&#125;collectCustomerProviders(customersInLine.remove(at: 0))collectCustomerProviders(customersInLine.remove(at: 0))print(&quot;Collected \(customerProviders.count) closures.&quot;)// 打印“Collected 2 closures.”for customerProvider in customerProviders &#123;    print(&quot;Now serving \(customerProvider())!&quot;)&#125;// 打印“Now serving Barry!”// 打印“Now serving Daniella!”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 函数</title>
      <link href="posts/383577965.html"/>
      <url>posts/383577965.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-函数的定义与调用"><a href="#1-函数的定义与调用" class="headerlink" title="1.函数的定义与调用"></a>1.函数的定义与调用</h2><pre><code>//定义func 函数名(参数名: 参数类型, 参数名: 参数类型, ...) -&gt; 返回类型 &#123;    ...    return ...&#125;//调用函数名(参数名: 实参)</code></pre><h2 id="2-函数参数与返回值"><a href="#2-函数参数与返回值" class="headerlink" title="2.函数参数与返回值"></a>2.函数参数与返回值</h2><h3 id="2-1-无参数函数"><a href="#2-1-无参数函数" class="headerlink" title="2.1 无参数函数"></a>2.1 无参数函数</h3><pre><code>func sayHelloWorld() -&gt; String &#123;    return &quot;hello, world&quot;&#125;print(sayHelloWorld())// 打印“hello, world”</code></pre><h3 id="2-2-多参数函数"><a href="#2-2-多参数函数" class="headerlink" title="2.2 多参数函数"></a>2.2 多参数函数</h3><pre><code>func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123;    if alreadyGreeted &#123;        return greetAgain(person: person)    &#125; else &#123;        return greet(person: person)    &#125;&#125;print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))// 打印“Hello again, Tim!”</code></pre><h3 id="2-3-无返回值函数"><a href="#2-3-无返回值函数" class="headerlink" title="2.3 无返回值函数"></a>2.3 无返回值函数</h3><pre><code>func printAndCount(string: String) -&gt; Int &#123;    print(string)    return string.count&#125;func printWithoutCounting(string: String) &#123;    let _ = printAndCount(string: string)&#125;printAndCount(string: &quot;hello, world&quot;)// 打印“hello, world”，并且返回值 12printWithoutCounting(string: &quot;hello, world&quot;)// 打印“hello, world”，但是没有返回任何值</code></pre><blockquote><p>返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译时错误。</p></blockquote><h3 id="2-4-多重返回值函数"><a href="#2-4-多重返回值函数" class="headerlink" title="2.4 多重返回值函数"></a>2.4 多重返回值函数</h3><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123;    var currentMin = array[0]    var currentMax = array[0]    for value in array[1..&lt;array.count] &#123;        if value &lt; currentMin &#123;            currentMin = value        &#125; else if value &gt; currentMax &#123;            currentMax = value        &#125;    &#125;    return (currentMin, currentMax)&#125;let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)// 打印“min is -6 and max is 109”</code></pre><h3 id="2-5-可选元组返回类型"><a href="#2-5-可选元组返回类型" class="headerlink" title="2.5 可选元组返回类型"></a>2.5 可选元组返回类型</h3><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123;    if array.isEmpty &#123; return nil &#125;    var currentMin = array[0]    var currentMax = array[0]    for value in array[1..&lt;array.count] &#123;        if value &lt; currentMin &#123;            currentMin = value        &#125; else if value &gt; currentMax &#123;            currentMax = value        &#125;    &#125;    return (currentMin, currentMax)&#125;//使用可选绑定来检查 minMax(array:) 函数返回的是一个存在的元组值还是 nilif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123;    print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)&#125;// 打印“min is -6 and max is 109”</code></pre><h3 id="2-6-隐式返回的函数"><a href="#2-6-隐式返回的函数" class="headerlink" title="2.6 隐式返回的函数"></a>2.6 隐式返回的函数</h3><p>如果一个函数的整个函数体是一个单行表达式，这个函数可以隐式地返回这个表达式</p><pre><code>func greeting(for person: String) -&gt; String &#123;    &quot;Hello, &quot; + person + &quot;!&quot;&#125;print(greeting(for: &quot;Dave&quot;))// 打印 &quot;Hello, Dave!&quot;func anotherGreeting(for person: String) -&gt; String &#123;    return &quot;Hello, &quot; + person + &quot;!&quot;&#125;print(anotherGreeting(for: &quot;Dave&quot;))// 打印 &quot;Hello, Dave!&quot;</code></pre><blockquote><p>任何一个可以被写成一行 <code>return</code> 语句的函数都可以忽略 <code>return</code>。</p></blockquote><h2 id="3-函数参数标签和参数名称"><a href="#3-函数参数标签和参数名称" class="headerlink" title="3.函数参数标签和参数名称"></a>3.函数参数标签和参数名称</h2><p>每个函数参数都有一个参数标签以及一个参数名称。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情况下，函数参数使用参数名称来作为它们的参数标签。</p><pre><code>func someFunction(firstParameterName: Int, secondParameterName: Int) &#123;    // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值&#125;someFunction(firstParameterName: 1, secondParameterName: 2)</code></pre><h3 id="3-1-指定参数标签"><a href="#3-1-指定参数标签" class="headerlink" title="3.1 指定参数标签"></a>3.1 指定参数标签</h3><p>可以在参数名称前指定它的参数标签，中间以空格分隔</p><pre><code>func someFunction(argumentLabel parameterName: Int) &#123;    // 在函数体内，parameterName 代表参数值&#125;func greet(person: String, from hometown: String) -&gt; String &#123;    return &quot;Hello \(person)!  Glad you could visit from \(hometown).&quot;&#125;print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))// 打印“Hello Bill!  Glad you could visit from Cupertino.”</code></pre><h3 id="3-2-忽略参数标签"><a href="#3-2-忽略参数标签" class="headerlink" title="3.2 忽略参数标签"></a>3.2 忽略参数标签</h3><p>如果不希望为某个参数添加一个标签，可以使用一个下划线（<code>_</code>）来代替一个明确的参数标签。</p><pre><code>func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123;     // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值&#125;someFunction(1, secondParameterName: 2)</code></pre><h3 id="3-3-默认参数值"><a href="#3-3-默认参数值" class="headerlink" title="3.3 默认参数值"></a>3.3 默认参数值</h3><pre><code>func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123;    // 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault = 6someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12</code></pre><blockquote><p>将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。</p></blockquote><h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><p>一个可变参数（variadic parameter）可以接受零个或多个值，通过在变量类型名后面加入（<code>...</code>）的方式来定义可变参数，可变参数的传入值在函数体中变为此类型的一个数组。</p><pre><code>func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;    var total: Double = 0    for number in numbers &#123;        total += number    &#125;    return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// 返回 3.0, 是这 5 个数的平均数。arithmeticMean(3, 8.25, 18.75)// 返回 10.0, 是这 3 个数的平均数。</code></pre><blockquote><p>注意：一个函数最多只能拥有一个可变参数</p></blockquote><h3 id="3-5-输入输出参数"><a href="#3-5-输入输出参数" class="headerlink" title="3.5 输入输出参数"></a>3.5 输入输出参数</h3><p>使用 <code>inout</code> 关键字定义 <code>输入输出参数</code></p><pre><code>func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123;    let temporaryA = a    a = b    b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)// 打印“someInt is now 107, and anotherInt is now 3”</code></pre><blockquote><p>注意：</p><ul><li>函数参数默认是常量，在函数体中不能被更改。如果要修改函数参数，则把参数定义为 <code>输入输出参数</code></li><li><code>输入输出参数</code>值在函数中被修改，替换原来的值并传出函数</li><li>只能传入变量，不能传入常量或者字面量</li><li>在函数调用时，需要在参数名前加 <code>&amp;</code></li><li><code>输入输出参数</code>不能有默认值，而且可变参数不能用 <code>inout</code> 标记。</li></ul></blockquote><h2 id="4-函数类型"><a href="#4-函数类型" class="headerlink" title="4.函数类型"></a>4.函数类型</h2><p>每个函数都有种特定的函数类型，函数的类型由函数的参数类型和返回类型组成。</p><pre><code>func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123;    return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123;    return a * b&#125;//这两个函数的类型是 (Int, Int) -&gt; Int//可以解读为:“这个函数类型有两个 Int 型的参数并返回一个 Int 型的值”</code></pre><h3 id="4-1-使用函数类型"><a href="#4-1-使用函数类型" class="headerlink" title="4.1 使用函数类型"></a>4.1 使用函数类型</h3><ul><li><p>可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</p><pre><code>var mathFunction: (Int, Int) -&gt; Int = addTwoInts</code></pre></li><li><p>有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样</p><pre><code>mathFunction = multiplyTwoIntsprint(&quot;Result: \(mathFunction(2, 3))&quot;)// Prints &quot;Result: 6&quot;</code></pre></li><li><p>当赋值一个函数给常量或变量时，可以让 Swift 来推断其函数类型</p><pre><code>let anotherMathFunction = addTwoInts// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</code></pre></li></ul><h3 id="4-2-函数类型作为参数类型"><a href="#4-2-函数类型作为参数类型" class="headerlink" title="4.2 函数类型作为参数类型"></a>4.2 函数类型作为参数类型</h3><p>可以用 <code>(Int, Int) -&gt; Int</code> 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</p><pre><code>func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123;    print(&quot;Result: \(mathFunction(a, b))&quot;)&#125;printMathResult(addTwoInts, 3, 5)// 打印“Result: 8”printMathResult(addTwoInts(_:_:), 4, 6)// 打印“Result: 10”</code></pre><h3 id="4-3-函数类型作为返回类型"><a href="#4-3-函数类型作为返回类型" class="headerlink" title="4.3 函数类型作为返回类型"></a>4.3 函数类型作为返回类型</h3><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（<code>-&gt;</code>）后写一个完整的函数类型。</p><pre><code>func stepForward(_ input: Int) -&gt; Int &#123;    return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123;    return input - 1&#125;func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;    return backward ? stepBackward : stepForward&#125;var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero 现在指向 stepBackward() 函数。print(&quot;Counting to zero:&quot;)// Counting to zero:while currentValue != 0 &#123;    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)&#125;print(&quot;zero!&quot;)// 3...// 2...// 1...// zero!</code></pre><h2 id="5-嵌套函数"><a href="#5-嵌套函数" class="headerlink" title="5.嵌套函数"></a>5.嵌套函数</h2><p>把函数定义在别的函数体中，称作 <code>嵌套函数</code>。</p><p>默认情况下，<code>嵌套函数</code>是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个<code>嵌套函数</code>，使得这个函数可以在其他域中被使用。</p><pre><code>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123;    func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125;    func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125;    return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 &#123;    print(&quot;\(currentValue)... &quot;)    currentValue = moveNearerToZero(currentValue)&#125;print(&quot;zero!&quot;)// -4...// -3...// -2...// -1...// zero!</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 控制流</title>
      <link href="posts/2571907037.html"/>
      <url>posts/2571907037.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-For-in循环"><a href="#1-For-in循环" class="headerlink" title="1.For-in循环"></a>1.For-in循环</h2><p>可以使用 <code>for-in</code> 循环来遍历一个集合中的所有元素，例如数组中的元素、范围内的数字或者字符串中的字符。</p><h3 id="1-1-For-in遍历数组"><a href="#1-1-For-in遍历数组" class="headerlink" title="1.1 For-in遍历数组"></a>1.1 For-in遍历数组</h3><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names &#123;    print(&quot;Hello, \(name)!&quot;)&#125;// Hello, Anna!// Hello, Alex!// Hello, Brian!// Hello, Jack!</code></pre><h3 id="1-2-For-in遍历字典"><a href="#1-2-For-in遍历字典" class="headerlink" title="1.2 For-in遍历字典"></a>1.2 For-in遍历字典</h3><pre><code>let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]for (animalName, legCount) in numberOfLegs &#123;    print(&quot;\(animalName)s have \(legCount) legs&quot;)&#125;// cats have 4 legs// ants have 6 legs// spiders have 8 legs</code></pre><h3 id="1-3-For-in遍历数字范围"><a href="#1-3-For-in遍历数字范围" class="headerlink" title="1.3 For-in遍历数字范围"></a>1.3 For-in遍历数字范围</h3><pre><code>for index in 1...5 &#123;    print(&quot;\(index) times 5 is \(index * 5)&quot;)&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25</code></pre><p>如果不需要区间序列内每一项的值，可以使用下划线（<code>_</code>）替代变量名来忽略这个值:</p><pre><code>let base = 3let power = 10var answer = 1for _ in 1...power &#123;    answer *= base&#125;print(&quot;\(base) to the power of \(power) is \(answer)&quot;)// 输出“3 to the power of 10 is 59049”</code></pre><p>半开区间使用 <code>stride(from:to:by:)</code> 函数跳过不需要的标记:</p><pre><code>let minutes = 60for tickMark in 0..&lt;minutes &#123;    // 每一分钟都渲染一个刻度线（60次）&#125;let minuteInterval = 5for tickMark in stride(from: 0, to: minutes, by: minuteInterval) &#123;    // 每5分钟渲染一个刻度线（0, 5, 10, 15 ... 45, 50, 55）&#125;</code></pre><p>在闭区间使用 <code>stride(from:through:by:)</code>函数跳过不需要的标记:</p><pre><code>let hours = 12let hourInterval = 3for tickMark in stride(from: 3, through: hours, by: hourInterval) &#123;    // 每3小时渲染一个刻度线（3, 6, 9, 12）&#125;</code></pre><h2 id="2-While-循环"><a href="#2-While-循环" class="headerlink" title="2.While 循环"></a>2.While 循环</h2><p><code>while</code> 循环会一直运行一段语句直到条件变成 <code>false</code>。这类循环适合使用在第一次迭代前，迭代次数未知的情况下。Swift 提供两种 <code>while</code> 循环形式：</p><ul><li><code>while</code> 循环，先判断条件，符合则执行循环；</li><li><code>repeat-while</code> 循环，先执行循环，再判断条件是否符合，至少执行一次循环。</li></ul><h2 id="3-条件语句"><a href="#3-条件语句" class="headerlink" title="3.条件语句"></a>3.条件语句</h2><h3 id="3-1-If"><a href="#3-1-If" class="headerlink" title="3.1 If"></a>3.1 If</h3><pre><code>temperatureInFahrenheit = 90if temperatureInFahrenheit &lt;= 32 &#123;    print(&quot;It&#39;s very cold. Consider wearing a scarf.&quot;)&#125; else if temperatureInFahrenheit &gt;= 86 &#123;    print(&quot;It&#39;s really warm. Don&#39;t forget to wear sunscreen.&quot;)&#125; else &#123;    print(&quot;It&#39;s not that cold. Wear a t-shirt.&quot;)&#125;// 输出“It&#39;s really warm. Don&#39;t forget to wear sunscreen.”</code></pre><h3 id="3-2-Switch"><a href="#3-2-Switch" class="headerlink" title="3.2 Switch"></a>3.2 Switch</h3><p><code>switch</code> 语句最简单的形式就是把某个值与一个或若干个相同类型的值作比较:</p><pre><code>switch some value to consider &#123;case value 1:    respond to value 1case value 2,    value 3:    respond to value 2 or 3default:    otherwise, do something else&#125;</code></pre><h4 id="3-2-1-不存在隐式的贯穿"><a href="#3-2-1-不存在隐式的贯穿" class="headerlink" title="3.2.1 不存在隐式的贯穿"></a>3.2.1 不存在隐式的贯穿</h4><p>在 Swift 中，当匹配的 <code>case</code> 分支中的代码执行完毕后，程序会终止 <code>switch</code> 语句，而不会继续执行下一个 <code>case</code> 分支</p><blockquote><p>不需要在 case 分支中显式地使用 <code>break</code> 语句，但是也可以使用 <code>break</code> </p></blockquote><p>每一个 <code>case</code> 分支都必须包含至少一条语句，否则代码无效：</p><pre><code>let anotherCharacter: Character = &quot;a&quot;switch anotherCharacter &#123;case &quot;a&quot;: // 无效，这个分支下面没有语句case &quot;A&quot;:    print(&quot;The letter A&quot;)default:    print(&quot;Not the letter A&quot;)&#125;// 这段代码会报编译错误</code></pre><h4 id="3-2-2-区间匹配"><a href="#3-2-2-区间匹配" class="headerlink" title="3.2.2 区间匹配"></a>3.2.2 区间匹配</h4><p><code>case</code> 分支的模式也可以是一个值的区间</p><pre><code>let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;let naturalCount: Stringswitch approximateCount &#123;case 0:    naturalCount = &quot;no&quot;case 1..&lt;5:    naturalCount = &quot;a few&quot;case 5..&lt;12:    naturalCount = &quot;several&quot;case 12..&lt;100:    naturalCount = &quot;dozens of&quot;case 100..&lt;1000:    naturalCount = &quot;hundreds of&quot;default:    naturalCount = &quot;many&quot;&#125;print(&quot;There are \(naturalCount) \(countedThings).&quot;)// 输出“There are dozens of moons orbiting Saturn.”</code></pre><h4 id="3-2-3-元组"><a href="#3-2-3-元组" class="headerlink" title="3.2.3 元组"></a>3.2.3 元组</h4><p>可以使用元组在同一个 <code>switch</code> 语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（<code>_</code>）来匹配所有可能的值。</p><pre><code>let somePoint = (1, 1)switch somePoint &#123;case (0, 0):    print(&quot;\(somePoint) is at the origin&quot;)case (_, 0):    print(&quot;\(somePoint) is on the x-axis&quot;)case (0, _):    print(&quot;\(somePoint) is on the y-axis&quot;)case (-2...2, -2...2):    print(&quot;\(somePoint) is inside the box&quot;)default:    print(&quot;\(somePoint) is outside of the box&quot;)&#125;// 输出“(1, 1) is inside the box”</code></pre><h4 id="3-2-4-值绑定"><a href="#3-2-4-值绑定" class="headerlink" title="3.2.4 值绑定"></a>3.2.4 值绑定</h4><p><code>case</code> 分支允许将匹配的值声明为临时常量或变量，并且在 <code>case</code> 分支体内使用:</p><pre><code>let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0):    print(&quot;on the x-axis with an x value of \(x)&quot;)case (0, let y):    print(&quot;on the y-axis with a y value of \(y)&quot;)case let (x, y):    print(&quot;somewhere else at (\(x), \(y))&quot;)&#125;// 输出“on the x-axis with an x value of 2”</code></pre><h4 id="3-2-5-where"><a href="#3-2-5-where" class="headerlink" title="3.2.5 where"></a>3.2.5 where</h4><p><code>case</code> 分支的模式可以使用 <code>where</code> 语句来判断额外的条件:</p><pre><code>let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y:    print(&quot;(\(x), \(y)) is on the line x == y&quot;)case let (x, y) where x == -y:    print(&quot;(\(x), \(y)) is on the line x == -y&quot;)case let (x, y):    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)&#125;// 输出“(1, -1) is on the line x == -y”</code></pre><h4 id="3-2-6-复合型-Cases"><a href="#3-2-6-复合型-Cases" class="headerlink" title="3.2.6 复合型 Cases"></a>3.2.6 复合型 Cases</h4><p>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个 <code>case</code> 后面，并且用逗号隔开，并且，如果匹配列表过长，还可以分行书写：</p><pre><code>let someCharacter: Character = &quot;e&quot;switch someCharacter &#123;case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:    print(&quot;\(someCharacter) is a vowel&quot;)case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,     &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:    print(&quot;\(someCharacter) is a consonant&quot;)default:    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)&#125;// 输出“e is a vowel”</code></pre><h2 id="4-控制转移语句"><a href="#4-控制转移语句" class="headerlink" title="4.控制转移语句"></a>4.控制转移语句</h2><p>控制转移语句改变代码的执行顺序，通过它可以实现代码的跳转。Swift 有五种控制转移语句：</p><ul><li><code>continue</code></li><li><code>break</code></li><li><code>fallthrough</code></li><li><code>return</code></li><li><code>throw</code></li></ul><h3 id="4-1-continue"><a href="#4-1-continue" class="headerlink" title="4.1 continue"></a>4.1 continue</h3><p><code>continue</code> 语句：停止本次循环，开始下次循环，不是停止整个循环体</p><pre><code>let puzzleInput = &quot;great minds think alike&quot;var puzzleOutput = &quot;&quot;for character in puzzleInput &#123;    switch character &#123;    case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;:        continue    default:        puzzleOutput.append(character)    &#125;&#125;print(puzzleOutput)// 输出“grtmndsthnklk”</code></pre><h3 id="4-2-Break"><a href="#4-2-Break" class="headerlink" title="4.2 Break"></a>4.2 Break</h3><p><code>break</code> 语句会立刻结束整个控制流的执行</p><h4 id="4-2-1-循环语句中的break"><a href="#4-2-1-循环语句中的break" class="headerlink" title="4.2.1 循环语句中的break"></a>4.2.1 循环语句中的break</h4><p>循环语句中的 <code>break</code>会立刻中断该循环体的执行。</p><h4 id="4-2-2-Switch语句中的break"><a href="#4-2-2-Switch语句中的break" class="headerlink" title="4.2.2 Switch语句中的break"></a>4.2.2 Switch语句中的break</h4><p>当在一个 <code>switch</code> 代码块中使用 <code>break</code> 时，会立即中断该 <code>switch</code> 代码块的执行。<code>break</code> 也可以被用来忽略一个或多个分支。</p><pre><code>let numberSymbol: Character = &quot;三&quot;  // 简体中文里的数字 3var possibleIntegerValue: Int?switch numberSymbol &#123;case &quot;1&quot;, &quot;١&quot;, &quot;一&quot;, &quot;๑&quot;:    possibleIntegerValue = 1case &quot;2&quot;, &quot;٢&quot;, &quot;二&quot;, &quot;๒&quot;:    possibleIntegerValue = 2case &quot;3&quot;, &quot;٣&quot;, &quot;三&quot;, &quot;๓&quot;:    possibleIntegerValue = 3case &quot;4&quot;, &quot;٤&quot;, &quot;四&quot;, &quot;๔&quot;:    possibleIntegerValue = 4default:    break&#125;if let integerValue = possibleIntegerValue &#123;    print(&quot;The integer value of \(numberSymbol) is \(integerValue).&quot;)&#125; else &#123;    print(&quot;An integer value could not be found for \(numberSymbol).&quot;)&#125;// 输出“The integer value of 三 is 3.”</code></pre><h3 id="4-3-贯穿（Fallthrough）"><a href="#4-3-贯穿（Fallthrough）" class="headerlink" title="4.3 贯穿（Fallthrough）"></a>4.3 贯穿（Fallthrough）</h3><p><code>fallthrough</code> 使得 <code>Switch</code>语句执行完上一个 <code>case</code> 分支之后，继续执行下一个 <code>case</code> 分支</p><pre><code>let integerToDescribe = 5var description = &quot;The number \(integerToDescribe) is&quot;switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19:    description += &quot; a prime number, and also&quot;    fallthroughdefault:    description += &quot; an integer.&quot;&#125;print(description)// 输出“The number 5 is a prime number, and also an integer.”</code></pre><h3 id="4-4-带标签的语句"><a href="#4-4-带标签的语句" class="headerlink" title="4.4 带标签的语句"></a>4.4 带标签的语句</h3><p>使用<code>标签</code>（statement label）来标记一个循环体或者条件语句，对于一个条件语句，你可以使用 <code>break</code> 加标签的方式，来结束这个被标记的语句。对于一个循环语句，你可以使用 <code>break</code> 或者 <code>continue</code> 加标签，来结束或者继续这条被标记语句的执行。</p><pre><code> label name: while condition &#123;     statements &#125;</code></pre><p>蛇和梯子小游戏：</p><pre><code>let finalSquare = 25var board = [Int](repeating: 0, count: finalSquare + 1)board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0//必须刚好落在第 25 个方块中gameLoop: while square != finalSquare &#123;    diceRoll += 1    if diceRoll == 7 &#123; diceRoll = 1 &#125;    switch square + diceRoll &#123;    case finalSquare:        // 骰子数刚好使玩家移动到最终的方格里，游戏结束。        break gameLoop    case let newSquare where newSquare &gt; finalSquare:        // 骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子        continue gameLoop    default:        // 合法移动，做正常的处理        square += diceRoll        square += board[square]    &#125;&#125;print(&quot;Game over!&quot;)</code></pre><h2 id="5-提前退出"><a href="#5-提前退出" class="headerlink" title="5.提前退出"></a>5.提前退出</h2><p>像 <code>if</code> 语句一样，<code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于<code> if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 从句，如果条件不为真则执行 <code>else</code> 从句中的代码</p><pre><code>func greet(person: [String: String]) &#123;    guard let name = person[&quot;name&quot;] else &#123;        return    &#125;    print(&quot;Hello \(name)!&quot;)    guard let location = person[&quot;location&quot;] else &#123;        print(&quot;I hope the weather is nice near you.&quot;)        return    &#125;    print(&quot;I hope the weather is nice in \(location).&quot;)&#125;greet(person: [&quot;name&quot;: &quot;John&quot;])// 输出“Hello John!”// 输出“I hope the weather is nice near you.”greet(person: [&quot;name&quot;: &quot;Jane&quot;, &quot;location&quot;: &quot;Cupertino&quot;])// 输出“Hello Jane!”// 输出“I hope the weather is nice in Cupertino.”</code></pre><h2 id="6-检测API可用性"><a href="#6-检测API可用性" class="headerlink" title="6.检测API可用性"></a>6.检测API可用性</h2><pre><code>if #available(平台名称 版本号, ..., *) &#123;    APIs 可用，语句将执行&#125; else &#123;    APIs 不可用，语句将不执行&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 集合类型</title>
      <link href="posts/3590693742.html"/>
      <url>posts/3590693742.html</url>
      
        <content type="html"><![CDATA[<p>Swift中的集合类型：<code>数组(Array)</code>、<code>集合(Set)</code>、<code>字典(Dictionary)</code>。<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="集合关系"></p><blockquote><p>集合分可变和不可变，可变集合：创建之后可以增加、删除、改变数据项，不可变集合：大小和内容都不可改变</p></blockquote><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="1-1-数组的简单语法"><a href="#1-1-数组的简单语法" class="headerlink" title="1.1 数组的简单语法"></a>1.1 数组的简单语法</h3><p>Swift中数组的完整写法为：<code>Array&lt;Element&gt;</code> 或者 <code>Array[Element]</code>。</p><h3 id="1-2-创建数组"><a href="#1-2-创建数组" class="headerlink" title="1.2 创建数组"></a>1.2 创建数组</h3><h4 id="1-2-1-创建空数组"><a href="#1-2-1-创建空数组" class="headerlink" title="1.2.1 创建空数组"></a>1.2.1 创建空数组</h4><pre><code>var someInts = [Int]()var someInts: [Int] = []</code></pre><h4 id="1-2-2-创建带有默认值的数组"><a href="#1-2-2-创建带有默认值的数组" class="headerlink" title="1.2.2 创建带有默认值的数组"></a>1.2.2 创建带有默认值的数组</h4><pre><code>var threeDoubles = Array(repeating: 0.0, count: 3) //[0.0, 0.0, 0.0]</code></pre><h4 id="1-2-3-通过两个数组相加创建一个数组"><a href="#1-2-3-通过两个数组相加创建一个数组" class="headerlink" title="1.2.3 通过两个数组相加创建一个数组"></a>1.2.3 通过两个数组相加创建一个数组</h4><pre><code>var threeDoubles = Array(repeating: 0.0, count: 3) //[0.0, 0.0, 0.0]var anotherThreeDoubles = Array(repeating: 2.5, count: 3) //[2.5, 2.5, 2.5]var sixDoubles = threeDoubles + anotherThreeDoubles //[0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</code></pre><h4 id="1-2-4-用数组字面量构造数组"><a href="#1-2-4-用数组字面量构造数组" class="headerlink" title="1.2.4 用数组字面量构造数组"></a>1.2.4 用数组字面量构造数组</h4><pre><code>var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]等价于var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]</code></pre><h3 id="1-3-访问和修改数组"><a href="#1-3-访问和修改数组" class="headerlink" title="1.3 访问和修改数组"></a>1.3 访问和修改数组</h3><h4 id="1-3-1-count获取数组中元素数量"><a href="#1-3-1-count获取数组中元素数量" class="headerlink" title="1.3.1 count获取数组中元素数量"></a>1.3.1 count获取数组中元素数量</h4><pre><code>print(&quot;The shopping list contains \(shoppingList.count) items.&quot;)</code></pre><h4 id="1-3-2-isEmpty属性判空"><a href="#1-3-2-isEmpty属性判空" class="headerlink" title="1.3.2 isEmpty属性判空"></a>1.3.2 isEmpty属性判空</h4><p>使用布尔属性 <code>isEmpty</code> 检查 <code>count</code> 属性是否为<code>0</code>：</p><pre><code>if shoppingList.isEmpty &#123;    print(&quot;The shopping list is empty.&quot;)&#125; else &#123;    print(&quot;The shopping list is not empty.&quot;)&#125;// 打印“The shopping list is not empty.”（shoppinglist 不是空的）</code></pre><h4 id="1-3-3-获取数组中元素"><a href="#1-3-3-获取数组中元素" class="headerlink" title="1.3.3 获取数组中元素"></a>1.3.3 获取数组中元素</h4><p>使用下标语法获取数组中的元素：</p><pre><code>var firstItem = shoppingList[0]</code></pre><h4 id="1-3-3-添加元素"><a href="#1-3-3-添加元素" class="headerlink" title="1.3.3 添加元素"></a>1.3.3 添加元素</h4><ul><li><p>调用数组的 <code>insert(_:at:)</code> 方法在某个指定索引值之前添加数据项：</p><pre><code>shoppingList.insert(&quot;Maple syrup&quot;, at: 0)</code></pre></li><li><p>使用<code>append(_:)</code>方法在数组后面添加新元素：</p><pre><code>shoppingList.append(&quot;Flour&quot;)</code></pre></li><li><p>使用 <code>+=</code> 直接将另一个相同类型数组中的元素添加到该数组后面：</p><pre><code>shoppingList += [&quot;Baking Powder&quot;]shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]</code></pre></li></ul><h4 id="1-3-4-改变某个下标对应的元素值"><a href="#1-3-4-改变某个下标对应的元素值" class="headerlink" title="1.3.4 改变某个下标对应的元素值"></a>1.3.4 改变某个下标对应的元素值</h4><pre><code>shoppingList[0] = [&quot;Six eggs&quot;]</code></pre><h4 id="1-3-5-删除元素"><a href="#1-3-5-删除元素" class="headerlink" title="1.3.5 删除元素"></a>1.3.5 删除元素</h4><ul><li><p>使用 <code>remove(at:)</code> 方法来移除数组中的某一项：</p><pre><code>let mapleSyrup = shoppingList.remove(at: 0)</code></pre></li><li><p>移除数组中的最后一项元素：</p><pre><code>let apples = shoppingList.removeLast()</code></pre></li></ul><h3 id="1-4-数组的遍历"><a href="#1-4-数组的遍历" class="headerlink" title="1.4 数组的遍历"></a>1.4 数组的遍历</h3><ul><li><p>使用 <code>for-in</code> 循环来遍历数组中所有的元素：</p><pre><code>for item in shoppingList &#123;  print(item)&#125;//Six eggs//Milk//Flour//Baking Powder//Bananas</code></pre></li><li><p>如果同时需要每个数据项的值和索引值，可以使用<code> enumerated()</code> 方法来进行数组遍历。<code>enumerated()</code> 返回一个由索引值和数据值组成的元组数组。</p><pre><code>for (index, value) in shoppingList.enumerated() &#123;  print(&quot;Item \(String(index + 1)): \(value)&quot;)&#125;//Item 1: Six eggs//Item 2: Milk//Item 3:Flour//Item 4: Baking Powder//Item 5: Bananas</code></pre></li></ul><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2.集合"></a>2.集合</h2><p>集合用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。集合三个特性：</p><ul><li>a == a （自反性）</li><li>a== b 意味着 b == a（对称性）</li><li>a == b &amp;&amp; b == c 意味着 a == c （传递性）<blockquote><ul><li>一个类型为了存储在集合中，该类型必须是可哈希化的——也就是说。一个哈希值是 Int 类型的，相等的对象哈希值必须相同，比如 a == b,因此必须 <code>a.hashValue == b.hashValue</code></li><li>Swift 的所有基本类型（比如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希化的</li></ul></blockquote></li></ul><h3 id="2-1-集合类型语法"><a href="#2-1-集合类型语法" class="headerlink" title="2.1 集合类型语法"></a>2.1 集合类型语法</h3><p>Swift 中的集合类型被写为 <code>Set&lt;Element&gt;</code></p><h3 id="2-2-创建集合"><a href="#2-2-创建集合" class="headerlink" title="2.2 创建集合"></a>2.2 创建集合</h3><h4 id="2-2-1-构造器语法创建空集合"><a href="#2-2-1-构造器语法创建空集合" class="headerlink" title="2.2.1 构造器语法创建空集合"></a>2.2.1 构造器语法创建空集合</h4><p>通过构造器语法创建一个特定类型的空集合：</p><pre><code>var letters = Set&lt;Character&gt;()</code></pre><h4 id="2-2-2-用数组字面量创建集合"><a href="#2-2-2-用数组字面量创建集合" class="headerlink" title="2.2.2 用数组字面量创建集合"></a>2.2.2 用数组字面量创建集合</h4><ul><li><p>如果上下文提供了类型信息，那么可以通过一个空的数组字面量创建一个空的集合：</p><pre><code>letters = [] //letters现在是一个空的Set，但是它依然是 Set&lt;Character&gt;类型</code></pre></li><li><p>用数组字面量创建集合</p><pre><code>var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]或者var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></pre></li></ul><h3 id="2-3-访问和修改集合"><a href="#2-3-访问和修改集合" class="headerlink" title="2.3 访问和修改集合"></a>2.3 访问和修改集合</h3><h4 id="2-3-1-获取集合元素数量"><a href="#2-3-1-获取集合元素数量" class="headerlink" title="2.3.1 获取集合元素数量"></a>2.3.1 获取集合元素数量</h4><p>可以使用 <code>count</code> 属性来获取集合中元素的数量：</p><pre><code>print(&quot;I have \(favoriteGenres.count) favorite music genres.&quot;)</code></pre><h4 id="2-3-2-isEmpty判断集合元素数量是否等于0"><a href="#2-3-2-isEmpty判断集合元素数量是否等于0" class="headerlink" title="2.3.2 isEmpty判断集合元素数量是否等于0"></a>2.3.2 isEmpty判断集合元素数量是否等于0</h4><p>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count </code>属性是否为 <code>0</code></p><pre><code>if favoriteGenres.isEmpty &#123;    print(&quot;As far as music goes, I&#39;m not picky.&quot;)&#125; else &#123;    print(&quot;I have particular music preferences.&quot;)&#125;</code></pre><h4 id="2-3-3-添加元素"><a href="#2-3-3-添加元素" class="headerlink" title="2.3.3 添加元素"></a>2.3.3 添加元素</h4><ul><li>通过调用集合的 <code>insert(_:)</code> 方法来添加一个新元素<pre><code>favoriteGenres.insert(&quot;Jazz&quot;)</code></pre></li></ul><h4 id="2-3-4-删除元素"><a href="#2-3-4-删除元素" class="headerlink" title="2.3.4 删除元素"></a>2.3.4 删除元素</h4><ul><li><p>通过调用集合的 <code>remove(_:)</code> 方法去删除一个元素，如果它是该集合的一个元素则删除它并且返回它的值，若该集合不包含它，则返回 nil</p><pre><code>if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) &#123;  print(&quot;\(removedGenre)? I&#39;m over it.&quot;)&#125; else &#123;  print(&quot;I never much cared for that.&quot;)&#125;</code></pre></li><li><p>可以通过 <code>removeAll() </code>方法删除所有元素</p></li></ul><h4 id="2-3-5-检查集合是否包含元素"><a href="#2-3-5-检查集合是否包含元素" class="headerlink" title="2.3.5 检查集合是否包含元素"></a>2.3.5 检查集合是否包含元素</h4><p>使用 <code>contains(_:)</code> 方法去检查集合中是否包含一个特定的值</p><pre><code>if favoriteGenres.contains(&quot;Funk&quot;) &#123;    print(&quot;I get up on the good foot.&quot;)&#125; else &#123;    print(&quot;It&#39;s too funky in here.&quot;)&#125;</code></pre><h3 id="2-4-集合的遍历"><a href="#2-4-集合的遍历" class="headerlink" title="2.4 集合的遍历"></a>2.4 集合的遍历</h3><ul><li><p>可以在一个<code> for-in</code> 循环中遍历一个集合中的所有值</p><pre><code>for genre in favoriteGenres &#123;  print(&quot;\(genre)&quot;)&#125;//Classical//Jazz//Hip hop</code></pre></li><li><p>Swift 的 <code>Set </code>类型没有确定的顺序，为了按照特定顺序来遍历一个集合中的值可以使用<code>sorted()</code>方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符<code>&lt;</code>对元素进行比较的结果来确定。</p><pre><code>for genre in favoriteGenres.sorted() &#123;  print(&quot;\(genre)&quot;)&#125;//Classical//Jazz//Hip hop</code></pre></li></ul><h3 id="2-5-集合操作"><a href="#2-5-集合操作" class="headerlink" title="2.5 集合操作"></a>2.5 集合操作</h3><h4 id="2-5-1-集合基本操作"><a href="#2-5-1-集合基本操作" class="headerlink" title="2.5.1 集合基本操作"></a>2.5.1 集合基本操作</h4><p>下面的插图描述了两个集合 <code>a</code> 和<code> b</code>，以及通过阴影部分的区域显示集合各种操作的结果。<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="集合基本操作"></p><ul><li>使用 <code>intersection(_:)</code> 方法根据两个集合的交集创建一个新的集合。</li><li>使用 <code>symmetricDifference(_:)</code> 方法根据两个集合不相交的值创建一个新的集合。</li><li>使用 <code>union(_:)</code> 方法根据两个集合的所有值创建一个新的集合。</li><li>使用 <code>subtracting(_:)</code> 方法根据不在另一个集合中的值创建一个新的集合。</li></ul><pre><code>let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]oddDigits.interaction(evenDigits).sorted()// []oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9]</code></pre><h4 id="2-5-2-集合成员关系和相等"><a href="#2-5-2-集合成员关系和相等" class="headerlink" title="2.5.2 集合成员关系和相等"></a>2.5.2 集合成员关系和相等</h4><p>下面的插图描述了三个集合 <code>a</code>、<code>b</code> 和 <code>c</code>，以及通过重叠区域表述集合间共享的元素。集合<code> a</code> 是集合 <code>b</code> 的父集合，因为 <code>a</code> 包含了 <code>b</code> 中所有的元素。相反的，集合 <code>b</code> 是集合 <code>a</code> 的子集合，因为属于 <code>b</code> 的元素也被 <code>a</code> 包含。集合 <code>b</code> 和集合 <code>c</code> 是不相交的，因为它们之间没有共同的元素。<br><img src="/images/iOS/Swift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E6%88%90%E5%91%98%E5%85%B3%E7%B3%BB.png" alt="集合成员关系"></p><ul><li>使用“是否相等”运算符（<code>==</code>）来判断两个集合包含的值是否全部相同。</li><li>使用 <code>isSubset(of:)</code> 方法来判断一个集合中的所有值是否也被包含在另外一个集合中。</li><li>使用 <code>isSuperset(of:)</code> 方法来判断一个集合是否包含另一个集合中所有的值。</li><li>使用 <code>isStrictSubset(of:)</code> 或者 <code>isStrictSuperset(of:)</code> 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li><li>使用 <code>isDisjoint(with:)</code> 方法来判断两个集合是否不含有相同的值（是否没有交集）</li></ul><pre><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]houseAnimals.isSubset(of: farmAnimals)// truefarmAnimals.isSuperset(of: houseAnimals)// truefarmAnimals.isDisjoint(with: cityAnimals)// true</code></pre><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h2><h3 id="3-1-字典类型简化语法"><a href="#3-1-字典类型简化语法" class="headerlink" title="3.1 字典类型简化语法"></a>3.1 字典类型简化语法</h3><p><code>Dictionary&lt;Key, Value&gt;</code> 或者 <code>[Key: Value]</code> </p><h3 id="3-2-创建字典"><a href="#3-2-创建字典" class="headerlink" title="3.2 创建字典"></a>3.2 创建字典</h3><h4 id="3-2-1-构造语法创建空字典"><a href="#3-2-1-构造语法创建空字典" class="headerlink" title="3.2.1 构造语法创建空字典"></a>3.2.1 构造语法创建空字典</h4><p>可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p><pre><code>var namesOfIntegers = [Int: String]()// namesOfIntegers 是一个空的 [Int: String] 字典</code></pre><h4 id="3-2-2-用字典字面量创建字典"><a href="#3-2-2-用字典字面量创建字典" class="headerlink" title="3.2.2 用字典字面量创建字典"></a>3.2.2 用字典字面量创建字典</h4><ul><li><p>如果上下文已经提供了类型信息，可以使用空字典字面量来创建一个空字典，记作<code>[:]</code></p><pre><code>namesOfIntegers[16] = &quot;sixteen&quot;//namesOfIntegers 现在包含一个键值对namesOfIntegers = [:]// nameOfIntegers 又成为了一个 [Int: String] 类型的空字典</code></pre></li><li><p>用字典字面量创建字典</p><pre><code>var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]//如果键和值都有各自统一的类型，可以不必写出字典的类型var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></pre></li></ul><h3 id="3-3-访问和修改字典"><a href="#3-3-访问和修改字典" class="headerlink" title="3.3 访问和修改字典"></a>3.3 访问和修改字典</h3><h4 id="3-3-1-获取字典元素数量"><a href="#3-3-1-获取字典元素数量" class="headerlink" title="3.3.1 获取字典元素数量"></a>3.3.1 获取字典元素数量</h4><p>可以通过 <code>Dictionary</code> 的只读属性 <code>count</code> 来获取字典的数据项数量：</p><pre><code>print(&quot;The dictionary of airports contains \(airports.count) items.&quot;)</code></pre><h4 id="3-3-2-isEmpty检查字典元素数量是否等于0"><a href="#3-3-2-isEmpty检查字典元素数量是否等于0" class="headerlink" title="3.3.2 isEmpty检查字典元素数量是否等于0"></a>3.3.2 isEmpty检查字典元素数量是否等于0</h4><p>使用布尔属性 <code>isEmpty</code> 作为一个缩写形式去检查 <code>count</code> 属性是否为 <code>0</code>：</p><pre><code>if airports.isEmpty &#123;    print(&quot;The airports dictionary is empty.&quot;)&#125; else &#123;    print(&quot;The airports dictionary is not empty.&quot;)&#125;</code></pre><h4 id="3-3-3-添加新元素"><a href="#3-3-3-添加新元素" class="headerlink" title="3.3.3 添加新元素"></a>3.3.3 添加新元素</h4><p>可以通过下标语法来给字典添加新的数据项。</p><pre><code>airports[&quot;LHR&quot;] = &quot;London&quot;// airports 字典现在有三个数据项</code></pre><h4 id="3-3-4-改变某个key对应的元素值"><a href="#3-3-4-改变某个key对应的元素值" class="headerlink" title="3.3.4 改变某个key对应的元素值"></a>3.3.4 改变某个key对应的元素值</h4><p>也可以使用下标语法来改变特定键对应的值</p><pre><code>airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;// &quot;LHR&quot; 对应的值被改为 “London Heathrow”</code></pre><h4 id="3-3-5-获取某个key对应的元素值"><a href="#3-3-5-获取某个key对应的元素值" class="headerlink" title="3.3.5 获取某个key对应的元素值"></a>3.3.5 获取某个key对应的元素值</h4><p>可以使用下标语法来在字典中检索特定键对应的值，返回对应值类型的可选类型。</p><pre><code>if let airportName = airports[&quot;DUB&quot;] &#123;    print(&quot;The name of the airport is \(airportName).&quot;)&#125; else &#123;    print(&quot;That airport is not in the airports dictionary.&quot;)&#125;//打印 “The name of the airport is Dublin Airport.”</code></pre><h4 id="3-3-6-移除某个key对应的元素值"><a href="#3-3-6-移除某个key对应的元素值" class="headerlink" title="3.3.6 移除某个key对应的元素值"></a>3.3.6 移除某个key对应的元素值</h4><ul><li>可以使用下标语法通过将某个键的对应值赋值为 nil 来从字典里移除一个键值对<pre><code>airports[&quot;APL&quot;] = &quot;Apple Internation&quot;airports[&quot;APL&quot;] = nil</code></pre></li></ul><blockquote><p>作为一种替代下标语法的方式，字典的 <code>updateValue(_:forKey:)</code> 方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，<code>updateValue(_:forKey:)</code> 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和下标的方式不同，<code>updateValue(_:forKey:) </code>这个方法返回更新值之前的原值(可选类型)。这样使得你可以检查更新是否成功。</p><pre><code>if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey:&quot;DUB&quot;) &#123;   print(&quot;The old value for DUB was \(oldValue).&quot;)&#125;// 输出 “The old value for DUB was Dublin.”</code></pre></blockquote><h3 id="3-4-字典遍历"><a href="#3-4-字典遍历" class="headerlink" title="3.4 字典遍历"></a>3.4 字典遍历</h3><ul><li><p>使用<code>for-in</code>遍历，每个字典中的数据项都以<code>(key, value)</code>元组形式返回</p><pre><code>for (airportCode, airportName) in airports &#123;  print(&quot;\(airportCode): \(airportName)&quot;)&#125;// YYZ: Toronto Pearson// LHR: London Heathrow</code></pre></li><li><p>通过访问 <code>keys</code> 或者 <code>values</code> 属性，你也可以遍历字典的键或者值：</p><pre><code>for airportCode in airports.keys &#123;  print(&quot;Airport code: \(airportCode)&quot;)&#125;// Airport code: YYZ// Airport code: LHRfor airportName in airports.values &#123;  print(&quot;Airport name: \(airportName)&quot;)&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow</code></pre></li><li><p>可以直接使用 <code>keys</code> 或者 <code>values</code> 属性构造一个新数组：</p><pre><code>let airportCodes = [String](airports.keys)let airportName = [String](airports.values)</code></pre></li></ul><p>Swift 的 <code>Dictionary</code> 是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的 <code>keys</code> 或 <code>values</code> 属性使用 <code>sorted()</code> 方法。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 字符串和字符</title>
      <link href="posts/3185683920.html"/>
      <url>posts/3185683920.html</url>
      
        <content type="html"><![CDATA[<p><code>字符串</code>是一系列字符的集合，例如 <code>&quot;hello, world&quot;</code>，<code>&quot;albatross&quot;</code>。Swift 的字符串通过 <code>String</code> 类型来表示</p><h2 id="1-字符串字面量"><a href="#1-字符串字面量" class="headerlink" title="1.字符串字面量"></a>1.字符串字面量</h2><p>字符串字面量是由一对双引号包裹着的具有固定顺序的字符集。可以用于为常量和变量提供初始值。</p><pre><code>let someString = &quot;Some string literal value&quot;</code></pre><h3 id="1-1-多行字符串字面量"><a href="#1-1-多行字符串字面量" class="headerlink" title="1.1 多行字符串字面量"></a>1.1 多行字符串字面量</h3><p>多行字符串字面量是由一对三个双引号（<code>&quot;&quot;&quot;</code>）包裹的具有固定顺序的文本字符集</p><pre><code>let quotation = &quot;&quot;&quot;The White Rabbit put on his spectacles.  &quot;Where shall I begin,please your Majesty?&quot; he asked.&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go ontill you come to the end; then stop.&quot;&quot;&quot;&quot;</code></pre><h3 id="1-2-字符串字面量的特殊字符"><a href="#1-2-字符串字面量的特殊字符" class="headerlink" title="1.2 字符串字面量的特殊字符"></a>1.2 字符串字面量的特殊字符</h3><p>字符串字面量可以包含以下特殊字符：</p><ul><li>转义字符 <code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\&quot;</code>(双引号)、<code>\&#39;</code>(单引号)。</li><li>Unicode 标量，写成 <code>\u&#123;n&#125;</code>(u 为小写)，其中 <code>n</code> 为任意一到八位十六进制数且可用的 Unicode 位码。<pre><code>let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;// &quot;Imageination is more important than knowledge&quot; - Enisteinlet dollarSign = &quot;\u&#123;24&#125;&quot;             // $，Unicode 标量 U+0024let blackHeart = &quot;\u&#123;2665&#125;&quot;           // ♥，Unicode 标量 U+2665let sparklingHeart = &quot;\u&#123;1F496&#125;&quot;      // 💖，Unicode 标量 U+1F496</code></pre></li></ul><h2 id="2-初始化空字符串"><a href="#2-初始化空字符串" class="headerlink" title="2.初始化空字符串"></a>2.初始化空字符串</h2><ul><li>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的<code> String</code><pre><code>var emptyString = &quot;&quot;               // 空字符串字面量var anotherEmptyString = String()  // 初始化方法// 两个字符串均为空并等价。</code></pre></li><li>可以通过检查 <code>Bool</code> 类型的 <code>isEmpty</code> 属性来判断该字符串是否为空<pre><code>if emptyString.isEmpty &#123;  print(&quot;Nothing to see here&quot;)&#125;// 打印输出：“Nothing to see here”</code></pre></li></ul><h2 id="3-字符串可变性"><a href="#3-字符串可变性" class="headerlink" title="3.字符串可变性"></a>3.字符串可变性</h2><p>通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p><pre><code>var variableString = &quot;Horse&quot;variableString += &quot; and carriage&quot;// variableString 现在为 &quot;Horse and carriage&quot;let constantString = &quot;Highlander&quot;constantString += &quot; and another Highlander&quot;// 这会报告一个编译错误（compile-time error） - 常量字符串不可以被修改。</code></pre><h2 id="4-字符串是值类型"><a href="#4-字符串是值类型" class="headerlink" title="4.字符串是值类型"></a>4.字符串是值类型</h2><h2 id="5-使用字符"><a href="#5-使用字符" class="headerlink" title="5.使用字符"></a>5.使用字符</h2><ul><li><p>通过 <code>for-in</code> 循环来遍历字符串，获取字符串中每一个字符的值</p><pre><code>for character in &quot;Dog!🐶&quot; &#123;  print(character)&#125;// D// o// g// !// 🐶</code></pre></li><li><p>通过标明一个 <code>Character</code> 类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p><pre><code>let exclamationMark: Character = &quot;!&quot;</code></pre></li><li><p>字符串可以通过传递一个值类型为 <code>Character</code> 的数组作为自变量来初始化：</p><pre><code>let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]let catString = String(catCharacters)print(catString)// 打印输出：“Cat!🐱”</code></pre></li></ul><h2 id="6-连接字符串和字符"><a href="#6-连接字符串和字符" class="headerlink" title="6.连接字符串和字符"></a>6.连接字符串和字符</h2><ul><li>字符串可以通过加法运算符（<code>+</code>）相加在一起（或称“连接”）创建一个新的字符串<pre><code>let string1 = &quot;hello&quot;let string2 = &quot; there&quot;var welcome = string1 + string2// welcome 现在等于 &quot;hello there&quot;</code></pre></li><li>可以通过加法赋值运算符（<code>+=</code>）将一个字符串添加到一个已经存在字符串变量上<pre><code>var instruction = &quot;look over&quot;instruction += string2// instruction 现在等于 &quot;look over there&quot;</code></pre></li><li>可以用 <code>append()</code> 方法将一个字符附加到一个字符串变量的尾部：<pre><code>let exclamationMark: Character = &quot;!&quot;welcome.append(exclamationMark)// welcome 现在等于 &quot;hello there!&quot;</code></pre><blockquote><p>注意：不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p></blockquote></li></ul><h2 id="7-字符串插值"><a href="#7-字符串插值" class="headerlink" title="7.字符串插值"></a>7.字符串插值</h2><p>字符串插值是一种构建新字符串的方式，可以在其中包含<code>常量</code>、<code>变量</code>、<code>字面量</code>和<code>表达式</code>。<code>字符串字面量</code>和<code>多行字符串字面量</code>都可以使用字符串插值。</p><pre><code>let multiplier = 3let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;// message 是 &quot;3 times 2.5 is 7.5&quot;</code></pre><h2 id="8-计算字符数量"><a href="#8-计算字符数量" class="headerlink" title="8.计算字符数量"></a>8.计算字符数量</h2><p>可以使用 <code>count</code> 属性来获得一个字符串中 <code>Character</code> 值的数量。</p><pre><code>let unusualMenagerie = &quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;print(&quot;unusualMenagerie has \(unusualMenagerie.count) characters&quot;)// 打印输出“unusualMenagerie has 40 characters”</code></pre><h2 id="9-访问和修改字符串"><a href="#9-访问和修改字符串" class="headerlink" title="9.访问和修改字符串"></a>9.访问和修改字符串</h2><h3 id="9-1-字符串索引"><a href="#9-1-字符串索引" class="headerlink" title="9.1 字符串索引"></a>9.1 字符串索引</h3><p>每一个 <code>String</code> 值都有一个关联的索引（index）类型，<code>String.Index</code>，它对应着字符串中的每一个 <code>Character</code> 的位置。</p><ul><li><p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 的索引</p></li><li><p>使用 <code>endIndex</code> 属性可以获取最后一个 <code>Character</code> 的后一个位置的索引</p></li><li><p>如果 <code>String</code> 是空串，<code>startIndex</code> 和 <code>endIndex</code> 是相等的</p></li><li><p>调用 <code>String</code> 的 <code>index(before:)</code> 或 <code>index(after:)</code> 方法，可以立即得到前面或后面的一个索引</p></li><li><p>调用 <code>index(_:offsetBy:)</code> 方法来获取对应偏移量的索引</p><pre><code>let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex]// Ggreeting[greeting.index(before: greeting.endIndex)]// !greeting[greeting.index(after: greeting.startIndex)]// ulet index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index]// a</code></pre></li><li><p>使用 <code>indices</code> 属性会创建一个包含全部索引的范围（<code>Range</code>），用来在一个字符串中访问单个字符</p><pre><code>for index in greeting.indices &#123; print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)&#125;// 打印输出“G u t e n   T a g ! ”</code></pre></li></ul><h3 id="9-2-插入和删除"><a href="#9-2-插入和删除" class="headerlink" title="9.2 插入和删除"></a>9.2 插入和删除</h3><ul><li>调用 <code>insert(_:at:)</code> 方法可以在一个字符串的指定索引插入一个字符</li><li>调用 <code>insert(contentsOf:at:)</code> 方法可以在一个字符串的指定索引插入一个段字符串</li></ul><pre><code>var welcome = &quot;hello&quot;welcome.insert(&quot;!&quot;, at: welcome.endIndex)// welcome 变量现在等于 &quot;hello!&quot;welcome.insert(contentsOf:&quot; there&quot;, at: welcome.index(before: welcome.endIndex))// welcome 变量现在等于 &quot;hello there!&quot;</code></pre><ul><li>调用 <code>remove(at:)</code> 方法可以在一个字符串的指定索引删除一个字符</li><li>调用 <code>removeSubrange(_:)</code> 方法可以在一个字符串的指定索引删除一个子字符串</li></ul><pre><code>welcome.remove(at: welcome.index(before: welcome.endIndex))// welcome 现在等于 &quot;hello there&quot;let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndexwelcome.removeSubrange(range)// welcome 现在等于 &quot;hello&quot;</code></pre><h2 id="10-子字符串"><a href="#10-子字符串" class="headerlink" title="10.子字符串"></a>10.子字符串</h2><ul><li>使用下标或者 <code>prefix(_:)</code> 之类的方法 —— 就可以得到一个 <code>SubString</code> 的实例，而非另外一个 <code>String</code></li><li>Swift 里的<code> SubString</code> 绝大部分函数都跟 <code>String</code> 一样，意味着可以使用同样的方式去操作 <code>SubString</code> 和 <code>String</code></li><li><code>SubString</code>重用了原 <code>String</code> 的内存空间，不适合长期存储，在短时间内需要操作字符串时，才会使用 <code>SubString</code>。当需要长时间保存结果时，就把 <code>SubString</code> 转化为 <code>String</code> 的实例</li></ul><pre><code>let greeting = &quot;Hello, world!&quot;let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning 的值为 &quot;Hello&quot;// 把结果转化为 String 以便长期存储。let newString = String(beginning)</code></pre><h2 id="11-比较字符串"><a href="#11-比较字符串" class="headerlink" title="11.比较字符串"></a>11.比较字符串</h2><h3 id="11-1-字符串-字符相等"><a href="#11-1-字符串-字符相等" class="headerlink" title="11.1 字符串/字符相等"></a>11.1 字符串/字符相等</h3><p>字符串/字符可以用等于操作符（<code>==</code>）和不等于操作符（<code>!=</code>）</p><pre><code>let quotation = &quot;We&#39;re a lot alike, you and I.&quot;let sameQuotation = &quot;We&#39;re a lot alike, you and I.&quot;if quotation == sameQuotation &#123;    print(&quot;These two strings are considered equal&quot;)&#125;// 打印输出“These two strings are considered equal”</code></pre><h3 id="11-2-前缀-后缀相等"><a href="#11-2-前缀-后缀相等" class="headerlink" title="11.2 前缀/后缀相等"></a>11.2 前缀/后缀相等</h3><p>通过调用字符串的 <code>hasPrefix(_:)</code>/<code>hasSuffix(_:)</code> 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个 <code>String</code> 类型的参数，并返回一个布尔值。</p><pre><code>let romeoAndJuliet = [    &quot;Act 1 Scene 1: Verona, A public place&quot;,    &quot;Act 1 Scene 2: Capulet&#39;s mansion&quot;,    &quot;Act 1 Scene 3: A room in Capulet&#39;s mansion&quot;,    &quot;Act 1 Scene 4: A street outside Capulet&#39;s mansion&quot;,    &quot;Act 1 Scene 5: The Great Hall in Capulet&#39;s mansion&quot;,    &quot;Act 2 Scene 1: Outside Capulet&#39;s mansion&quot;,    &quot;Act 2 Scene 2: Capulet&#39;s orchard&quot;,    &quot;Act 2 Scene 3: Outside Friar Lawrence&#39;s cell&quot;,    &quot;Act 2 Scene 4: A street in Verona&quot;,    &quot;Act 2 Scene 5: Capulet&#39;s mansion&quot;,    &quot;Act 2 Scene 6: Friar Lawrence&#39;s cell&quot;]var act1SceneCount = 0for scene in romeoAndJuliet &#123;    if scene.hasPrefix(&quot;Act 1 &quot;) &#123;        act1SceneCount += 1    &#125;&#125;print(&quot;There are \(act1SceneCount) scenes in Act 1&quot;)// 打印输出“There are 5 scenes in Act 1”var mansionCount = 0var cellCount = 0for scene in romeoAndJuliet &#123;    if scene.hasSuffix(&quot;Capulet&#39;s mansion&quot;) &#123;        mansionCount += 1    &#125; else if scene.hasSuffix(&quot;Friar Lawrence&#39;s cell&quot;) &#123;        cellCount += 1    &#125;&#125;print(&quot;\(mansionCount) mansion scenes; \(cellCount) cell scenes&quot;)// 打印输出“6 mansion scenes; 2 cell scenes”</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 基本运算符</title>
      <link href="posts/3538274255.html"/>
      <url>posts/3538274255.html</url>
      
        <content type="html"><![CDATA[<p>运算符分为一元、二元和三元运算符：</p><ul><li>一元运算符对单一操作对象（如 <code>-a</code>）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如 <code>!b</code>），后置运算符需紧跟在操作对象之后（如 <code>c!</code>）</li><li>二元运算符操作两个操作对象（如 <code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间</li><li>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。</li></ul><h2 id="1-赋值运算符"><a href="#1-赋值运算符" class="headerlink" title="1.赋值运算符"></a>1.赋值运算符</h2><ul><li><code>a = b</code><pre><code>let b = 10var a = 5a = b// a 现在等于 10</code></pre></li><li>多元组，它的元素可以马上被分解成多个常量或变量<pre><code>let (x, y) = (1, 2)// 现在 x 等于 1，y 等于 2</code></pre></li><li>Swift 的赋值操作并不返回任何值</li></ul><h2 id="2-算术运算符"><a href="#2-算术运算符" class="headerlink" title="2.算术运算符"></a>2.算术运算符</h2><p>Swift 中所有数值类型都支持了基本的四则算术运算符：</p><ul><li>加法（<code>+</code>）</li><li>减法（<code>-</code>）</li><li>乘法（<code>*</code>）</li><li>除法（<code>/</code>）<br>加法运算符也可用于 <code>String</code> 的拼接：<pre><code>&quot;hello, &quot; + &quot;world&quot;  // 等于 &quot;hello, world&quot;</code></pre></li><li>求余运算符（<code>%</code>）<br>求余运算符（<code>a % b</code>）也叫取模运算符，是计算 <code>b</code> 的多少倍刚刚好可以容入 <code>a</code>，返回多出来的那部分（余数）。<br>在对负数 <code>b</code> 求余时，<code>b </code>的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code> 的规则是相同的。</li><li>一元负号运算符 (<code>-</code>)</li><li>一元正号运算符 (<code>+</code>)</li></ul><h2 id="3-组合赋值运算符"><a href="#3-组合赋值运算符" class="headerlink" title="3.组合赋值运算符"></a>3.组合赋值运算符</h2><pre><code>var a = 1a += 2// a 现在是 3</code></pre><h2 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4.比较运算符"></a>4.比较运算符</h2><p>所有标准 C 语言中的比较运算符都可以在 Swift 中使用：</p><ul><li>等于（<code>a == b</code>）</li><li>不等于（<code>a != b</code>）</li><li>大于（<code>a &gt; b</code>）</li><li>小于（<code>a &lt; b</code>）</li><li>大于等于（<code>a &gt;= b</code>）</li><li>小于等于（<code>a &lt;= b</code>）</li></ul><p>Swift 也提供恒等（<code>===</code>）和不恒等（<code>!==</code>）这两个比较符来判断两个对象是否引用同一个对象实例。</p><h3 id="4-1-元组比较"><a href="#4-1-元组比较" class="headerlink" title="4.1 元组比较"></a>4.1 元组比较</h3><ul><li>如果两个元组的元素相同，且长度相同的话，元组就可以被比较</li><li>比较元组大小会按照从左到右、逐值比较的方式</li><li>如果所有的值都相等，那么这一对元组我们就称它们是相等的</li><li>存有布尔类型的元组不能被比较</li><li>Swift 标准库只能比较七个以内元素的元组比较函数<pre><code>(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;)   // true，因为 1 小于 2(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;)    // true，因为 3 等于 3，但是 apple 小于 bird(4, &quot;dog&quot;) == (4, &quot;dog&quot;)      // true，因为 4 等于 4，dog 等于 dog</code></pre></li></ul><h2 id="5-三元运算符（问题-答案1-答案2）"><a href="#5-三元运算符（问题-答案1-答案2）" class="headerlink" title="5.三元运算符（问题 ? 答案1 : 答案2）"></a>5.三元运算符（<code>问题 ? 答案1 : 答案2</code>）</h2><h2 id="6-空合运算符"><a href="#6-空合运算符" class="headerlink" title="6.空合运算符"></a>6.空合运算符</h2><p>空合运算符（<code>a ?? b</code>）将对可选类型 <code>a </code>进行空判断，如果 <code>a</code> 包含一个值就进行解包，否则就返回一个默认值 <code>b</code>。表达式 <code>a</code> 必须是 Optional 类型。默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储值的类型保持一致。</p><pre><code>a != nil ? a! : b</code></pre><h2 id="7-区间运算符"><a href="#7-区间运算符" class="headerlink" title="7.区间运算符"></a>7.区间运算符</h2><h3 id="7-1-闭区间运算符"><a href="#7-1-闭区间运算符" class="headerlink" title="7.1 闭区间运算符"></a>7.1 闭区间运算符</h3><p>闭区间运算符（<code>a...b</code>）定义一个包含从 <code>a</code> 到 <code>b</code>（包括 <code>a</code> 和 <code>b</code>）的所有值的区间。<code>a</code> 的值不能超过 <code>b</code>。</p><pre><code>for index in 1...5 &#123;    print(&quot;\(index) * 5 = \(index * 5)&quot;)&#125;// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20// 5 * 5 = 25</code></pre><h3 id="7-2-半开区间运算符"><a href="#7-2-半开区间运算符" class="headerlink" title="7.2 半开区间运算符"></a>7.2 半开区间运算符</h3><p>半开区间运算符（<code>a..&lt;b</code>）定义一个从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。</p><pre><code>let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]let count = names.countfor i in 0..&lt;count &#123;    print(&quot;第 \(i + 1) 个人叫 \(names[i])&quot;)&#125;// 第 1 个人叫 Anna// 第 2 个人叫 Alex// 第 3 个人叫 Brian// 第 4 个人叫 Jack</code></pre><h3 id="7-3-单侧区间"><a href="#7-3-单侧区间" class="headerlink" title="7.3 单侧区间"></a>7.3 单侧区间</h3><p>闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间</p><pre><code>for name in names[2...] &#123;    print(name)&#125;// Brian// Jackfor name in names[...2] &#123;    print(name)&#125;// Anna// Alex// Brian</code></pre><p>半开区间操作符也有单侧表达形式，附带上它的最终值。就像你使用区间去包含一个值，最终值并不会落在区间内</p><pre><code>for name in names[..&lt;2] &#123;    print(name)&#125;// Anna// Alex</code></pre><p>也可以查看一个单侧区间是否包含某个特定的值</p><pre><code>let range = ...5range.contains(7)   // falserange.contains(4)   // truerange.contains(-1)  // true</code></pre><h2 id="8-逻辑运算符"><a href="#8-逻辑运算符" class="headerlink" title="8.逻辑运算符"></a>8.逻辑运算符</h2><p>逻辑运算符的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p><ul><li>逻辑非（<code>!a</code>）</li><li>逻辑与（<code>a &amp;&amp; b</code>）</li><li>逻辑或（<code>a || b</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习笔记 --- 基础部分</title>
      <link href="posts/2215211348.html"/>
      <url>posts/2215211348.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-常量和变量"><a href="#1-常量和变量" class="headerlink" title="1.常量和变量"></a>1.常量和变量</h2><h3 id="1-1-声明常量和变量"><a href="#1-1-声明常量和变量" class="headerlink" title="1.1 声明常量和变量"></a>1.1 声明常量和变量</h3><ul><li>常量和变量必须在使用前声明，用 <code> let</code> 来声明常量，用 <code>var</code> 来声明变量：<pre><code>let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0</code></pre></li><li>可以在一行中声明多个常量或者多个变量，用逗号隔开：<pre><code>var x = 0.0, y = 0.0, z = 0.0</code></pre><blockquote><p>注意：如果代码中有不需要改变的值，请使用 <code>let </code> 关键字将它声明为常量。只将需要改变的值声明为变量。</p></blockquote></li></ul><h3 id="1-2-类型注解"><a href="#1-2-类型注解" class="headerlink" title="1.2 类型注解"></a>1.2 类型注解</h3><p>在声明常量或变量的时候，在常量或变量名后面加上一个冒号和空格，然后加上类型名称：</p><pre><code>var welcomeMessage: String = &quot;Heollo&quot;//一行中定义多个同样类型的变量var red, green, blue: Double</code></pre><h3 id="1-3-常量和变量的命名"><a href="#1-3-常量和变量的命名" class="headerlink" title="1.3 常量和变量的命名"></a>1.3 常量和变量的命名</h3><ul><li>常量和变量名可以包含任何字符，包括 <code>Unicode</code> 字符：<pre><code>let π = 3.14159let 你好 = &quot;你好世界&quot;let 🐶🐮 = &quot;dogcow&quot;</code></pre></li><li>常量与变量名不能包含数学符号、箭头、保留的（或者非法的）Unicode 码位、连线与制表符</li><li>不能以数字开头，但是可以在常量与变量名的其他地方包含数字</li></ul><h3 id="1-4-输出常量和变量"><a href="#1-4-输出常量和变量" class="headerlink" title="1.4 输出常量和变量"></a>1.4 输出常量和变量</h3><p>可以用 <code>print(_:separator:terminator:)</code> 函数来输出当前常量或变量的值：</p><pre><code>print(friendlyWelcome)// 输出“Bonjour!”</code></pre><h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h2><h3 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h3><pre><code>// 这是一个注释</code></pre><h3 id="2-2-多行注释"><a href="#2-2-多行注释" class="headerlink" title="2.2 多行注释"></a>2.2 多行注释</h3><pre><code>/* 这也是一个注释，但是是多行的 */</code></pre><h3 id="2-3-嵌套多行注释"><a href="#2-3-嵌套多行注释" class="headerlink" title="2.3 嵌套多行注释"></a>2.3 嵌套多行注释</h3><pre><code>/* 这是第一个多行注释的开头/* 这是第二个被嵌套的多行注释 */这是第一个多行注释的结尾 */</code></pre><h2 id="3-分号"><a href="#3-分号" class="headerlink" title="3.分号"></a>3.分号</h2><p>Swift 并不强制要求在每条语句的结尾处使用分号（<code>;</code>），有一种情况下必须要用分号，即打算在同一行内写多条独立的语句：</p><pre><code>let cat = &quot;🐱&quot;; print(cat)// 输出“🐱”</code></pre><h2 id="4-整数"><a href="#4-整数" class="headerlink" title="4.整数"></a>4.整数</h2><p>Swift 提供了8、16、32和64位的有符号和无符号整数类型，分别为：</p><ul><li><code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code></li><li><code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code></li></ul><p>一般来说，不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型 <code>Int</code>，长度与当前平台的原生字长相同:</p><ul><li>在32位平台上，<code>Int</code> 和 <code>Int32</code> 长度相同。</li><li>在64位平台上，<code>Int</code> 和 <code>Int64</code> 长度相同。</li></ul><p>除非需要特定长度的整数，一般来说使用 <code>Int</code> 就可以了，可以访问不同整数类型的 <code>min</code> 和 <code>max</code> 属性来获取对应类型的最小值和最大值：</p><pre><code>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型</code></pre><h2 id="5-浮点数"><a href="#5-浮点数" class="headerlink" title="5.浮点数"></a>5.浮点数</h2><p>Swift 提供了两种有符号浮点数类型：</p><ul><li><code>Double</code> 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li><li><code>Float</code> 表示32位浮点数。精度要求不高的话可以使用此类型。<blockquote><p><code>Double</code> 精确度很高，至少有 <code>15</code> 位小数，而 <code>Float</code> 只有 <code>6</code> 位小数</p></blockquote></li></ul><h2 id="6-类型安全和类型推断"><a href="#6-类型安全和类型推断" class="headerlink" title="6.类型安全和类型推断"></a>6.类型安全和类型推断</h2><ul><li>声明常量或者变量时如果赋初始值，Swift根据初始值判断常量或者变量的类型</li><li>当推断浮点数的类型时，Swift 总是会选择 <code>Double</code> 而不是 <code>Float</code></li><li>如果表达式中同时出现了整数和浮点数，会被推断为 <code>Double</code> 类型</li></ul><h2 id="7-数值型字面量"><a href="#7-数值型字面量" class="headerlink" title="7.数值型字面量"></a>7.数值型字面量</h2><p>整数字面量可以被写作：</p><ul><li>一个十进制数，没有前缀</li><li>一个二进制数，前缀是 <code>0b</code></li><li>一个八进制数，前缀是<code> 0o</code></li><li>一个十六进制数，前缀是 <code>0x</code><pre><code>let decimalInteger = 17let binaryInteger = 0b10001       // 二进制的17let octalInteger = 0o21           // 八进制的17let hexadecimalInteger = 0x11     // 十六进制的17</code></pre>浮点字面量可以被写作：</li><li>十进制，没有前缀，可选指数（e）</li><li>十六进制，前缀是<code>0x</code>，可选指数（p）<pre><code>let decimalDouble = 12.1875let exponentDouble = 1.21875e1let hexadecimalDouble = 0xC.3p0</code></pre>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：<pre><code>let paddedDouble = 000123.456let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1</code></pre></li></ul><h2 id="8-数值型类型转换"><a href="#8-数值型类型转换" class="headerlink" title="8.数值型类型转换"></a>8.数值型类型转换</h2><h3 id="8-1-整数转换-SomeType-ofInitialValue"><a href="#8-1-整数转换-SomeType-ofInitialValue" class="headerlink" title="8.1 整数转换 SomeType(ofInitialValue)"></a>8.1 整数转换 <code>SomeType(ofInitialValue)</code></h3><pre><code>let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one)</code></pre><h3 id="8-2-整数和浮点数转换"><a href="#8-2-整数和浮点数转换" class="headerlink" title="8.2 整数和浮点数转换"></a>8.2 整数和浮点数转换</h3><p>整数和浮点数的转换必须显示指定类型：</p><pre><code>let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine// pi 等于 3.14159，所以被推测为 Double 类型</code></pre><p>浮点数到整数的反向转换同样行，整数类型可以用 <code>Double</code> 或者 <code>Float</code> 类型来初始化：</p><pre><code>let integerPi = Int(pi)// integerPi 等于 3，所以被推测为 Int 类型</code></pre><h2 id="9-类型别名"><a href="#9-类型别名" class="headerlink" title="9.类型别名"></a>9.类型别名</h2><p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 <code>typealias</code> 关键字来定义类型别名：</p><pre><code>typealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在是 0</code></pre><h2 id="10-布尔值"><a href="#10-布尔值" class="headerlink" title="10.布尔值"></a>10.布尔值</h2><p>Swift 有一个基本的布尔（Boolean）类型，叫做 <code>Bool</code>，有两个布尔常量：<code>true</code> 和 <code>false</code></p><h2 id="11-元组"><a href="#11-元组" class="headerlink" title="11.元组"></a>11.元组</h2><ul><li><code>元组</code>（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。<pre><code>let http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</code></pre></li><li>可以将一个元组的内容分解（decompose）成单独的常量和变量：<pre><code>let (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \(statusCode)&quot;)// 输出“The status code is 404”print(&quot;The status message is \(statusMessage)&quot;)// 输出“The status message is Not Found”</code></pre></li><li>如果只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：<pre><code>let (justTheStatusCode, _) = http404Errorprint(&quot;The status code is \(justTheStatusCode)&quot;)// 输出“The status code is 404”</code></pre></li><li>可以通过下标来访问元组中的单个元素，下标从零开始：<pre><code>print(&quot;The status code is \(http404Error.0)&quot;)// 输出“The status code is 404”print(&quot;The status message is \(http404Error.1)&quot;)// 输出“The status message is Not Found”</code></pre></li><li>可以在定义元组的时候给单个元素命名：<pre><code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)</code></pre></li><li>给元组中的元素命名后，可以通过名字来获取这些元素的值：<pre><code>print(&quot;The status code is \(http200Status.statusCode)&quot;)// 输出“The status code is 200”print(&quot;The status message is \(http200Status.description)&quot;)// 输出“The status message is OK”</code></pre></li></ul><h2 id="12-可选类型"><a href="#12-可选类型" class="headerlink" title="12.可选类型"></a>12.可选类型</h2><p>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示两种可能：或者有值，你可以解析可选类型访问这个值，或者根本没有值。</p><pre><code>let possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber)// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</code></pre><blockquote><p>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回 <code>nil</code>，<code>nil</code> 表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如 <code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</p></blockquote><h3 id="12-1-nil"><a href="#12-1-nil" class="headerlink" title="12.1 nil"></a>12.1 nil</h3><ul><li>可以给可选变量赋值为 <code>nil</code> 来表示它没有值：<pre><code>var serverResponseCode: Int? = 404// serverResponseCode 包含一个可选的 Int 值 404serverResponseCode = nil// serverResponseCode 现在不包含值</code></pre></li><li>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：<pre><code>var surveyAnswer: String?// surveyAnswer 被自动设置为 nil</code></pre><blockquote><p>注意：Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。</p></blockquote><h3 id="12-2-if-语句以及强制解析"><a href="#12-2-if-语句以及强制解析" class="headerlink" title="12.2 if 语句以及强制解析"></a>12.2 if 语句以及强制解析</h3></li><li>你可以使用 <code>if</code> 语句和 <code>nil</code> 比较来判断一个可选值是否包含值<pre><code>if convertedNumber != nil &#123;  print(&quot;convertedNumber contains some integer value.&quot;)&#125;// 输出“convertedNumber contains some integer value.”</code></pre></li><li>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这被称为可选值的强制解析<pre><code>if convertedNumber != nil &#123;  print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)&#125;// 输出“convertedNumber has an integer value of 123.”</code></pre></li></ul><h3 id="12-3-可选绑定"><a href="#12-3-可选绑定" class="headerlink" title="12.3 可选绑定"></a>12.3 可选绑定</h3><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 <code>if</code> 和 <code>while</code> 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。</p><pre><code>if let constantName = someOptional &#123;    statements&#125;</code></pre><h3 id="12-4-隐式解析可选类型"><a href="#12-4-隐式解析可选类型" class="headerlink" title="12.4 隐式解析可选类型"></a>12.4 隐式解析可选类型</h3><p>在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下可以把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选类型</p><pre><code>let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // 需要感叹号来获取值let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString  // 不需要感叹号</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift-学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins --- iOS自动化打包</title>
      <link href="posts/1870901654.html"/>
      <url>posts/1870901654.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>此篇文章是以 <code>Jenkins</code>安装包 + <code>java8</code>安装包组成的环境进行的。</p><h2 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2. 插件安装"></a>2. 插件安装</h2><p>Jenkins安装完成，并且基本设置做好后。我们需要安装一些插件：</p><ul><li>Xcode integration</li><li>Keychains and Provisioning Profiles Management</li></ul><h3 id="2-1-系统管理"><a href="#2-1-系统管理" class="headerlink" title="2.1 系统管理"></a>2.1 系统管理</h3><p>首页的左侧，点击 <code>系统管理</code>:<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86.png" alt="系统管理"></p><h3 id="2-2-插件管理"><a href="#2-2-插件管理" class="headerlink" title="2.2 插件管理"></a>2.2 插件管理</h3><p>在系统管理页面找到 <code>插件管理</code>:<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86.png" alt="插件管理"></p><h3 id="2-3-安装插件"><a href="#2-3-安装插件" class="headerlink" title="2.3 安装插件"></a>2.3 安装插件</h3><ul><li>搜索插件安装<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%90%9C%E7%B4%A2%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6.png"></li><li>本地上传插件安装，点击 <code>高级</code> -&gt; <code>上传插件</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6.png"></li></ul><h2 id="3-系统设置"><a href="#3-系统设置" class="headerlink" title="3. 系统设置"></a>3. 系统设置</h2><h3 id="3-1-钥匙串权限、-Library权限以及电脑用户管理权限"><a href="#3-1-钥匙串权限、-Library权限以及电脑用户管理权限" class="headerlink" title="3.1 钥匙串权限、~/Library权限以及电脑用户管理权限"></a>3.1 钥匙串权限、~/Library权限以及电脑用户管理权限</h3><h4 id="3-1-1-MobileDevice"><a href="#3-1-1-MobileDevice" class="headerlink" title="3.1.1 MobileDevice"></a>3.1.1 MobileDevice</h4><p>将 <code>/Users/用户名/Library</code> 的 <code>MobileDevice</code> 文件夹拷贝到 <code>/Users/Shared/Jenkins/Library</code>下</p><blockquote><p>注意：是将 <code>MobileDevice</code> 这个文件夹拷贝过去，而不是 <code>MobileDevice</code> 里的文件，<code>/Users/Shared/Jenkins/Library</code> 目录下是没有 <code>MobileDevice</code> 这个文件夹，所以先创建一个 <code>MobileDevice</code>文件夹。</p></blockquote><pre><code>sudo mkdir /Users/Shared/Jenkins/Library/MobileDevicesudo cp -r /Users/xxx/Library/MobileDevice/ /Users/Shared/Jenkins/Library/MobileDevice/</code></pre><h4 id="3-1-2-Keychains"><a href="#3-1-2-Keychains" class="headerlink" title="3.1.2 Keychains"></a>3.1.2 Keychains</h4><p>将 <code>/Users/用户名/Library/Keychains/</code> 下的 <code>login.keychain-db</code>文件拷贝到 <code>/Users/Shared/Jenkins/Library/Keychains</code> 文件夹下面</p><pre><code>cd /Users/Shared/Jenkins/Library/sudo mkdir Keychainssudo cp /Users/xxx/Library/Keychains/login.keychain-db ./Keychains/</code></pre><p>再将这个 <code>login.keychain-db</code> 拷贝到桌面上一份，将文件后缀改为 <code>.keychain</code></p><h4 id="3-1-3-钥匙串权限"><a href="#3-1-3-钥匙串权限" class="headerlink" title="3.1.3 钥匙串权限"></a>3.1.3 钥匙串权限</h4><p>打开钥匙串，找到相应的证书：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E8%AF%81%E4%B9%A6.png"><br>右键密钥显示简介，在访问控制那一项里勾选允许所有应用程序访问此项目，并存储更改<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E8%AF%81%E4%B9%A6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png"></p><h4 id="3-1-4-Library权限"><a href="#3-1-4-Library权限" class="headerlink" title="3.1.4 ~/Library权限"></a>3.1.4 ~/Library权限</h4><ol><li>进入mac系统偏好设置 — 用户与群组 — 其他用户 — jenkins ，勾选允许用户管理这台电脑，并右键选择高级选项，将名字改为jenkins<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AEjenkins%E7%94%A8%E6%88%B7.png"><blockquote><p>Jenkins 安装成功之后，会自动创建一个用户，该用户没有名字</p></blockquote></li></ol><p>找到 <code>Library</code> 资源库文件夹，设置共享与访问权限，everyone读与写都可以<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_library%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png"></p><h3 id="3-2-配置-Keychains-and-Provisioning-Profiles-Management"><a href="#3-2-配置-Keychains-and-Provisioning-Profiles-Management" class="headerlink" title="3.2 配置 Keychains and Provisioning Profiles Management"></a>3.2 配置 <code>Keychains and Provisioning Profiles Management</code></h3><p>插件安装完成后回到系统管理页面进行 <code>Keychains and Provisioning Profiles Management</code> 配置<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png"><br>选取拷贝到桌面的 <code>login.keychain</code> 文件以及相对应的 <code>Provisioning Profile</code> 文件，并upload</p><blockquote><p>注意：开发证书和 Provisioning profile 一定要对应正确，不然命令行打包会认证不了而失败</p></blockquote><h4 id="3-2-1-设置-Keychains"><a href="#3-2-1-设置-Keychains" class="headerlink" title="3.2.1 设置 Keychains"></a>3.2.1 设置 Keychains</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%92%A5%E5%8C%99%E4%B8%B2%E8%AE%BE%E7%BD%AE.png"></p><ul><li><code>Filename</code>: 直接就是 <code>login.keychain</code></li><li><code>Password</code>: 钥匙串密码</li><li><code>Code Signing Identity</code>: 证书名称（PS：这里可以填写多个证书名称，一般开发和生产2个就够了）。可在钥匙串中找到证书，直接复制名称进行粘贴）</li></ul><h4 id="3-2-2-设置-Provisioning-Profiles"><a href="#3-2-2-设置-Provisioning-Profiles" class="headerlink" title="3.2.2 设置 Provisioning Profiles"></a>3.2.2 设置 Provisioning Profiles</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p><h2 id="4-项目新建和设置"><a href="#4-项目新建和设置" class="headerlink" title="4.项目新建和设置"></a>4.项目新建和设置</h2><h3 id="4-1-新建任务"><a href="#4-1-新建任务" class="headerlink" title="4.1 新建任务"></a>4.1 新建任务</h3><p>点击首页 <code>新建任务</code>，然后选择 <code>构建一个自由风格的软件项目</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA.png"><br>在通用选项里可进行一些描述信息填写和构建包丢弃计划（非必要设置）<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE.png"></p><h3 id="4-2-源码管理"><a href="#4-2-源码管理" class="headerlink" title="4.2 源码管理"></a>4.2 源码管理</h3><p>以 <code>Git</code> 为例，在源码管理中填写项目Git地址、相关密钥信息（https账户密码或ssh密钥）、指定分支名称<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86.png"><br>如果 <code>Credentials</code> 设置为 <code>无</code> 的话，会报错：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%BA%90%E7%A0%81%E4%BB%93%E5%BA%93%E6%9D%83%E9%99%90%E6%8A%A5%E9%94%99.png"><br>面板点击添加来设置 <code>SSH</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%B7%BB%E5%8A%A0SSH.png"></p><blockquote><p>私钥查看命令:</p><pre><code>$ cat ~/.ssh/id_rsa</code></pre><p>私钥填写包含 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code> 和 <code>-----END OPENSSH PRIVATE KEY-----</code></p></blockquote><h3 id="4-3-构建触发器"><a href="#4-3-构建触发器" class="headerlink" title="4.3 构建触发器"></a>4.3 构建触发器</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%9E%84%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><h3 id="4-4-构建环境"><a href="#4-4-构建环境" class="headerlink" title="4.4 构建环境"></a>4.4 构建环境</h3><p>选择 <code>Keychains andProvisioning Profiles Management</code> 和 <code>Mobile Provisioning Profiles</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83.png"></p><h3 id="4-5-构建"><a href="#4-5-构建" class="headerlink" title="4.5 构建"></a>4.5 构建</h3><h4 id="4-5-1-Shell"><a href="#4-5-1-Shell" class="headerlink" title="4.5.1 Shell"></a>4.5.1 Shell</h4><p>来到构建选项，先选择添加 <code>执行shell</code>，因为要通过 <code>shell</code> 先执行 <code>pod install</code>操作，当然如果你没有使用 <code>cocoapods</code> 或者你直接把第三方库文件都放在git的话可以忽略这一步<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1%E6%9E%84%E5%BB%BA%E6%89%A7%E8%A1%8CShell.png"><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%BB%BB%E5%8A%A1Shell%E5%86%85%E5%AE%B9.png"></p><h4 id="4-5-2-XCode"><a href="#4-5-2-XCode" class="headerlink" title="4.5.2 XCode"></a>4.5.2 XCode</h4><h4 id="4-5-3-General-build-settings"><a href="#4-5-3-General-build-settings" class="headerlink" title="4.5.3 General build settings"></a>4.5.3 General build settings</h4><h4 id="4-5-4-Code-signing-amp-OS-X-keychain-options"><a href="#4-5-4-Code-signing-amp-OS-X-keychain-options" class="headerlink" title="4.5.4 Code signing &amp; OS X keychain options"></a>4.5.4 Code signing &amp; OS X keychain options</h4><h4 id="4-5-5-Advanced-Xcode-build-options"><a href="#4-5-5-Advanced-Xcode-build-options" class="headerlink" title="4.5.5 Advanced Xcode build options"></a>4.5.5 Advanced Xcode build options</h4><h2 id="5-问题集锦"><a href="#5-问题集锦" class="headerlink" title="5.问题集锦"></a>5.问题集锦</h2><h3 id="5-1-pod-command-not-found"><a href="#5-1-pod-command-not-found" class="headerlink" title="5.1 pod: command not found"></a>5.1 <code>pod: command not found</code></h3><pre><code>$ /bin/sh -xe /Users/Shared/Jenkins/tmp/hudson6502897316694164242.sh+ pod install --verbose --no-repo-update/Users/Shared/Jenkins/tmp/hudson6502897316694164242.sh: line 2: pod: command not foundBuild step &#39;Execute shell&#39; marked build as failure</code></pre><p>出现这个问题可能是因为你没有设置pod的运行路径，解决方法如下：</p><ol><li>打开Jenkins，然后在Jenkins左侧的菜单中找到<strong>系统管理—&gt;系统设置—&gt;全局属性</strong>，然后找到 <code>Environment variables</code>（中文：环境变量）并且勾选。</li><li>打开终端，在终端中输入 <code>echo $PATH</code>，终端会打印出一串字符串，几个路径，复制该路径，返回到Jenkins中</li><li>会让填写一个键值对，键默认填写 <code>PATH</code>，值填写你从终端复制的那个字符串，点击保存，完成，构建该项目。<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></li></ol><h3 id="5-2-Cloning-spec-repo-cocoapods-from-…"><a href="#5-2-Cloning-spec-repo-cocoapods-from-…" class="headerlink" title="5.2 Cloning spec repo cocoapods from …"></a>5.2 Cloning spec repo <code>cocoapods</code> from …</h3><p>配置execute 脚本拉取CocoaPods依赖的时候，不管是 <code>pod install --verbose --no-repo-update</code> 还是用 <code>pod install</code>，页面一直处于转圈圈状态，如下图所示:<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BA%E5%85%8B%E9%9A%86cocoapods.png"><br>等待很长时间之后报错如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BA%E5%85%8B%E9%9A%86cocoapods%E5%A4%B1%E8%B4%A5.png"><br>这个问题可以进入所在文件夹通过<code>pod repo add</code> 方式来解决，或者手动拷贝过去</p><h3 id="5-3-xcode-select-error-tool-‘xcodebuild’-requires-Xcode…"><a href="#5-3-xcode-select-error-tool-‘xcodebuild’-requires-Xcode…" class="headerlink" title="5.3 xcode-select: error: tool ‘xcodebuild’ requires Xcode…"></a>5.3 xcode-select: error: tool ‘xcodebuild’ requires Xcode…</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BAxcode-select%E6%8A%A5%E9%94%99.png"><br>这个问题是 <code>Xcode</code> 路径不对，在终端输入 <code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/</code> 解决</p><h3 id="5-4-xcodebuild-error-‘xxx-xcworkspace’-does-not-exist"><a href="#5-4-xcodebuild-error-‘xxx-xcworkspace’-does-not-exist" class="headerlink" title="5.4 xcodebuild: error: ‘xxx.xcworkspace’ does not exist."></a>5.4 xcodebuild: error: ‘xxx.xcworkspace’ does not exist.</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BAworkspace%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF.png"><br>这个错误是说我们选择的项目路径，也就是需要打包的工作路径、文件不对，修改方法为: 在Jenkins项目配置里面，找到构建，点击增加构建步骤，选择 <code>Advanced Xcode build options</code>，找到<code>Xcode Workspace File</code>填写你的工作路径: <code>/Users/Shared/.jenkins/workspace/Jenkins创建的项目/项目名称</code><br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%9E%84%E5%BB%BAworkspace%E8%B7%AF%E5%BE%84.png"></p><h3 id="5-5-Unable-to-unlock-the-keychain"><a href="#5-5-Unable-to-unlock-the-keychain" class="headerlink" title="5.5 Unable to unlock the keychain"></a>5.5 Unable to unlock the keychain</h3><pre><code>security: SecKeychainUnlock /Users/Shared/Jenkins/Home/workspace/test/login.keychain: The user name or passphrase you entered is not correct.FATAL: Unable to unlock the keychain.</code></pre><p><code>Code signing &amp; OS X keychain options</code> 中 <code>Keychains Path</code> 和 <code>Keychains password</code> 不对导致的</p><h3 id="5-6-Code-Signing-Error-There-are-no-accounts-registered-with-Xcode…"><a href="#5-6-Code-Signing-Error-There-are-no-accounts-registered-with-Xcode…" class="headerlink" title="5.6 Code Signing Error: There are no accounts registered with Xcode…"></a>5.6 Code Signing Error: There are no accounts registered with Xcode…</h3><p>打包出现以下报错：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"><br>原因: 使用了错误的 <code>Provisioning Profile</code></p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins --- 安装</title>
      <link href="posts/210946848.html"/>
      <url>posts/210946848.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装java环境"><a href="#1-安装java环境" class="headerlink" title="1. 安装java环境"></a>1. 安装java环境</h2><p><code>Jenkins</code> 是一个用Java编写的持续集成工具，依赖于Java，所以在安装Jenkins前，需要先安装Java环境，可用以下命令检查是否安装：</p><pre><code>$ java -version</code></pre><p>如果已安装的话，会有以下内容的输出：</p><pre><code>java version &quot;15.0.2&quot; 2021-01-19Java(TM) SE Runtime Environment (build 15.0.2+7-27)Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</code></pre><p>如果没有安装的话，会提示<code>No Java runtime present, requesting install.</code>，可通过下面两种方式安装。</p><h3 id="1-1-官网下载-Java-SDK"><a href="#1-1-官网下载-Java-SDK" class="headerlink" title="1.1 官网下载 Java SDK"></a>1.1 官网下载 Java SDK</h3><p>通过 <code>java -version</code> 命令检查是否安装的时候，如果没有安装，会有如下提示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_java%E5%AE%89%E8%A3%85%E5%BC%B9%E6%A1%86.png"><br>点击更多信息，会直接跳转到<a href="https://www.oracle.com/java/technologies/javase-jdk15-downloads.html">Java官网</a>下载，下载之后按照安装提示安装即可。<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E4%B8%8B%E8%BD%BDjava%E5%8C%85.png"></p><h3 id="1-2-HomeBrew命令行安装"><a href="#1-2-HomeBrew命令行安装" class="headerlink" title="1.2 HomeBrew命令行安装"></a>1.2 HomeBrew命令行安装</h3><p>可通过 <code>brew install java</code> 命令安装java，执行之后如果输出以下内容，则代表安装成功：</p><pre><code>$ brew install javaUpdating Homebrew...==&gt; Auto-updated Homebrew!Updated 3 taps (homebrew/cask-versions, homebrew/core and homebrew/cask).==&gt; New Formulaeqt-libiodbc                   qt-mysql                      qt-postgresql                 xrayqt-mariadb                    qt-percona-server             qt-unixodbc==&gt; Updated FormulaeUpdated 30 formulae.==&gt; Updated CasksUpdated 11 casks.==&gt; Downloading https://homebrew.bintray.com/bottles/openjdk-15.0.2.catalina.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring openjdk-15.0.2.catalina.bottle.tar.gz==&gt; CaveatsFor the system Java wrappers to find this JDK, symlink it with  sudo ln -sfn /usr/local/opt/openjdk/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdkopenjdk is keg-only, which means it was not symlinked into /usr/local,because macOS provides similar software and installing this software inparallel can cause all kinds of trouble.If you need to have openjdk first in your PATH, run:  echo &#39;export PATH=&quot;/usr/local/opt/openjdk/bin:$PATH&quot;&#39; &gt;&gt; /Users/wangruifang/.bash_profileFor compilers to find openjdk you may need to set:  export CPPFLAGS=&quot;-I/usr/local/opt/openjdk/include&quot;==&gt; Summary🍺  /usr/local/Cellar/openjdk/15.0.2: 614 files, 324.9MB</code></pre><blockquote><p>从官网下载安装比较简单，HomeBrew命令行安装过程中容易出错（此篇文章第三部分记录的就是安装过程中遇到的问题）。</p></blockquote><h2 id="2-安装Jenkins"><a href="#2-安装Jenkins" class="headerlink" title="2.安装Jenkins"></a>2.安装Jenkins</h2><p>通安装java环境以下，Jenkins的安装也有两种方式</p><h3 id="2-1-安装包下载安装"><a href="#2-1-安装包下载安装" class="headerlink" title="2.1 安装包下载安装"></a>2.1 安装包下载安装</h3><p>前往<a href="https://www.jenkins.io/">Jenkins官网</a>下载 <code>.pkg</code> 安装包进行安装即可。</p><h3 id="2-2-HomeBrew命令行安装"><a href="#2-2-HomeBrew命令行安装" class="headerlink" title="2.2 HomeBrew命令行安装"></a>2.2 HomeBrew命令行安装</h3><p>可直接通过 <code>brew install jenkins</code> 命令安装：</p><pre><code>$ brew install jenkins</code></pre><p>安装结束后，可根据需要执行以下命令：</p><pre><code>// For the system Java wrappers to find this JDK, symlink it with$ sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk// openjdk@11 is keg-only, which means it was not symlinked into /usr/local, because this is an alternate version of another formula.// If you need to have openjdk@11 first in your PATH, run:$ echo &#39;export PATH=&quot;/usr/local/opt/openjdk@11/bin:$PATH&quot;&#39; &gt;&gt; /Users/wangruifang/.bash_profile//For compilers to find openjdk@11 you may need to set:$ export CPPFLAGS=&quot;-I/usr/local/opt/openjdk@11/include&quot;</code></pre><h2 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h2><p>安装完成之后，在终端输入命令：</p><pre><code>$ jenkins 或者$ brew services start jenkins </code></pre><p>启动 jenkins 服务，即可在浏览器中<a href="http://localhost:8080/">http://localhost:8080</a>中访问</p><blockquote><p><code>brew services start jenkins</code> 命令与 <code>jenkins</code> 的区别是：当终端关闭时，jenkins服务还可以继续使用。</p></blockquote><h3 id="3-1-解锁Jenkins"><a href="#3-1-解锁Jenkins" class="headerlink" title="3.1 解锁Jenkins"></a>3.1 解锁Jenkins</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E8%A7%A3%E9%94%81jenkins.png"><br>按照图中描述输入 <code>cat</code> + <code>密码路径</code>，获取密码复制到管理员密码框中，然后下一步:</p><pre><code>$ cat /Users/用户名/.jenkins/secrets/initialAdminPassword</code></pre><h3 id="3-2-选择安装推荐的插件"><a href="#3-2-选择安装推荐的插件" class="headerlink" title="3.2 选择安装推荐的插件"></a>3.2 选择安装推荐的插件</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E9%80%89%E6%8B%A9%E6%8F%92%E4%BB%B6.png"></p><h3 id="3-3-等待插件安装"><a href="#3-3-等待插件安装" class="headerlink" title="3.3 等待插件安装"></a>3.3 等待插件安装</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.png"></p><blockquote><p>这个过程可能会有插件安装失败，在进度完成之后可重试，会再次安装失败的插件</p></blockquote><h3 id="3-4-创建管理员用户"><a href="#3-4-创建管理员用户" class="headerlink" title="3.4 创建管理员用户"></a>3.4 创建管理员用户</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7.png"></p><h3 id="3-5-实例配置"><a href="#3-5-实例配置" class="headerlink" title="3.5 实例配置"></a>3.5 实例配置</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8jenkins%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA.png"><br>使用默认端口就可以， 点击保存后就会到Jenkins即将就绪页面，此时需重启Jenkins，执行命令：</p><pre><code>$ brew services restart jenkins</code></pre><blockquote><p>url重启Jenkins : <a href="http://localhost:8080/restart">http://localhost:8080/restart</a><br>url关闭Jenkins : <a href="http://localhost:8080/exit">http://localhost:8080/exit</a></p></blockquote><h3 id="3-6-完成"><a href="#3-6-完成" class="headerlink" title="3.6 完成"></a>3.6 完成</h3><p>jenkins服务重启后刷新<a href="http://localhost:8080/">http://localhost:8080</a>，就可以看到jenkins的登录页面了<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E7%99%BB%E5%BD%95.png"><br>输入账号密码就可以进入Jenkins首页：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_%E9%A6%96%E9%A1%B5.png"></p><h2 id="3-安装过程中遇到的问题"><a href="#3-安装过程中遇到的问题" class="headerlink" title="3.安装过程中遇到的问题"></a>3.安装过程中遇到的问题</h2><h3 id="3-1-No-available-formula-with-the-name-quot-java-quot"><a href="#3-1-No-available-formula-with-the-name-quot-java-quot" class="headerlink" title="3.1 No available formula with the name &quot;java&quot; "></a>3.1 <code>No available formula with the name &quot;java&quot; </code></h3><p><code>Q</code>: 执行 <code>brew install java</code>可能会出现以下报错内容：</p><pre><code>$ brew install javaUpdating Homebrew...Error: No available formula with the name &quot;java&quot; ==&gt; Searching for a previously deleted formula (in the last month)...Warning: homebrew/core is shallow clone. To get complete history run:  git -C &quot;$(brew --repo homebrew/core)&quot; fetch --unshallowError: No previously deleted formula found.==&gt; Searching for similarly named formulae...These similarly named formulae were found:app-engine-java               javacc                        jslint4java                   pdftk-javagoogle-java-format            javarepl                      libreadline-javaTo install one of them, run (for example):  brew install app-engine-java==&gt; Searching taps...==&gt; Searching taps on GitHub...Warning: Error searching on GitHub: curl failed!   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed  0     0    0     0    0     0      0      0 --:--:--  0:00:04 --:--:--     0curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to api.github.com:443 Error: No formulae found in taps.</code></pre><p><code>A</code>: 此代表当前 HomeBrew 版本较低导致安装失败，需update，可执行：</p><pre><code>$ brew update</code></pre><h3 id="3-2-homebrew-core-is-a-shallow-clone"><a href="#3-2-homebrew-core-is-a-shallow-clone" class="headerlink" title="3.2 homebrew-core is a shallow clone"></a>3.2 <code>homebrew-core is a shallow clone</code></h3><p><code>Q</code>: 执行 <code>brew update</code> 可能会出现以下报错：</p><pre><code>$ brew updateError:   homebrew-core is a shallow clone.To `brew update`, first run:  git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallowThis command may take a few minutes to run due to the large size of the repository.This restriction has been made on GitHub&#39;s request because updating shallowclones is an extremely expensive operation due to the tree layout and traffic ofHomebrew/homebrew-core and Homebrew/homebrew-cask. We don&#39;t do this for youautomatically to avoid repeatedly performing an expensive unshallow operation inCI systems (which should instead be fixed to not use shallow clones). Sorry forthe inconvenience!</code></pre><p><code>A</code>: 解决方法是先执行以下命令再执行 <code>brew update</code>：</p><pre><code>$ rm -rf /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</code></pre><h3 id="3-3-The-following-directories-are-not-writable-by-your-user-usr-local-share-man-man8"><a href="#3-3-The-following-directories-are-not-writable-by-your-user-usr-local-share-man-man8" class="headerlink" title="3.3 The following directories are not writable by your user: /usr/local/share/man/man8"></a>3.3 <code>The following directories are not writable by your user: /usr/local/share/man/man8</code></h3><p><code>Q</code>: 执行 <code>brew install java</code>可能会因为权限问题出现以下报错内容：</p><pre><code>$ brew install javaError: The following directories are not writable by your user:/usr/local/share/man/man8You should change the ownership of these directories to your user.  sudo chown -R $(whoami) /usr/local/share/man/man8And make sure that your user has write permission.  chmod u+w /usr/local/share/man/man8</code></pre><p><code>A</code>: 解决方法可执行以下命令：</p><pre><code>$ sudo chown -R $(whoami) /usr/local/share/man/man8</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 标签</title>
      <link href="posts/1519021198.html"/>
      <url>posts/1519021198.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-标签简介"><a href="#1-标签简介" class="headerlink" title="1.标签简介"></a>1.标签简介</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来，所以，标签也是版本库的一个快照。</p><blockquote><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针，所以，创建和删除标签都是瞬间完成的。</p></blockquote><h2 id="2-打标签"><a href="#2-打标签" class="headerlink" title="2.打标签"></a>2.打标签</h2><h3 id="2-1-创建标签"><a href="#2-1-创建标签" class="headerlink" title="2.1 创建标签"></a>2.1 创建标签</h3><p>Git 支持两种标签：<code>轻量标签</code>（lightweight）与 <code>附注标签</code>（annotated）</p><h4 id="2-1-1-轻量标签"><a href="#2-1-1-轻量标签" class="headerlink" title="2.1.1 轻量标签"></a>2.1.1 轻量标签</h4><p>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息</p><pre><code>$ git tag v1.0.0</code></pre><h4 id="2-1-2-附注标签"><a href="#2-1-2-附注标签" class="headerlink" title="2.1.2 附注标签"></a>2.1.2 附注标签</h4><p>附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。</p><pre><code>$ git tag -a v1.0.0 -m &quot;my version 1.4&quot;$ git tag -a v1.0.0 9fceb02 //对过去的某次提交打标签$ git push origin v1.0.0    //将标签1.0.0推送到远程仓库</code></pre><h3 id="2-2-查看已有标签"><a href="#2-2-查看已有标签" class="headerlink" title="2.2 查看已有标签"></a>2.2 查看已有标签</h3><pre><code>$ git tag</code></pre><h3 id="2-3-删除标签"><a href="#2-3-删除标签" class="headerlink" title="2.3 删除标签"></a>2.3 删除标签</h3><pre><code>$ git tag -d v1.0.0</code></pre><blockquote><p>上述命令并不会从任何远程仓库中移除这个标签，你必须用:<br><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; </code><br>或者<br><code>git push origin --delete &lt;tagname&gt;</code></p></blockquote><h3 id="2-4-检出标签"><a href="#2-4-检出标签" class="headerlink" title="2.4 检出标签"></a>2.4 检出标签</h3><pre><code>$ git checkout v1.0.0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 分支</title>
      <link href="posts/1519021197.html"/>
      <url>posts/1519021197.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-分支简介"><a href="#1-分支简介" class="headerlink" title="1.分支简介"></a>1.分支简介</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p><h2 id="2-分支管理"><a href="#2-分支管理" class="headerlink" title="2.分支管理"></a>2.分支管理</h2><h3 id="2-1-创建分支"><a href="#2-1-创建分支" class="headerlink" title="2.1 创建分支"></a>2.1 创建分支</h3><pre><code>$ git branch branchname //只是创建分支$ git checkout -b branchname    //创建分支branchname，并切换到分支branchname上</code></pre><h3 id="2-2-切换分支"><a href="#2-2-切换分支" class="headerlink" title="2.2 切换分支"></a>2.2 切换分支</h3><pre><code>$ git checkout branchname</code></pre><blockquote><p>切换分支时，Git会用该分支的最后提交的快照替换工作目录的内容， 所以多个分支不需要多个目录。</p></blockquote><h3 id="2-3-合并分支"><a href="#2-3-合并分支" class="headerlink" title="2.3 合并分支"></a>2.3 合并分支</h3><pre><code>$ git merge branchname</code></pre><h3 id="2-4-删除分支"><a href="#2-4-删除分支" class="headerlink" title="2.4 删除分支"></a>2.4 删除分支</h3><pre><code>git branch -d branchname</code></pre><h3 id="2-5-合并冲突"><a href="#2-5-合并冲突" class="headerlink" title="2.5 合并冲突"></a>2.5 合并冲突</h3><p>如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，分支合并的时候就会产生合并冲突：</p><pre><code>$ git merge devleopAuto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result....&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD...=======...&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop</code></pre><p>解决冲突之后，用 <code>git add</code> 要告诉 Git 文件冲突已经解决，然后再 <code>git commit</code> 提交：</p><pre><code>$ git status -sUU index.html$ git add index.html$ git status -sM  index.html$ git commit[master 88afe0e] Merge branch &#39;develop&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 基础</title>
      <link href="posts/28b33e30.html"/>
      <url>posts/28b33e30.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取Git仓库"><a href="#1-获取Git仓库" class="headerlink" title="1.获取Git仓库"></a>1.获取Git仓库</h2><p>通常有两种获取 <code>Git</code> 项目仓库的方式：</p><ol><li>本地创建 Git 仓库；</li><li>从其它服务器 <code>克隆</code> 一个已存在的 Git 仓库</li></ol><h3 id="1-1-本地创建-Git-仓库"><a href="#1-1-本地创建-Git-仓库" class="headerlink" title="1.1 本地创建 Git 仓库"></a>1.1 本地创建 Git 仓库</h3><h4 id="1-1-1-创建版本库"><a href="#1-1-1-创建版本库" class="headerlink" title="1.1.1 创建版本库"></a>1.1.1 创建版本库</h4><p>创建版本库很简单，首先，选择一个合适的地方，创建一个空目录：</p><pre><code>mkdir Git仓库目录cd Git仓库目录pwd //显示当前目录</code></pre><p>然后通过 <code>git init</code> 命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/username/Git_Repository/.git/</code></pre><p>这样Git仓库就创建好了，目前还是一个空的仓库，但是该目录下多了一个 <code>.git</code> 目录，这个目录是Git来跟踪管理版本库的，不可随意改动。</p><blockquote><p>如果你没有看到 <code>.git</code> 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p></blockquote><h4 id="1-1-2-本地Git关联远程仓库"><a href="#1-1-2-本地Git关联远程仓库" class="headerlink" title="1.1.2 本地Git关联远程仓库"></a>1.1.2 本地Git关联远程仓库</h4><p>以 <code>GitHub</code> 为例，可以从 GitHub 仓库克隆出新的仓库，也可以关联一个已有的本地仓库，然后将本地仓库的内容推送到 GitHub 仓库。打开本地仓库，执行以下命令来进行关联：</p><pre><code>git remote add origin git@github.com:username/Git_Repository.git</code></pre><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.</code></pre><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。以后只要本地有修改，就可以通过以下命令把本地master分支的最新修改推送至GitHub：</p><pre><code>$ git push origin master</code></pre><blockquote><p>由于远程库是空的，我们第一次推送master分支时，加上了 <code>-u</code> 参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></blockquote><h4 id="1-1-3-删除远程库"><a href="#1-1-3-删除远程库" class="headerlink" title="1.1.3 删除远程库"></a>1.1.3 删除远程库</h4><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用 <code>git remote rm &lt;name&gt;</code> 命令。使用前，建议先用 <code>git remote -v</code> 查看远程库信息：</p><pre><code>$ git remote -vorigin    git@github.com:username/Git_Repository.git (fetch)origin    git@github.com:username/Git_Repository.git (push)</code></pre><p>然后根据名字删除：</p><pre><code>$ git remote rm origin</code></pre><h3 id="1-2-克隆现有的仓库"><a href="#1-2-克隆现有的仓库" class="headerlink" title="1.2 克隆现有的仓库"></a>1.2 克隆现有的仓库</h3><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code>，url为仓库地址，比如：</p><pre><code>git clone https://github.com/libgit2/libgit2</code></pre><blockquote><p>这会在当前目录下创建一个名为 <code>libgit2</code> 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p></blockquote><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><pre><code>git clone https://github.com/libgit2/libgit2 mylibgit</code></pre><p>这会执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p><blockquote><p><code>Git</code> 支持多种数据传输协议。上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 <code>SSH</code> 传输协议，比如 <code>user@server:path/to/repo.git</code>。</p></blockquote><h2 id="2-Git基本操作"><a href="#2-Git基本操作" class="headerlink" title="2.Git基本操作"></a>2.Git基本操作</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git init</td><td align="center">初始化仓库</td></tr><tr><td align="center">git clone</td><td align="center">克隆远程仓库</td></tr></tbody></table><h3 id="2-2-提交与修改"><a href="#2-2-提交与修改" class="headerlink" title="2.2 提交与修改"></a>2.2 提交与修改</h3><h4 id="2-2-1-检查当前文件状态"><a href="#2-2-1-检查当前文件状态" class="headerlink" title="2.2.1 检查当前文件状态"></a>2.2.1 检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态，对于没有任何文件修改的仓库执行完命令之后显示<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_0.png"></p><h4 id="2-2-2-把更改的内容添加到暂存区"><a href="#2-2-2-把更改的内容添加到暂存区" class="headerlink" title="2.2.2 把更改的内容添加到暂存区"></a>2.2.2 把更改的内容添加到暂存区</h4><p>新建 <code>_config.yml</code> 文件，执行 <code>git status</code> 之后显示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_1.png"><br>此时代表 <code>_config.yml</code> 文件还未添加到暂存区，我们使用命令 <code>git add</code>，运行：</p><pre><code>git add _config.yml</code></pre><p>然后再执行 <code>git status</code>，就会看到 <code>_config.yml</code> 文件已被添加到暂存区，并处于暂存状态：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_2.png"></p><blockquote><p><code>git add</code> 命令使用文件或目录的路径作为参数</p></blockquote><h4 id="2-2-3-修改已暂存的文件"><a href="#2-2-3-修改已暂存的文件" class="headerlink" title="2.2.3 修改已暂存的文件"></a>2.2.3 修改已暂存的文件</h4><p>修改一个已在暂存区的文件，以 <code>_config.yml</code> 为例，修改之后执行 <code>git status</code> 命令之后，会看到下面内容：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_3.png"><br>暂存这次修改，再次执行 <code>git add</code> 命令。</p><blockquote><p><code>_config.yml</code> 文件同时出现在暂存区 和 非暂存区，但是 <code>git commit</code>时，只会提交最后一次运行 <code>git add</code> 时的版本。</p></blockquote><h4 id="2-2-4-状态预览"><a href="#2-2-4-状态预览" class="headerlink" title="2.2.4 状态预览"></a>2.2.4 状态预览</h4><p><code>git status</code> 命令的输出非常详细，但其用语有些繁琐。可以使用 <code>git status -s</code> 或 <code>git status -short</code> 来进行简洁输出：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_preview.png"></p><blockquote><p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态:<br><code>??</code> : 未被添加到暂存区的文件<br><code>A</code>   : 新添加到暂存区中的文件<br><code>M</code>   : 被修改的文件<br><code>AM</code> : 添加到暂存区之后又有改动</p></blockquote><h4 id="2-2-5-忽略文件"><a href="#2-2-5-忽略文件" class="headerlink" title="2.2.5 忽略文件"></a>2.2.5 忽略文件</h4><p>执行 <code>add</code> 操作时，有些文件是不想要放到暂存区，就可以使用下面的方法忽略掉:</p><ul><li>使用命令：<code>touch .gitignore</code> 创建 <code>.gitignore</code> 文件</li><li>在文件中写入需要忽略的文件</li></ul><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略</li><li>可以使用标准的 <code>glob</code> 模式匹配，它会递归地应用在整个工作区中</li><li>匹配模式可以以（<code>/</code>）开头防止递归</li><li>匹配模式可以以（<code>/</code>）结尾指定目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反</li></ul><blockquote><p>所谓的 <code>glob</code> 模式是指 <code>shell</code> 所使用的简化了的正则表达式:<br><code>*</code> : 匹配零个或多个任意字符<br><code>[abc]</code> : 匹配任何一个列在方括号中的字符(要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)<br><code>?</code> : 只匹配一个任意字符<br><code>[0-9]</code> : 匹配所有 <code>0</code> 到 <code>9</code> 的数字<br><code>**</code> : 匹配任意中间目录(比如：<code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等)</p></blockquote><p><code>.gitignore</code> 文件示例：</p><pre><code># 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf</code></pre><h4 id="2-2-6-比较暂存区和工作区的差异"><a href="#2-2-6-比较暂存区和工作区的差异" class="headerlink" title="2.2.6 比较暂存区和工作区的差异"></a>2.2.6 比较暂存区和工作区的差异</h4><ul><li>比较文件在暂存区和工作区的差异，使用命令：<pre><code>$ git diff</code></pre></li><li>查看文件修改之后还没有暂存的变化部分，直接使用命令：<pre><code>$ git diff [file]</code></pre></li><li>显示已暂存文件和上次提交的差异，使用命令：<pre><code>$ git diff --staged或$ git diff --cached</code></pre></li><li>显示两次提交之间的差异，使用命令：<pre><code>$ git diff [first-branch]...[second-branch]</code></pre></li></ul><h4 id="2-2-7-提交更新"><a href="#2-2-7-提交更新" class="headerlink" title="2.2.7 提交更新"></a>2.2.7 提交更新</h4><p>提交暂存区到本地仓库中，命令为：</p><pre><code>$ git commit -m &quot;message&quot; //message为提交log信息</code></pre><p>提交暂存区的指定文件到本地仓库，使用命令：</p><pre><code>$ git commit [file1] [file2] ... -m &quot;message&quot;</code></pre><p>修改文件后，不执行 <code>git add</code> 命令，直接跳过使用暂存区来提交，使用命令：</p><pre><code>$ git commit -a -m &quot;message&quot;</code></pre><blockquote><p>运行 <code>git commit -a</code> 相当于运行 <code>git add</code> 把所有文件加入暂存区，然后再运行 <code>git commit</code> 把文件提交本地仓库。<br>提交之后，发现漏提文件或者提交信息写错了，可以重新提交，使用命令：</p></blockquote><pre><code>$ git commit -m &quot;message&quot;$ git add forgotten_file$ git commit --amend</code></pre><blockquote><p>最终只会有一个提交——第二次提交将代替第一次提交的结果</p></blockquote><h4 id="2-2-8-删除文件"><a href="#2-2-8-删除文件" class="headerlink" title="2.2.8 删除文件"></a>2.2.8 删除文件</h4><ol><li><p>从工作区删除文件<br>从工作区中移除某个文件，可以直接删除，也可以用 <code>rm</code> 命令删：</p><pre><code>rm [file]</code></pre><p>这只是简单的从工作目录中删除了文件，运行 <code>git status</code> 时就会有 <code>Changes not staged for commit</code> 部分：</p><pre><code>$ rm test.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes not staged for commit:(use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)     deleted:    test.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>然后再运行 <code>git rm </code> 记录此次移除文件的操作，然后提交，文件从版本库中被删除：</p><pre><code>$ git rm test.mdrm &#39;test.md&#39;$ git commit -m &quot;remove test.md&quot;[master d46f35e] remove test.md1 file changed, 1 deletion(-)delete mode 100644 test.md</code></pre><blockquote><p>如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>git rm -f [file]</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p></blockquote></li><li><p>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可：</p><pre><code>$ git rm --cached test.md</code></pre></li></ol><h4 id="2-2-9-移动文件"><a href="#2-2-9-移动文件" class="headerlink" title="2.2.9 移动文件"></a>2.2.9 移动文件</h4><p><code>git mv</code> 命令用于移动或重命名一个文件、目录或软连接:</p><pre><code>$ git mv file_from file_to</code></pre><p><code>git mv</code> 相当于运行了下面三条命令：</p><pre><code>$ mv file_from file_to$ git rm file_from$ git add file_to</code></pre><h4 id="2-2-10-代码回退"><a href="#2-2-10-代码回退" class="headerlink" title="2.2.10 代码回退"></a>2.2.10 代码回退</h4><pre><code>$ git reset --files //用本地仓库覆盖暂存区中修改，也就是覆盖最后一次git add的内容$ git checkout --files  //把文件从暂存区复制到工作区，用于放弃本地的修改$ git checkout HEAD --files //回退最后一次的提交内容</code></pre><blockquote><p>从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></blockquote><h4 id="2-2-11-版本回退"><a href="#2-2-11-版本回退" class="headerlink" title="2.2.11 版本回退"></a>2.2.11 版本回退</h4><pre><code>$ git reset --hard HEAD^ //回退到上一版本$ git reset --hard HEAD^^ //回退到上上版本$ git reset --hard HEAD~100 //回退到前100个版本$ git reset --hard [版本号] //回退到固定版本号$ git reflog //记录每一次的命令（可以查看版本号）</code></pre><h3 id="2-3-提交日志"><a href="#2-3-提交日志" class="headerlink" title="2.3 提交日志"></a>2.3 提交日志</h3><h4 id="2-3-1-查看历史提交记录"><a href="#2-3-1-查看历史提交记录" class="headerlink" title="2.3.1 查看历史提交记录"></a>2.3.1 查看历史提交记录</h4><pre><code>$ git log</code></pre><h4 id="2-3-2-以列表形式查看指定文件的历史修改记录"><a href="#2-3-2-以列表形式查看指定文件的历史修改记录" class="headerlink" title="2.3.2 以列表形式查看指定文件的历史修改记录"></a>2.3.2 以列表形式查看指定文件的历史修改记录</h4><pre><code>$ git blame file</code></pre><h3 id="2-4-远程操作"><a href="#2-4-远程操作" class="headerlink" title="2.4 远程操作"></a>2.4 远程操作</h3><h4 id="2-4-1-本地推送远程"><a href="#2-4-1-本地推送远程" class="headerlink" title="2.4.1 本地推送远程"></a>2.4.1 本地推送远程</h4><p>如果还没有克隆现有仓库，并想将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><pre><code>$ git remote add origin &lt;url&gt;</code></pre><p>如果已经关联了远程仓库，可以使用下述命令看一下远程仓库是哪个</p><pre><code>$ git remote -v</code></pre><p>然后将本地的改动提交到远程仓库:</p><pre><code>$ git push origin [分支]</code></pre><h4 id="2-4-2-从远程仓库中抓取与拉取"><a href="#2-4-2-从远程仓库中抓取与拉取" class="headerlink" title="2.4.2 从远程仓库中抓取与拉取"></a>2.4.2 从远程仓库中抓取与拉取</h4><pre><code>$ git fetch //下载远程代码到本地仓库$ git pull  //合并</code></pre><blockquote><p><code>git fetch</code> 命令只会将数据下载到你的本地仓库，并不会自动合并或修改你当前的工作</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 入门</title>
      <link href="posts/bcaee25f.html"/>
      <url>posts/bcaee25f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于版本控制"><a href="#1-关于版本控制" class="headerlink" title="1.关于版本控制"></a>1.关于版本控制</h2><h3 id="1-1-什么是版本控制"><a href="#1-1-什么是版本控制" class="headerlink" title="1.1 什么是版本控制"></a>1.1 什么是版本控制</h3><p>版本控制是一种记录一个或若干文件(可以是任意类型的文件)内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="1-2-为什么要用版本控制"><a href="#1-2-为什么要用版本控制" class="headerlink" title="1.2 为什么要用版本控制"></a>1.2 为什么要用版本控制</h3><p>在我们的实际开发过程中，经常会有这样的问题：</p><ol><li>一个项目多人协同开发，多人修改后如何快速生成一份最新代码</li><li>检查某个文件的修改记录（修改人、修改时间、修改内容）</li><li>改错代码，需将项目代码恢复到之前的某个版本</li></ol><h3 id="1-3-历史分类"><a href="#1-3-历史分类" class="headerlink" title="1.3 历史分类"></a>1.3 历史分类</h3><p>纵观版本控制系统的发展历史，<a href="https://ericsink.com/vcbe/index.html">《Version Control By Example》</a>一书的作者 <code>Eric Sink</code> 在他的书中对版本控制进行了分类，广义上讲，版本控制工具的历史可以分为三代：</p><table><thead><tr><th align="center">代</th><th align="center">名称</th><th align="center">网络</th><th align="center">操作</th><th align="center">并发性</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">第一代</td><td align="center">本地版本控制系统</td><td align="center">无</td><td align="center">仅一个文件</td><td align="center">锁定的</td><td align="center">RCS</td></tr><tr><td align="center">第二代</td><td align="center">集中式版本控制系统</td><td align="center">集中式</td><td align="center">多文件</td><td align="center">提交之前合并</td><td align="center">CVS, SourceSafe, Subversion, Team Foundation Server</td></tr><tr><td align="center">第三代</td><td align="center">分布式版本控制系统</td><td align="center">分布式</td><td align="center">变更的集合</td><td align="center">合并之前提交</td><td align="center">Bazaar, Git, Mercurial</td></tr></tbody></table><h4 id="1-3-1-本地版本控制系统"><a href="#1-3-1-本地版本控制系统" class="headerlink" title="1.3.1 本地版本控制系统"></a>1.3.1 本地版本控制系统</h4><p>本地版本控制系统，一次只能有一个人处理文件，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><h4 id="1-3-2-集中式版本控制系统"><a href="#1-3-2-集中式版本控制系统" class="headerlink" title="1.3.2 集中式版本控制系统"></a>1.3.2 集中式版本控制系统</h4><p>集中式版本控制系统，版本库是集中存放在中央服务器的，协同工作的人都是通过客户端连接到这台服务器，取出最新的文件或者提交更新。<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_category_cvcs.png"><br>由上图可看到，在集中式版本控制系统中：</p><ul><li>优点: 不同的开发者可以在不同的电脑上进行协同开发，对同步修改更加宽容</li><li>缺点: 中央服务器的单点故障。如果宕机一小时，那么在这一个小时内，谁都无法提交更新。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，那么将丢失所有数据——包括项目的整个变更历史，只剩下各自机器上保留的单独快照。</li></ul><h4 id="1-3-3-分布式版本控制系统"><a href="#1-3-3-分布式版本控制系统" class="headerlink" title="1.3.3 分布式版本控制系统"></a>1.3.3 分布式版本控制系统</h4><p>分布式版本控制系统，允许合并和提交分开，在每个使用者电脑上都有一个完整的版本库，包括完整的历史记录，没有网络依然可以使用。<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_category_dvcs.png"><br>由上图可看到，分布式式版本控制系统也可以有个服务器端的仓库，用来同步各开发者的私有仓库！在分布式版本控制系统中，每个参与者的本地也会有一个完整的仓库。即使服务器端崩溃，我们仍然可以使用 Git（仅在本地仓库管理我们的代码），在网络具备时，再和服务器进行同步即可！</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><h3 id="2-1-Git起源"><a href="#2-1-Git起源" class="headerlink" title="2.1 Git起源"></a>2.1 Git起源</h3><p>Linus 在1991年创建了开源的 <code>Linux</code>，Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，初期世界各地的志愿者把源代码文件通过 <code>diff</code> 的方式发给Linus，然后由linus 本人通过 <code>linux</code> 命令 <code>diff</code> 和 <code>patch</code> 两条命令手动完成。随着 Linux 代码越来越壮大，靠 Linus 一个人来手动合并已经不现实。2002 年，Linus 选择了一个商业版本控制系统 <code>BitKeeper</code> 作为 Linux 内核的代码管理工具（<code>BitKeeper</code> 的开发商 <code>BitMover</code> 授权 linux 社区免费使用）。但是，免费使用是有很多的限制的，因此 linux 社区的大佬开始破解 <code>BitKeeper</code>。其中，<code>samba</code> 的作者 <code>andrew</code> 破解成功了。但是被 <code>BitMover</code> 公司发现，收回免费使用权。</p><p>迫不得已，Linus 选择了自己开发一个分布式版本控制工具以替代 <code>BitKeeper</code>。linus 闭关一个月，用C写出了 <code>Git</code>。在一个月后，<code>Git</code> 成功接管了 <code>Linux</code> 社区的版本控制工作，并且开始开源。</p><h3 id="2-2-Git简介"><a href="#2-2-Git简介" class="headerlink" title="2.2 Git简介"></a>2.2 Git简介</h3><p><code>Git</code> 是目前世界上最先进的分布式版本控制系统。每个开发者的本地都会有完整的版本库，不需要来联网，也能进行版本的管理和代码的提交，每个开发者都可以在本地进行提交代码、查看版本、切换分支等操作。</p><h4 id="2-2-1-Git特点"><a href="#2-2-1-Git特点" class="headerlink" title="2.2.1 Git特点"></a>2.2.1 Git特点</h4><ol><li>直接记录快照，而不是差异比较:<br> 其他版本控制系统(<code>CVS</code>、<code>Subversion</code>、<code>Perforce</code>、<code>Bazaar</code> 等等)将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异:<br> <img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_cvs_record.png"><br> 在<code>Git</code>中保存项时，它主要对当时的全部文件制作一个快照并保存这个快照的索引，<code>Git</code> 对待数据更像是一个 <code>快照流</code>。<br> <img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_git_record.png"></li><li>近乎所有操作都是本地执行</li><li>Git保证完整性: Git数据库中保存的信息都是以文件内容的哈希值（40个十六进制字符 <code>0-9</code> 和 <code>a-f</code>）来索引，而不是文件名。</li><li>执行的Git操作，只往Git数据库中增加数据，而且Git操作不可逆。</li></ol><h4 id="2-2-2-Git工作区、暂存区和版本库"><a href="#2-2-2-Git工作区、暂存区和版本库" class="headerlink" title="2.2.2 Git工作区、暂存区和版本库"></a>2.2.2 Git工作区、暂存区和版本库</h4><p>Git有三种状态，你的文件有可能处于其中之一：</p><ul><li><code>已提交</code>：表示数据已经安全的保存在本地数据库中</li><li><code>已修改</code>：表示修改了文件，但还没保存到数据库中</li><li><code>已暂存</code>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><p>由此可以引入Git的三个工作区：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_work_zone.png"></p><ul><li><code>工作区</code>：就是你在电脑里能看到的目录</li><li><code>暂存区</code>：英文叫 <code>stage</code> 或 <code>index</code>。一般存放在 <code>.git</code> 目录下的 <code>index</code> 文件 <code>（.git/index）</code>中，所以我们把暂存区有时也叫作索引（index）</li><li><code>版本库</code>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 Git 的版本库</li></ul><h4 id="2-2-3-Git工作流程"><a href="#2-2-3-Git工作流程" class="headerlink" title="2.2.3 Git工作流程"></a>2.2.3 Git工作流程</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_git_process.png"><br>一般工作流程如下：</p><ol><li>克隆Git资源作为工作目录</li><li>在工作目录中添加或者修改文件</li><li>如果其他人修改了，你可以更新资源</li><li>在提交前查看修改</li><li>提交修改，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li></ol><h3 id="2-3-Git安装"><a href="#2-3-Git安装" class="headerlink" title="2.3 Git安装"></a>2.3 Git安装</h3><p>Git 本身支持 <code>Mac OS X</code>、<code>Windows</code>、<code>Linux/Unix</code> 这些主流的平台。</p><h4 id="2-3-1-Mac-OS"><a href="#2-3-1-Mac-OS" class="headerlink" title="2.3.1 Mac OS"></a>2.3.1 Mac OS</h4><p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 <code>Xcode Command Line Tools</code>。 <code>Mavericks （10.9）</code> 或更高版本的系统中，在 <code>Terminal</code> 里尝试首次运行 git 命令即可:</p><pre><code>git --version</code></pre><p>如果没有安装过命令行开发者工具，将会提示你安装。</p><blockquote><p>还可以通过 <code>homebrew</code> 安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</p></blockquote><h3 id="2-4-Git配置"><a href="#2-4-Git配置" class="headerlink" title="2.4 Git配置"></a>2.4 Git配置</h3><p>Git 的配置主要就是 Git 命令 <code>git config</code> 的使用。</p><h4 id="2-4-1-设置用户信息"><a href="#2-4-1-设置用户信息" class="headerlink" title="2.4.1 设置用户信息"></a>2.4.1 设置用户信息</h4><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p><pre><code>$ git config --global user.name &quot;username&quot;$ git config --global user.email username@example.com</code></pre><blockquote><p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p></blockquote><h4 id="2-4-2-检查配置信息"><a href="#2-4-2-检查配置信息" class="headerlink" title="2.4.2 检查配置信息"></a>2.4.2 检查配置信息</h4><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置：</p><pre><code>$ git config --listcredential.helper=osxkeychaincore.excludesfile=/Users/username/.gitignore_globaldifftool.sourcetree.cmd=opendiff &quot;$LOCAL&quot; &quot;$REMOTE&quot;difftool.sourcetree.path=mergetool.sourcetree.cmd=/Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh &quot;$LOCAL&quot; &quot;$REMOTE&quot; -ancestor &quot;$BASE&quot; -merge &quot;$MERGED&quot;mergetool.sourcetree.trustexitcode=trueuser.name=usernameuser.email=email@email.comcommit.template=/Users/username/.stCommitMsghttp.postbuffer=524288000http.lowspeedlimit=0http.lowspeedtime=999999credential.helper=osxkeychaincore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=trueremote.origin.url=git@github.com:username/repository.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=origin</code></pre><p>你可以通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置:</p><pre><code>$ git config user.nameusername</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 添加Gitalk评论</title>
      <link href="posts/2465856778.html"/>
      <url>posts/2465856778.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>目前 <code>3-hexo</code> 已经集成了评论系统有 <code>gitalk</code> 、<code>gitment</code>、 <code>disqus</code> 、<code>来必力</code>、<code>utteranc</code>。本来以为按照 <code>3-hexo</code> 作者的设置文档很简单，没想到中间还是遇到一些问题，然后就将这些问题做了以下记录。</p><h2 id="2-Gitalk"><a href="#2-Gitalk" class="headerlink" title="2.Gitalk"></a>2.Gitalk</h2><h3 id="2-1-Gitalk简介"><a href="#2-1-Gitalk简介" class="headerlink" title="2.1 Gitalk简介"></a>2.1 Gitalk简介</h3><blockquote><p><a href="https://gitalk.github.io/">Gitalk</a> 是一款基于 <code>Github Issue</code> 和 <code>Preact</code> 开发的评论插件，使用 Github 帐号登录，界面干净整洁，支持 <code>MarkDown</code> 语法，在个人博客里添加了之后就可以很简便的进行评论和回复了。</p></blockquote><p>主要特性：</p><ul><li>使用 Github 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd | ctrl + enter）</li><li>支持 MarkDown 语法</li></ul><p>界面效果：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_comment.png"></p><h3 id="2-2-3-hexo添加Gitalk评论"><a href="#2-2-3-hexo添加Gitalk评论" class="headerlink" title="2.2 3-hexo添加Gitalk评论"></a>2.2 3-hexo添加Gitalk评论</h3><h4 id="2-2-1-登录Github注册OAuth应用"><a href="#2-2-1-登录Github注册OAuth应用" class="headerlink" title="2.2.1 登录Github注册OAuth应用"></a>2.2.1 登录Github注册OAuth应用</h4><p><a href="https://github.com/settings/applications/new"><strong>点击进行注册</strong></a> ，也可以通过 GitHub -&gt; 【点击头像】 -&gt; 【Settings】 -&gt; 【Developer settings】-&gt; 【OAuth Apps】-&gt;【New OAuth App】进行基本配置，如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_register.png"></p><ul><li><code>Application name</code>：应用名称，随便填</li><li><code>Homepage URL</code>：没有过多要求，可以填自己的博客地址(避免出问题最和Authorization callback URL好统一)</li><li><code>Application description</code>：应用描述，描述一下，无要求</li><li><code>Authorization callback URL</code>：这个就有要求了，填自己要使用 <code>Gitalk</code> 的博客地址，不可乱填</li></ul><p>注册完后，可得到 <code>Client ID</code> 和 <code>Client Secret</code>。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_client_info.png"></p><h4 id="2-2-2-新建存放评论的仓库"><a href="#2-2-2-新建存放评论的仓库" class="headerlink" title="2.2.2 新建存放评论的仓库"></a>2.2.2 新建存放评论的仓库</h4><p>因为 <code>gitalk</code> 是基于 Github 的 <code>Issue</code> 的，所以，你要为他建一个库或用现成的库，可以新建一个，而 <code>repo</code> 就是你要用的库的名称。 比如，为 Gitalk 专门建了一个叫 gitalk 的库，所以在 repo: 处填 gitalk。</p><h4 id="2-2-3-配置主题"><a href="#2-2-3-配置主题" class="headerlink" title="2.2.3 配置主题"></a>2.2.3 配置主题</h4><p>在主题下 <code>_config.yml</code> 中找到如下配置，启用评论，并使用 <code>gitalk</code></p><pre><code>##########评论设置#############comment:  on: true  type: gitalk</code></pre><p>在主题下 <code>_config.yml</code> 中找到 <code>gitalk</code> 配置，将第1步得到的 <code>Client ID</code> 和 <code>Client Secret</code> 复制到如下位置:</p><pre><code>gitalk:  githubID:    # 填你的 github 用户名  repo:  xxx.github.io     # 承载评论的仓库，一般使用 Github Page 仓库  ClientID:   # 第1步获得 Client ID  ClientSecret:  # 第1步获得 Client Secret  adminUser:     # Github 用户名  distractionFreeMode: true  language: zh-CN  perPage: 10</code></pre><p>到此为止，所有的配置就完成了，执行部署之后，过一会儿应该能看到效果了，应该能看到效果了。</p><h3 id="2-3-问题"><a href="#2-3-问题" class="headerlink" title="2.3 问题"></a>2.3 问题</h3><h4 id="2-3-1-未找到相关的lssues进行评论"><a href="#2-3-1-未找到相关的lssues进行评论" class="headerlink" title="2.3.1 未找到相关的lssues进行评论"></a>2.3.1 未找到相关的lssues进行评论</h4><p>如果出现以下提示，则<code>使用Github登录即可解决</code>。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_login.png"></p><h4 id="2-3-2-登录GitHub之后跳转博客首页"><a href="#2-3-2-登录GitHub之后跳转博客首页" class="headerlink" title="2.3.2 登录GitHub之后跳转博客首页"></a>2.3.2 登录GitHub之后跳转博客首页</h4><p>登录GitHub之后跳转到博客首页，主要是因为 <code>Homepage URL</code> 和 <code>Authorization callback URL</code>这两个地址错误引起的，我是因为注册 <code>OAuth应用</code> 的时候填写的博客地址，但是测试时用的 <code>http://localhost:4000/</code>，导致两个地址不匹配。</p><h4 id="2-3-3-Request-failed-with-status-code-403"><a href="#2-3-3-Request-failed-with-status-code-403" class="headerlink" title="2.3.3 Request failed with status code 403"></a>2.3.3 Request failed with status code 403</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403.png"></p><blockquote><p>遇到这个问题之后，我反复检查配置，发现跟别人讲解的都一样，但是自己的还是不能使用，像极了大多数家长教育自家孩子的那句话：为什么别人家的孩子都可以，就你不行【吐血】。那能怎么办呢，生活还是要继续，问题还是要解决。经过一番网上查找之后，发现遇到这个问题的不止我一个，真的是大有人在啊！</p></blockquote><p>首先有这个报错，肯定是有网络请求，F12 打开开发者工具，查看 <code>Network</code>项发现报错为:<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_developer.png"><br>这个请求是由 <code>https://cors-anywhere.herokuapp.com/</code> + <code>https://github.com/login/oauth/access_token</code>两部分组成，其实真正的请求地址是后面这个地址，是为了请求token，而 <a href="https://github.com/Rob--W/cors-anywhere"><strong>CORS Anywhere</strong></a> 是一个NodeJS代理，是一个开源框架，使用之后，可以在需要的时候做跨域请求，<code>CORS Anywhere</code> 为了确保每个人都可以使用该服务，每个周期的请求数都受到限制，但来自某些明确列入白名单的来源的请求除外。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_reason.png"><br>这个网站本来是演示用的，<strong>但是由于被滥用，从2021年1月31号开始停止开放，2.1开始用户只能手动先访问这个网站获取临时的访问权限，然后才能使用</strong>。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_solve.png"><br>从 <a href="https://gitalk.github.io/"><strong>Gitalk</strong></a>的 <code>issues</code> 中查到有两种解决方法：更新版本到1.7.2或者修改配置增加 <code>proxy</code>。修改配置增加 <code>proxy</code>方式如下（本博主题为 3-hexo）：</p><ol><li>打开 <code>themes/3-hexo/_config.yml</code>，将<code>gitalk</code>项添加 <code>proxy</code> 配置：<pre><code>gitalk:githubID: repo: ClientID: ClientSecret: adminUser: distractionFreeMode: truelanguage: zh-CNperPage: 10proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</code></pre></li><li>打开 <code>themes/3-hexo/layout/_partial/comments/gitalk.ejs</code> 文件，增加 <code>proxy: &#39;&lt;%=theme.gitalk.proxy %&gt;&#39;,</code>，完整代码为：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_gitalk_request_403_solve_code.png"><br>重新部署Hexo之后，Gitalk评论就能使用了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 添加每日一言或诗词</title>
      <link href="posts/1bafec33.html"/>
      <url>posts/1bafec33.html</url>
      
        <content type="html"><![CDATA[<p>看到好多博客上都带有每日一言或者诗词功能，挺好看的，然后就按耐不住自己的小手手给自己的博客也安排上了。</p><h2 id="1-每日一言"><a href="#1-每日一言" class="headerlink" title="1.每日一言"></a>1.每日一言</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><blockquote><p>一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，有或是单纯的回忆。</p><p align="right">一言官方网站</p></blockquote><p>实现每日一言功能，需借助 <a href="https://links.jianshu.com/go?to=Hitokoto.cn">一言网</a>，创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。</p><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><p>关于每日一言如何使用，一言网关于<a href="https://pa-1251215871.cos-website.ap-chengdu.myqcloud.com/sentence/">语句接口</a>介绍的很详细，以下是以 <code>hexo-3-hexo</code>主题为例的使用说明：</p><p>首先打开主题的 <code>index.ejs</code>文件，路径<code>theme/3-hexo/layout/index.ejs</code>，将下面的代码添加到<code>&lt;body&gt;</code>之前:</p><pre><code>&lt;!-- 一言API --&gt;&lt;!-- 现代写法，推荐 --&gt;&lt;!-- 兼容低版本浏览器 (包括 IE)，可移除 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt;&lt;!--End--&gt;&lt;script&gt;  fetch(&#39;https://v1.hitokoto.cn&#39;)    .then(function (res)&#123;      return res.json();    &#125;)    .then(function (data) &#123;      var hitokoto = document.getElementById(&#39;hitokoto&#39;);      hitokoto.innerText = data.hitokoto + &#39;——【&#39; + data.from + &#39;】&#39;;    &#125;)    .catch(function (err) &#123;      console.error(err);    &#125;)&lt;/script&gt;</code></pre><p>然后再将下面的代码，添加到你想要添加的位置:</p><pre><code>&lt;p id=&quot;hitokoto&quot;&gt;正在加载一言...&lt;/p&gt;</code></pre><p>最后执行hexo三步连操作即可看到效果。</p><h2 id="2-今日诗词"><a href="#2-今日诗词" class="headerlink" title="2.今日诗词"></a>2.今日诗词</h2><p><a href="https://www.jinrishici.com/doc/#about">今日诗词API</a>，是一个可以返回一句古诗词名句的接口。它可以通过图片和 JSON 格式调用。今日诗词 API 根据不同地点、时间、节日、季节、天气、景观、城市进行智能推荐。</p><h3 id="2-1-修改样式"><a href="#2-1-修改样式" class="headerlink" title="2.1 修改样式"></a>2.1 修改样式</h3><p>修改今日诗词显示的样式，也可以不修改哟😜，在\themes\next\source\css\style.styl中适当位置添加以下样式代码：</p><pre><code>/*诗*/.poem-wrap &#123;    position: relative;    width: 730px;    max-width: 80%;    border: 2px solid #797979;    border-top: none;    text-align: center;    margin: 80px auto;&#125; .poem-wrap h1 &#123;    font-size: 30px;    position: relative;    margin-top: -20px;    display: inline-block;    letter-spacing: 4px;    color: #797979&#125; .poem-wrap p &#123;    width: 70%;    margin: auto;    line-height: 30px;    color: #797979;&#125; .poem-wrap p#poem &#123;    font-size: 25px;&#125; .poem-wrap p#info &#123;    font-size: 15px;    margin: 15px auto;&#125; .poem-border &#123;    position: absolute;    height: 2px;    width: 27%;    background-color: #797979;&#125; .poem-right &#123;    right: 0;&#125; .poem-left &#123;    left: 0;&#125; @media (max-width: 685px) &#123;    .poem-border &#123;        width: 18%;    &#125;&#125; @media (max-width: 500px) &#123;    .poem-wrap &#123;        margin-top: 60px;        margin-bottom: 20px;        border-top: 2px solid #797979;    &#125;     .poem-wrap h1 &#123;        margin: 20px 6px;    &#125;     .poem-border &#123;        display: none;    &#125;&#125;</code></pre><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p>在需要使用的 <code>.html</code> 文件或<code>.md</code>中添加:</p><pre><code>&lt;div class=&quot;poem-wrap&quot;&gt;  &lt;div class=&quot;poem-border poem-left&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;poem-border poem-right&quot;&gt;&lt;/div&gt;    &lt;h1&gt;今日诗词&lt;/h1&gt;    &lt;p id=&quot;poem&quot;&gt;挑选中...&lt;/p&gt;    &lt;p id=&quot;info&quot;&gt;  &lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    jinrishici.load(function(result) &#123;      poem.innerHTML = result.data.content      info.innerHTML = &#39;【&#39; + result.data.origin.dynasty + &#39;】&#39; + result.data.origin.author + &#39;《&#39; + result.data.origin.title + &#39;》&#39;      document.getElementById(&quot;poem&quot;).value(poem);      document.getElementById(&quot;info&quot;).value(info);    &#125;);  &lt;/script&gt;&lt;/div&gt;</code></pre><h3 id="2-3-效果"><a href="#2-3-效果" class="headerlink" title="2.3 效果"></a>2.3 效果</h3><div class="poem-wrap">  <div class="poem-border poem-left"></div>  <div class="poem-border poem-right"></div>    <h1>念两句诗</h1>    <p id="poem">挑选中...</p>    <p id="info">  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>  <script type="text/javascript">    jinrishici.load(function(result) {      poem.innerHTML = result.data.content      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'      document.getElementById("poem").value(poem);      document.getElementById("info").value(info);    });  </script></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 主题3-hexo</title>
      <link href="posts/5d51cb1e.html"/>
      <url>posts/5d51cb1e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>一千个读者心中有一千个哈姆雷特，同样的主题也可根据不同人的喜好演变成不同的风格，此博客是自己对主题3-hexo个性化定制的记录。</p></blockquote><h2 id="1-配置首页"><a href="#1-配置首页" class="headerlink" title="1.配置首页"></a>1.配置首页</h2><p>首页文件位置为 <code>/layout/indexs.md</code>，可根据自己需要来配置相关信息。</p><h3 id="1-1-添加每日一言或诗词"><a href="#1-1-添加每日一言或诗词" class="headerlink" title="1.1 添加每日一言或诗词"></a>1.1 添加每日一言或诗词</h3><p>关于如何添加每日一言或诗词，请查看 <a href="/posts/1bafec33.html">Hexo博客 — 添加每日一言或诗词</a></p><h2 id="2-左侧栏"><a href="#2-左侧栏" class="headerlink" title="2.左侧栏"></a>2.左侧栏</h2><h3 id="2-1-修改左侧栏宽度"><a href="#2-1-修改左侧栏宽度" class="headerlink" title="2.1 修改左侧栏宽度"></a>2.1 修改左侧栏宽度</h3><p>打开 <code>themes/_config.yml</code> 文件中，更改对应代码对应的宽度即可</p><pre><code>width:    lg: 120 # 1468px&lt;屏幕宽度 左侧分类宽度    md: 100 # 1024px&lt;屏幕宽度&lt;=1468px 左侧分类宽度    sm: 100 # 426px&lt;屏幕宽度&lt;=1024px 左侧分类宽度（ipad）</code></pre><h3 id="2-2-修改背景颜色"><a href="#2-2-修改背景颜色" class="headerlink" title="2.2 修改背景颜色"></a>2.2 修改背景颜色</h3><p>打开<code>themes/source/css/_partial/nav-left.styl</code>文件，将<code>.nav_left</code>的<code>background</code>设置成自己喜欢的颜色即可</p><h3 id="2-3-修改图片"><a href="#2-3-修改图片" class="headerlink" title="2.3 修改图片"></a>2.3 修改图片</h3><p><code>themes/source/img</code>文件中，<code>avatar.jpg</code>为头像，<code>weixin.jpg</code>和<code>alipay.jpg</code>分别对应打赏的微信和支付宝收款图片，直接将图片替换为自己的即可 </p><h2 id="3-文章列表栏"><a href="#3-文章列表栏" class="headerlink" title="3.文章列表栏"></a>3.文章列表栏</h2><h3 id="3-1-去除文章列表时间"><a href="#3-1-去除文章列表时间" class="headerlink" title="3.1 去除文章列表时间"></a>3.1 去除文章列表时间</h3><p>打开<code>themes/layout/_partial/nav_right.ejs</code> 文件，将下面代码删除即可</p><pre><code>&lt;span class=&quot;post-date&quot; title=&quot;&lt;%= date(post.date, &#39;YYYY-MM-DD HH:mm:ss&#39;)%&gt;&quot;&gt;&lt;%= date(post.date, &#39;YYYY/MM/DD&#39;) %&gt;&lt;/span&gt;</code></pre><h2 id="4-关于文章"><a href="#4-关于文章" class="headerlink" title="4.关于文章"></a>4.关于文章</h2><h3 id="4-1-字数统计"><a href="#4-1-字数统计" class="headerlink" title="4.1 字数统计"></a>4.1 字数统计</h3><pre><code>npm i --save hexo-wordcount</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- Markdown</title>
      <link href="posts/fcf4f4e7.html"/>
      <url>posts/fcf4f4e7.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Markdown概述"><a href="#1-Markdown概述" class="headerlink" title="1.Markdown概述"></a>1.Markdown概述</h2><h3 id="1-1-Markdown简介"><a href="#1-1-Markdown简介" class="headerlink" title="1.1 Markdown简介"></a>1.1 Markdown简介</h3><p>Markdown 是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">轻量级标记语言</a>，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由<a href="https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF">约翰·格鲁伯</a>创建。<br>Markdown 编写的文档可以导出 <code>HTML</code> 、<code>Word</code>、<code>图像</code>、<code>PDF</code>、<code>Epub</code> 等多种格式的文档。<br>Markdown 编写的文档后缀为 <code>.md</code>, <code>.markdown</code>。</p><h3 id="1-2-Markdown应用"><a href="#1-2-Markdown应用" class="headerlink" title="1.2 Markdown应用"></a>1.2 Markdown应用</h3><p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于<code>论坛</code>上发表消息。如<code>GitHub</code>、<code>Reddit</code>、<code>Diaspora</code>、<code>Stack Exchange</code>、<code>OpenStreetMap</code> 、<code>SourceForge</code>、<code>简书</code>等，甚至还能被用来撰写<code>电子书</code>。</p><h2 id="2-Markdown基础技巧"><a href="#2-Markdown基础技巧" class="headerlink" title="2.Markdown基础技巧"></a>2.Markdown基础技巧</h2><h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>Markdown 支持两种标题的语法，类 <code>Setext</code> 和类 <code>atx</code> 形式。</p><h4 id="2-1-1-使用-和-标记一级和二级标题"><a href="#2-1-1-使用-和-标记一级和二级标题" class="headerlink" title="2.1.1 使用 = 和 - 标记一级和二级标题"></a>2.1.1 使用 <code>=</code> 和 <code>-</code> 标记一级和二级标题</h4><p>类 <code>Setext</code> 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><pre><code>我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><h4 id="2-1-2-使用-号标记"><a href="#2-1-2-使用-号标记" class="headerlink" title="2.1.2 使用 # 号标记"></a>2.1.2 使用 <code>#</code> 号标记</h4><p>使用 <code>#</code> 号可表示 <code>1-6</code> 级标题，一级标题对应一个 <code>#</code> 号，二级标题对应两个 <code>#</code> 号，以此类推:</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h3 id="2-2-段落格式"><a href="#2-2-段落格式" class="headerlink" title="2.2 段落格式"></a>2.2 段落格式</h3><h4 id="2-2-1-段落"><a href="#2-2-1-段落" class="headerlink" title="2.2.1 段落"></a>2.2.1 段落</h4><p>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在 <code>Visual Studio Code上</code>，<strong>段落的换行是使用两个以上空格加上回车</strong>。</p><h4 id="2-2-2-字体"><a href="#2-2-2-字体" class="headerlink" title="2.2.2 字体"></a>2.2.2 字体</h4><p>Markdown 可以使用以下几种字体：</p><pre><code>*斜体* 或 _斜体_**粗体** 或 __粗体文本__***加粗斜体*** 或 ___粗斜体文本___~~删除线~~++下划线++</code></pre><h4 id="2-2-3-对齐方式"><a href="#2-2-3-对齐方式" class="headerlink" title="2.2.3 对齐方式"></a>2.2.3 对齐方式</h4><pre><code>&lt;p align=&quot;left&quot;&gt;居左对齐&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;居右对齐&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;居中对齐&lt;/p&gt;</code></pre><h4 id="2-2-3-分隔线"><a href="#2-2-3-分隔线" class="headerlink" title="2.2.3 分隔线"></a>2.2.3 分隔线</h4><p>可以在一行中用三个以上的<code>*</code>(星号)、<code>-</code>(减号)、<code>_</code>(底线)来建立一个分隔线，行内不能有其他东西，也可以在星号或是减号中间插入空格:</p><pre><code>**** * ******- - -----------</code></pre><h4 id="2-2-4-删除线"><a href="#2-2-4-删除线" class="headerlink" title="2.2.4 删除线"></a>2.2.4 删除线</h4><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可:</p><pre><code>~~删除线~~</code></pre><h4 id="2-2-5-下划线"><a href="#2-2-5-下划线" class="headerlink" title="2.2.5 下划线"></a>2.2.5 下划线</h4><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现:</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><h3 id="2-3-列表"><a href="#2-3-列表" class="headerlink" title="2.3 列表"></a>2.3 列表</h3><h4 id="2-3-1-无序列表"><a href="#2-3-1-无序列表" class="headerlink" title="2.3.1 无序列表"></a>2.3.1 无序列表</h4><p>无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记，<strong>这些标记后面要添加一个空格</strong>，然后再填写内容:</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>以上三种写法显示效果一样，如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="2-3-2-有序列表"><a href="#2-3-2-有序列表" class="headerlink" title="2.3.2 有序列表"></a>2.3.2 有序列表</h4><p>有序列表使用<code>数字</code> + <code>.</code> 号来表示:</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>显示效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h4 id="2-3-3-列表嵌套"><a href="#2-3-3-列表嵌套" class="headerlink" title="2.3.3 列表嵌套"></a>2.3.3 列表嵌套</h4><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>显示效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h3 id="2-4-引用Blockquotes"><a href="#2-4-引用Blockquotes" class="headerlink" title="2.4 引用Blockquotes"></a>2.4 引用Blockquotes</h3><h4 id="2-4-1-普通引用"><a href="#2-4-1-普通引用" class="headerlink" title="2.4.1 普通引用"></a>2.4.1 普通引用</h4><p>Markdown 引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个<code>空格</code>符号:</p><pre><code>&gt; 学习是劳动，是充满思想的劳动。——乌申斯基</code></pre><p>显示效果如下：</p><blockquote><p>学习是劳动，是充满思想的劳动。——乌申斯基</p></blockquote><h4 id="2-4-2-引用嵌套"><a href="#2-4-2-引用嵌套" class="headerlink" title="2.4.2 引用嵌套"></a>2.4.2 引用嵌套</h4><p>引用是可以嵌套的，一个 <code>&gt;</code> 符号是最外层，两个 <code>&gt;</code> 符号是第一层嵌套，以此类推：</p><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>显示效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h4 id="2-4-3-引用中使用列表"><a href="#2-4-3-引用中使用列表" class="headerlink" title="2.4.3 引用中使用列表"></a>2.4.3 引用中使用列表</h4><p>引用中使用列表实例如下：</p><pre><code>&gt; 引用中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><p>显示效果如下：</p><blockquote><p>引用中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h4 id="2-4-4-列表中使用引用"><a href="#2-4-4-列表中使用引用" class="headerlink" title="2.4.4 列表中使用引用"></a>2.4.4 列表中使用引用</h4><p>如果要在列表项目内放进引用，那么就需要在 <code>&gt;</code> 前添加四个空格的缩进，实例如下：</p><pre><code>* 第一项    &gt; 学习呀    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><p>显示效果如下：</p><ul><li>第一项<blockquote><p>学习呀<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h3 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h3><h4 id="2-5-1-关键字"><a href="#2-5-1-关键字" class="headerlink" title="2.5.1 关键字"></a>2.5.1 关键字</h4><p>如果是段落上的一个函数或片段的代码可以用 `` 把它包起来：</p><pre><code>`code` 代码</code></pre><h4 id="2-5-2-代码块"><a href="#2-5-2-代码块" class="headerlink" title="2.5.2 代码块"></a>2.5.2 代码块</h4><ul><li>可以用 ``` 包裹一段代码，并指定一种语言，也可以不指定：</li><li>使用 <strong>4 个空格</strong>或者一个制表符（<strong>Tab 键</strong>）<br>效果如下：<pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="2-6-链接"><a href="#2-6-链接" class="headerlink" title="2.6 链接"></a>2.6 链接</h3><h4 id="2-6-1-常用链接"><a href="#2-6-1-常用链接" class="headerlink" title="2.6.1 常用链接"></a>2.6.1 常用链接</h4><pre><code>文字链接 [链接名称](http://链接网址)网址链接 &lt;http://链接网址&gt;</code></pre><h4 id="2-6-2-高级链接"><a href="#2-6-2-高级链接" class="headerlink" title="2.6.2 高级链接"></a>2.6.2 高级链接</h4><pre><code>这个链接用 1 作为网址变量 [Google][1].这个链接用 `百度` 作为网址变量 [百度!][百度].然后在文档的结尾为变量赋值（网址）  [1]: https://www.google.com/  [百度]: https://www.baidu.com/</code></pre><h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><p>跟链接的方法区别在于前面加了个感叹号 <code>!</code>:</p><pre><code>![图片名称](https://图片网址)</code></pre><p>也可以像网址那样对图片网址使用变量:</p><pre><code>这个链接用 1 作为网址变量 [Google][1].然后在文档的结尾位变量赋值（网址） [1]: https://www.google.com/logo.png</code></pre><blockquote><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签:<br><code>&lt;img src=&quot;https://developer.apple.com/home/images/hero-ios-14/ios-14-large_2x.png&quot; width=&quot;50%&quot;&gt;</code><br><img src="https://developer.apple.com/home/images/hero-ios-14/ios-14-large_2x.png" width="50%"></p></blockquote><h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p><pre><code>|  表头   | 表头  || :----: | :---: || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><blockquote><p>表格的对齐方式：<br><code>-:</code> 设置内容和标题栏居右对齐<br><code>:-</code> 设置内容和标题栏居左对齐<br><code>:-:</code> 设置内容和标题栏居中对齐</p></blockquote><h2 id="3-高级技巧"><a href="#3-高级技巧" class="headerlink" title="3 高级技巧"></a>3 高级技巧</h2><h3 id="3-1-行内-HTML-元素"><a href="#3-1-行内-HTML-元素" class="headerlink" title="3.1 行内 HTML 元素"></a>3.1 行内 HTML 元素</h3><p>目前只支持部分段内 HTML 元素效果，包括 <code>&lt;kdb&gt;</code> <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;em&gt;</code> <code>&lt;sup&gt;</code> <code>&lt;sub&gt;</code> <code>&lt;br&gt;</code> ，如:</p><ul><li>键位显示<pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre></li><li>代码块<pre><code>使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块</code></pre></li><li>粗斜体<pre><code>&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt;</code></pre></li></ul><h3 id="3-2-符号转义"><a href="#3-2-符号转义" class="headerlink" title="3.2 符号转义"></a>3.2 符号转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用<code>反斜杠</code>转义特殊字符：</p><pre><code>\_不想这里的文本变斜体\_\*\*不想这里的文本被加粗\*\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h2 id="4-在线Markdown编辑器"><a href="#4-在线Markdown编辑器" class="headerlink" title="4.在线Markdown编辑器"></a>4.在线Markdown编辑器</h2><ul><li><a href="http://markdown.xiaoshujiang.com/">【<strong>小书匠</strong>】</a>：专为markdown写作设计的文档编辑器，多种编辑模式，多种主题选择，丰富的语法支持。</li><li>【<strong>Visual Studio Code</strong>】：微软推出一款轻量级的文本编辑工具，类似于 Sublime。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 写文章</title>
      <link href="posts/2507c73c.html"/>
      <url>posts/2507c73c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建文章模版"><a href="#1-创建文章模版" class="headerlink" title="1.创建文章模版"></a>1.创建文章模版</h2><h3 id="1-1-文章模版"><a href="#1-1-文章模版" class="headerlink" title="1.1 文章模版"></a>1.1 文章模版</h3><p>为了新建文章方便，我们可以修改一下文章模板，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre><code>---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:tags:categories:---</code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，修改对应信息就可以了</p><h3 id="1-2-Front-matter"><a href="#1-2-Front-matter" class="headerlink" title="1.2 Front-matter"></a>1.2 Front-matter</h3><p><code>Front-matter</code> 选项中的所有内容均为非必填的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值</p><table><thead><tr><th align="center">配置选项</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">Markdown的文件标题</td><td align="center">文章标题</td></tr><tr><td align="center">date</td><td align="center">文件创建时的日期时间</td><td align="center">发布时间</td></tr><tr><td align="center">author</td><td align="center">根 <code>_config.yml</code> 中的 <code>author</code></td><td align="center">文章作者</td></tr><tr><td align="center">img</td><td align="center"><code>featureImages</code> 中的某个值</td><td align="center">文章特征图</td></tr><tr><td align="center">top</td><td align="center"><code>true</code></td><td align="center">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="center">cover</td><td align="center"><code>false</code></td><td align="center">表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="center">coverImg</td><td align="center">无</td><td align="center">表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="center">password</td><td align="center">无</td><td align="center">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="center">toc</td><td align="center"><code>true</code></td><td align="center">是否开启 <code>TOC</code>，可以针对某篇文章单独关闭 <code>TOC</code> 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="center">mathjax</td><td align="center"><code>false</code></td><td align="center">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="center">summary</td><td align="center">无</td><td align="center">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="center">categories</td><td align="center">无</td><td align="center">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="center">tags</td><td align="center">无</td><td align="center">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p>注意：</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code> 加密的 <code>password</code> 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 <code>SHA256</code> 加密的地址，可供使用：开源中国在线工具、chahuo、站长工具。</li></ol></blockquote><h2 id="2-创建文章"><a href="#2-创建文章" class="headerlink" title="2.创建文章"></a>2.创建文章</h2><h3 id="2-1-直接创建"><a href="#2-1-直接创建" class="headerlink" title="2.1 直接创建"></a>2.1 直接创建</h3><p>可以通过以下命令创建文章，该文件所在目录为 <code>_posts/xxxx.md</code></p><pre><code>$ hexo new xxxx.md</code></pre><h3 id="2-2-按分类创建文章"><a href="#2-2-按分类创建文章" class="headerlink" title="2.2 按分类创建文章"></a>2.2 按分类创建文章</h3><p>直接通过 <code>hexo new post xxxx.md</code> 来创建的文章，所有都在 <code>_posts</code>目录下，这样很不好归类查找，如果想在 _posts 目录下创建子目录分类文章的话，可通过下面方式创建</p><pre><code>$ hexo new post -p 目录1/目录2/.../文章.md</code></pre><h2 id="3-文章技巧"><a href="#3-文章技巧" class="headerlink" title="3.文章技巧"></a>3.文章技巧</h2><h3 id="3-1-文章添加图片"><a href="#3-1-文章添加图片" class="headerlink" title="3.1 文章添加图片"></a>3.1 文章添加图片</h3><h4 id="3-1-1-本地引用"><a href="#3-1-1-本地引用" class="headerlink" title="3.1.1 本地引用"></a>3.1.1 本地引用</h4><ol><li>绝对路径<br>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 <code>source/images</code> 文件夹中，通过 <code>markdown</code> 语法访问它们<pre><code>![](/images/image.jpg)</code></pre></li><li>相对路径<br>直接放在文章自己的目录中，需要将hexo根目录下的 <code>_config.yml</code> 配置文件中的 <code>post_asset_folder</code> 设为 <code>true</code> ，然后执行：<pre><code>$ cnpm install hexo-asset-image</code></pre>此时再执行命令 <code>hexo n article_name</code> 创建新的文章，在 <code>source/_posts</code> 中会生成文章 <code>post_name.md</code> 和同名文件夹 <code>post_name</code>，我们文章中所使用到的图片资源均放在 <code>post_name</code> 中，这时就可以在文章中使用相对路径引用图片资源了：<pre><code>![](img_name.jpg) //文章中的图片资源路径格式</code></pre><h4 id="3-1-2-CDN"><a href="#3-1-2-CDN" class="headerlink" title="3.1.2 CDN"></a>3.1.2 CDN</h4>将图片上传到一些免费的<code>CDN</code>服务中。比如 <code>Cloudinary</code> 提供的图片CDN服务，在 <code>Cloudinary</code> 中上传图片后，会生成对应的 <code>url</code>地址，将地址直接拿来引用即可。</li></ol><h3 id="3-2-生成永久文章链接"><a href="#3-2-生成永久文章链接" class="headerlink" title="3.2 生成永久文章链接"></a>3.2 生成永久文章链接</h3><p>hexo博客文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。比如：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_article_link.png" alt="image"><br>这样，如果文章标题是中文的话，URL链接是也会是中文。而且跳转站内文章填写链接的时候也不方便，修改文章标题后url就变了，以前的文章地址变成了404，就很不灵活，容易出错，所以生成唯一不变的URL链接很有必要。</p><h4 id="3-2-1-安装-hexo-abbrlink-插件"><a href="#3-2-1-安装-hexo-abbrlink-插件" class="headerlink" title="3.2.1 安装 hexo-abbrlink 插件"></a>3.2.1 安装 hexo-abbrlink 插件</h4><p>安装命令：</p><pre><code>npm install hexo-abbrlink --save</code></pre><h4 id="3-2-2-配置"><a href="#3-2-2-配置" class="headerlink" title="3.2.2 配置"></a>3.2.2 配置</h4><p>修改根目录配置文件 <code>config.yml</code>，改为：</p><pre><code># permalink: :year/:month/:day/:title/permalink: posts/:abbrlink.html  #此处可以自己设置，最终链接格式为：https://博客站点/permalinkabbrlink:    alg: crc32   #算法： crc16(default) and crc32    rep: hex     #进制： dec(default) and hex</code></pre><p>生成完后，原 <code>md文件</code> 的 <code>Front-matter</code> 内会增加 <code>abbrlink</code> 字段，值为生成的<code>ID</code>。这个字段确保了在我们修改了博客标题title或创建日期date字段之后而不会改变链接地址。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 环境搭建</title>
      <link href="posts/5bd46458.html"/>
      <url>posts/5bd46458.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于博客"><a href="#1-关于博客" class="headerlink" title="1.关于博客"></a>1.关于博客</h2><p>喜欢写Blog的人，会经历三个阶段。</p><blockquote><p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</p></blockquote><blockquote><p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p></blockquote><blockquote><p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p></blockquote><p>我们每个人的在网络上产生的数据越来越多，这些信息是我们在互联网上存在过的痕迹，值得我们认真对待。但是它们被分散分布在各个网站上。很多时候我们很难将它们聚合在一起，而且各个网站的信息排布方式也没有办法自由控制，所以我们需要一个可以由自己主宰的空间——博客。</p><p>通过博客，我们可以记录自己的生活和成长的轨迹。它不像 Twitter 那样碎片化，也不像 Facebook 那样关系化，它是私人的空间。</p><blockquote><p>之前写文章用的比较多的是印象笔记，较早时候感觉印象笔记还是挺好的，但是随着后来自己要求的慢慢变高，就觉得印象笔记里面编辑出来的文章样式不满足自己的需求，再加上创建带目录的文章竟然需要购买会员。然后就萌生自己搭建博客的想法，然后就从网上查了相关资料和介绍，在前人的基础上搭建了一个简单的博客(<code>Hexo+GitHub</code>)</p></blockquote><p>本篇博客旨在记录自己的搭建过程，方便以后的查看和修改，当然还有一些优化项和功能后续会慢慢更新。</p><h2 id="2-关于Hexo"><a href="#2-关于Hexo" class="headerlink" title="2.关于Hexo"></a>2.关于Hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a>基于<code>Node.js</code>，使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，可利用靓丽的主题生成静态网页，而且只需两三条命令即可将生成的网页上传到<code>github</code>等代码管理托管平台，简单、快速，是搭建博客的首选框架。</p><blockquote><p><code>Hexo</code>的作者是来自台湾的 <a href="https://zespia.tw/">Tommy Chen</a>，对中文的支持很友好，可以选择中文进行查看。</p></blockquote><p>Hexo特点:</p><ul><li>部署方便并且速度</li><li>支持 <code>Markdown</code>语法</li><li>使用极简命令即可部署到<code>GitHub Pages</code></li><li>高扩展性、可个性化定制</li><li>兼容于 <code>Windows</code>, <code>Mac</code> &amp; <code>Linux</code></li></ul><h2 id="3-搭建"><a href="#3-搭建" class="headerlink" title="3.搭建"></a>3.搭建</h2><p>本人使用Mac电脑，以此只记录了Mac电脑下的搭建过程</p><h3 id="3-1-安装Git"><a href="#3-1-安装Git" class="headerlink" title="3.1 安装Git"></a>3.1 安装Git</h3><p>什么是<code>Git</code>？关于<code>Git</code>，廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a>讲的特别好，大家可以去看看，也可以直接查看 <a href="https://git-scm.com/book/zh/v2">Git官网 Pro Git Book</a>中的讲解。而我们为了把本地的网页文件上传到<code>github</code>上面去，需要用到分布式版本控制工具<code>Git</code>。</p><p>在 <code>Mac</code> 上安装 <code>Git</code> 有多种方式。最简单的方法是安装 <code>Xcode Command Line Tools</code>。 Mavericks（10.9）或更高版本的系统中，在 <code>Terminal</code> 里尝试首次运行 <code>git</code> 命令即可。</p><pre><code>$ git --version</code></pre><p>如果没有安装过命令行开发者工具，将会提示你安装。</p><p>如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 macOS Git 安装程序可以在 Git 官方网站下载，网址为 <a href="https://git-scm.com/download/mac%E3%80%82">https://git-scm.com/download/mac。</a></p><pre><code>git --version</code></pre><blockquote><p>如果你想安装更新的版本，可以使用二进制安装程序。官方维护的 <code>macOS Git</code> 安装程序可以在 <code>Git</code> 官方网站下载，网址为 <a href="https://git-scm.com/download/mac">https://git-scm.com/download/mac</a></p></blockquote><h3 id="3-2-安装Node-js"><a href="#3-2-安装Node-js" class="headerlink" title="3.2 安装Node.js"></a>3.2 安装Node.js</h3><p>打开 <a href="https://nodejs.org/en/download/">Node.js</a> 下载页面，直接选择 <code>macOS Installer</code> 下载，然后双击已下载的<code>pkg</code>文件安装即可。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_node_js_download.png"><br>安装完成之后，可通过以下命令来检查是否安装成功:</p><pre><code>node -v</code></pre><h3 id="3-3-安装Hexo"><a href="#3-3-安装Hexo" class="headerlink" title="3.3 安装Hexo"></a>3.3 安装Hexo</h3><p>安装完 <code>Git</code> 和 <code>Node.js</code>之后，即可使用 <code>npm</code> 安装 <code>Hexo</code>。终端输入如下命令：</p><pre><code>sudo npm install -g hexo-cli</code></pre><p>安装完成之后输入 <code>hexo -v</code> 验证是否安装成功。</p><blockquote><p>Hexo官网上的安装命令是 <code>npm install -g hexo-cli</code>，但是实际安装的时候需要加上 <code>sudo</code>，否则会因为权限问题报错而导致安装失败</p></blockquote><h4 id="3-3-1-初始化"><a href="#3-3-1-初始化" class="headerlink" title="3.3.1 初始化"></a>3.3.1 初始化</h4><p>使用终端 <code>cd</code> 到一个文件目录，执行以下命令（命令中的 <code>Blog</code> 是要创建的博客文件夹）:</p><pre><code>hexo init Blog</code></pre><p>使用终端 <code>cd</code> 到 <code>Blog</code> 文件夹下，执行以下命令，安装必备的组件：</p><pre><code>cd Blognpm install</code></pre><p>安装完成之后，<code>Blog</code> 目录下有：</p><ul><li><code>node_modules</code>: 依赖包</li><li><code>public</code>: 存放生成的页面</li><li><code>scaffolds</code>: 生成文章的一些模板</li><li><code>source</code>: 用来存放你的文章</li><li><code>themes</code>: 安装的主题</li><li><code>_config.yml</code>: 博客的配置文件</li></ul><h4 id="3-3-2-本地预览"><a href="#3-3-2-本地预览" class="headerlink" title="3.3.2 本地预览"></a>3.3.2 本地预览</h4><p>经过上面步骤之后，基本的博客系统就已经搭建好了，而且自带了 <code>landscape</code> 主题，执行如下命令，开启本地 <code>Hexo</code> 服务器:</p><pre><code>sudo npm install hexo-server  //安装hexo serverhexo generate //或者 hexo g，生成静态页面hexo server //或者 hexo s，本地预览</code></pre><p>然后浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_landscape.png"></p><h3 id="3-4-将Hexo部署到GitHub-Pages"><a href="#3-4-将Hexo部署到GitHub-Pages" class="headerlink" title="3.4 将Hexo部署到GitHub Pages"></a>3.4 将Hexo部署到GitHub Pages</h3><h4 id="3-4-1-创建仓库"><a href="#3-4-1-创建仓库" class="headerlink" title="3.4.1 创建仓库"></a>3.4.1 创建仓库</h4><p>登录 <a href="https://github.com/">GitHub</a> 账号，新建名称为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 的仓库，具体如下图所示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_creat.png"></p><h4 id="3-4-2-开启GitHub-Pages"><a href="#3-4-2-开启GitHub-Pages" class="headerlink" title="3.4.2 开启GitHub Pages"></a>3.4.2 开启GitHub Pages</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_setting.png"><br>点击 <code>setting</code> ,打开创建的仓库的设置页面，滑动到 <code>GitHub Pages</code> 位置，进行如下设置，这样才能通过 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>来访问<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_pages.png"></p><h4 id="3-4-3-生成SSH添加到GitHub"><a href="#3-4-3-生成SSH添加到GitHub" class="headerlink" title="3.4.3 生成SSH添加到GitHub"></a>3.4.3 生成SSH添加到GitHub</h4><p><code>GitHub</code> 使用 <code>SSH</code> 公钥进行认证，关于 <code>SSH</code> 相关内容可以直接查看另一篇博客<a href="2021/03/07/%E5%B7%A5%E5%85%B7/Terminal/Terminal---%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5">Terminal—生成SSH公钥</a></p><p>在 <code>GitHub</code> 中，点击头像打开 <code>Setting</code> 页面，将 <code>SSH</code> 添加到 <code>SSH and GPG keys</code>中，如下图所示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_ssh.png"><br>然后在终端输入 <code>ssh -T git@github.com</code>，如果出现 <code>Hi xxx! You&#39;ve successfully authenticated...</code>，那么恭喜你，添加成功了。</p><h4 id="3-4-4-将Hexo部署到GitHub-Pages"><a href="#3-4-4-将Hexo部署到GitHub-Pages" class="headerlink" title="3.4.4 将Hexo部署到GitHub Pages"></a>3.4.4 将Hexo部署到GitHub Pages</h4><p>打开 <code>Blog</code> 根目录下的 <code>_config.yml</code> 文件，这是博客的配置文件，在这里可以修改博客配置的各种相关信息，修改 <code>deploy</code> 相关信息如下：</p><pre><code>deploy:  type: git  repository: https://github.com/xxx/xxx.github.io.git //此地址为自己github的仓库地址  branch: master</code></pre><blockquote><p>修改 <code>_config.yml</code> 文件时，所有的冒号 <code>:</code> 后面都要加一个空格，否则执行命令时会报错。</p></blockquote><p>配置之后，<code>Hexo</code> 和 <code>GitHub</code> 就能关联起来，部署时，就可以将生成的静态网页上传到上面填写的仓库中。</p><p>然后就可以通过下面命令，将本地 <code>Hexo</code> 博客部署到 <code>GitHub</code> 上：</p><pre><code>npm install hexo-deployer-git --save //安装 deploy-githexo clean  //清除之前生成的静态文件hexo g  //生成静态页面至public目录hexo d  //将.deploy目录部署到GitHub</code></pre><p>至此博客已部署完成，可以通过 <code>https://xxx.github.io/</code> 来访问你的博客啦！！！</p><h2 id="4-个性化定制"><a href="#4-个性化定制" class="headerlink" title="4.个性化定制"></a>4.个性化定制</h2><h3 id="4-1-基本配置"><a href="#4-1-基本配置" class="headerlink" title="4.1 基本配置"></a>4.1 基本配置</h3><p>在文件根目录下的 <code>_config.yml</code> ，就是整个hexo框架的配置文件，可在文件中设置博客站点的标题、副标题等相关信息。</p><h4 id="4-1-1-新建page"><a href="#4-1-1-新建page" class="headerlink" title="4.1.1 新建page"></a>4.1.1 新建page</h4><p>如果新建page页，可以使用</p><pre><code>hexo new page newpage</code></pre><p>系统会自动在<code>source</code>文件夹下创建一个<code>newpage</code>文件夹，以及<code>newpage</code>文件夹中的<code>index.md</code>，这样访问的<code>newpage</code>对应的链接就是<a href="http://xxx.xxx/newpage">http://xxx.xxx/newpage</a></p><h4 id="4-1-2-新建分类categories页"><a href="#4-1-2-新建分类categories页" class="headerlink" title="4.1.2 新建分类categories页"></a>4.1.2 新建分类categories页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;categories&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code>---title: categoriesdate: 2021-03-03 08:25:30type: &quot;categories&quot;layout: &quot;categories&quot;---</code></pre><h4 id="4-1-3-新建标签tags页"><a href="#4-1-3-新建标签tags页" class="headerlink" title="4.1.3 新建标签tags页"></a>4.1.3 新建标签tags页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;tags&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code>---title: tagsdate: 2021-03-03 08:25:30type: &quot;tags&quot;layout: &quot;tags&quot;---</code></pre><h4 id="4-1-4-新建关于我about页"><a href="#4-1-4-新建关于我about页" class="headerlink" title="4.1.4 新建关于我about页"></a>4.1.4 新建关于我about页</h4><p><code>about</code> 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;about&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code>---title: aboutdate: 2021-03-03 08:25:30type: &quot;about&quot;layout: &quot;about&quot;---</code></pre><h4 id="4-1-5-添加404页面"><a href="#4-1-5-添加404页面" class="headerlink" title="4.1.5 添加404页面"></a>4.1.5 添加404页面</h4><p>原来的主题没有<code>404</code>页面，我们加一个。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><pre><code>title: 404date: 2019-08-5 16:41:10type: &quot;404&quot;layout: &quot;404&quot;description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;</code></pre><p>网上好多都说要在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件(注：我安装的主题在该目录下已有<code>404.ejs</code>文件，无需自己创建)</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    /* don&#39;t remove. */    .about-cover &#123;        height: 75vh;    &#125;&lt;/style&gt;&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;                &lt;div class=&quot;brand&quot;&gt;                    &lt;div class=&quot;title center-align&quot;&gt;                        404                    &lt;/div&gt;                    &lt;div class=&quot;description center-align&quot;&gt;                        &lt;%= page.description %&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 每天切换 banner 图.  Switch banner image every day.    $(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);&lt;/script&gt;</code></pre><h3 id="4-2-更换主题"><a href="#4-2-更换主题" class="headerlink" title="4.2 更换主题"></a>4.2 更换主题</h3><p>hexo 搭建之后默认安装的主题是 <code>landscape</code>，更多风格主题查看 <a href="https://hexo.io/themes/">Hexo官网Themes</a>，可以从里面选择自己喜欢的主题进行安装。</p><h4 id="4-2-1-主题推荐"><a href="#4-2-1-主题推荐" class="headerlink" title="4.2.1 主题推荐"></a>4.2.1 主题推荐</h4><ul><li><a href="https://github.com/next-theme/hexo-theme-next">NexT主题</a>：简洁美观，目前Github上Star最高的Hexo主题，支持几种不同的风格。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_next.png"></li><li><a href="https://github.com/blinkfox/hexo-theme-matery">Metery主题</a>：简单漂亮，瀑布流式的文章列表，文章内容美观易读。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_matery.png"></li><li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">Wikitten主题</a>：简单，双列，分类管理，具备多层次分类知识，适用于个人Wiki知识管理。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_theme_preview_wikitten.png"></li></ul><h4 id="4-2-2-主题安装"><a href="#4-2-2-主题安装" class="headerlink" title="4.2.2 主题安装"></a>4.2.2 主题安装</h4><p>我们所有的主题都被放在根目录 <code>/themes</code> 文件夹下，可以将主题的的源码下载到 <code>/themes</code> 文件夹下，然后将 Hexo 根目录下的 <code>_config.yml</code> 中的主题设置为下载的主题：</p><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: 主题 #更改为自己下载的主题</code></pre><p>配置好后，执行 <code>hexo clean</code> 和 <code>hexo g &amp; s</code> 就能看到博客已经更换成新安装的主题风格了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
