<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jenkins --- 安装</title>
      <link href="2021/03/11/%E5%B7%A5%E5%85%B7/Jenkins/Jenkins-%E5%AE%89%E8%A3%85/"/>
      <url>2021/03/11/%E5%B7%A5%E5%85%B7/Jenkins/Jenkins-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装java环境"><a href="#1-安装java环境" class="headerlink" title="1. 安装java环境"></a>1. 安装java环境</h2><p><code>Jenkins</code> 是一个用Java编写的持续集成工具，依赖于Java，所以在安装Jenkins前，需要先安装Java环境，可用以下命令检查是否安装：</p><pre><code>$ java -version</code></pre><p>如果已安装的话，会有以下内容的输出：</p><pre><code>java version &quot;15.0.2&quot; 2021-01-19Java(TM) SE Runtime Environment (build 15.0.2+7-27)Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</code></pre><p>如果没有安装的话，会提示<code>No Java runtime present, requesting install.</code>，可通过下面两种方式安装。</p><h3 id="1-1-官网下载-Java-SDK"><a href="#1-1-官网下载-Java-SDK" class="headerlink" title="1.1 官网下载 Java SDK"></a>1.1 官网下载 Java SDK</h3><p>通过 <code>java -version</code> 命令检查是否安装的时候，如果没有安装，会有如下提示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_java_install_alert.png"><br>点击更多信息，会直接跳转到<a href="https://www.oracle.com/java/technologies/javase-jdk15-downloads.html">Java官网</a>下载，下载之后按照安装提示安装即可。<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_java_download.png"></p><h3 id="1-2-HomeBrew命令行安装"><a href="#1-2-HomeBrew命令行安装" class="headerlink" title="1.2 HomeBrew命令行安装"></a>1.2 HomeBrew命令行安装</h3><p>可通过 <code>brew install java</code> 命令安装java，执行之后如果输出以下内容，则代表安装成功：</p><pre><code>$ brew install javaUpdating Homebrew...==&gt; Auto-updated Homebrew!Updated 3 taps (homebrew/cask-versions, homebrew/core and homebrew/cask).==&gt; New Formulaeqt-libiodbc                   qt-mysql                      qt-postgresql                 xrayqt-mariadb                    qt-percona-server             qt-unixodbc==&gt; Updated FormulaeUpdated 30 formulae.==&gt; Updated CasksUpdated 11 casks.==&gt; Downloading https://homebrew.bintray.com/bottles/openjdk-15.0.2.catalina.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring openjdk-15.0.2.catalina.bottle.tar.gz==&gt; CaveatsFor the system Java wrappers to find this JDK, symlink it with  sudo ln -sfn /usr/local/opt/openjdk/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdkopenjdk is keg-only, which means it was not symlinked into /usr/local,because macOS provides similar software and installing this software inparallel can cause all kinds of trouble.If you need to have openjdk first in your PATH, run:  echo &#39;export PATH=&quot;/usr/local/opt/openjdk/bin:$PATH&quot;&#39; &gt;&gt; /Users/wangruifang/.bash_profileFor compilers to find openjdk you may need to set:  export CPPFLAGS=&quot;-I/usr/local/opt/openjdk/include&quot;==&gt; Summary🍺  /usr/local/Cellar/openjdk/15.0.2: 614 files, 324.9MB</code></pre><blockquote><p>从官网下载安装比较简单，HomeBrew命令行安装过程中容易出错（此篇文章第三部分记录的就是安装过程中遇到的问题）。</p></blockquote><h2 id="2-安装Jenkins"><a href="#2-安装Jenkins" class="headerlink" title="2.安装Jenkins"></a>2.安装Jenkins</h2><p>通安装java环境以下，Jenkins的安装也有两种方式</p><h3 id="2-1-安装包下载安装"><a href="#2-1-安装包下载安装" class="headerlink" title="2.1 安装包下载安装"></a>2.1 安装包下载安装</h3><p>前往<a href="https://www.jenkins.io/">Jenkins官网</a>下载 <code>.pkg</code> 安装包进行安装即可。</p><h3 id="2-2-HomeBrew命令行安装"><a href="#2-2-HomeBrew命令行安装" class="headerlink" title="2.2 HomeBrew命令行安装"></a>2.2 HomeBrew命令行安装</h3><p>可直接通过 <code>brew install jenkins</code> 命令安装：</p><pre><code>$ brew install jenkins</code></pre><p>安装结束后，可根据需要执行以下命令：</p><pre><code>// For the system Java wrappers to find this JDK, symlink it with$ sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk// openjdk@11 is keg-only, which means it was not symlinked into /usr/local, because this is an alternate version of another formula.// If you need to have openjdk@11 first in your PATH, run:$ echo &#39;export PATH=&quot;/usr/local/opt/openjdk@11/bin:$PATH&quot;&#39; &gt;&gt; /Users/wangruifang/.bash_profile//For compilers to find openjdk@11 you may need to set:$ export CPPFLAGS=&quot;-I/usr/local/opt/openjdk@11/include&quot;</code></pre><h2 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h2><p>安装完成之后，在终端输入命令：</p><pre><code>$ jenkins 或者$ brew services start jenkins </code></pre><p>启动 jenkins 服务，即可在浏览器中<a href="http://localhost:8080/">http://localhost:8080</a>中访问</p><blockquote><p><code>brew services start jenkins</code> 命令与 <code>jenkins</code> 的区别是：当终端关闭时，jenkins服务还可以继续使用。</p></blockquote><h3 id="3-1-解锁Jenkins"><a href="#3-1-解锁Jenkins" class="headerlink" title="3.1 解锁Jenkins"></a>3.1 解锁Jenkins</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_unlocking.png"><br>按照图中描述输入 <code>cat</code> + <code>密码路径</code>，获取密码复制到管理员密码框中，然后下一步:</p><pre><code>$ cat /Users/用户名/.jenkins/secrets/initialAdminPassword</code></pre><h3 id="3-2-选择安装推荐的插件"><a href="#3-2-选择安装推荐的插件" class="headerlink" title="3.2 选择安装推荐的插件"></a>3.2 选择安装推荐的插件</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_plugins_choice.png"></p><h3 id="3-3-等待插件安装"><a href="#3-3-等待插件安装" class="headerlink" title="3.3 等待插件安装"></a>3.3 等待插件安装</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_plugins_install.png"></p><blockquote><p>这个过程可能会有插件安装失败，在进度完成之后可重试，会再次安装失败的插件</p></blockquote><h3 id="3-4-创建管理员用户"><a href="#3-4-创建管理员用户" class="headerlink" title="3.4 创建管理员用户"></a>3.4 创建管理员用户</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_create_admin.png"></p><h3 id="3-5-实例配置"><a href="#3-5-实例配置" class="headerlink" title="3.5 实例配置"></a>3.5 实例配置</h3><p><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_instance_config.png"><br>使用默认端口就可以， 点击保存后就会到Jenkins即将就绪页面，此时需重启Jenkins，执行命令：</p><pre><code>$ brew services restart jenkins</code></pre><blockquote><p>url重启Jenkins : <a href="http://localhost:8080/restart">http://localhost:8080/restart</a><br>url关闭Jenkins : <a href="http://localhost:8080/exit">http://localhost:8080/exit</a></p></blockquote><h3 id="3-6-完成"><a href="#3-6-完成" class="headerlink" title="3.6 完成"></a>3.6 完成</h3><p>jenkins服务重启后刷新<a href="http://localhost:8080/">http://localhost:8080</a>，就可以看到jenkins的登录页面了<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_login.png"><br>输入账号密码就可以进入Jenkins首页：<br><img src="/images/%E5%B7%A5%E5%85%B7/Jenkins/jenkins_home.png"></p><h2 id="3-安装过程中遇到的问题"><a href="#3-安装过程中遇到的问题" class="headerlink" title="3.安装过程中遇到的问题"></a>3.安装过程中遇到的问题</h2><h3 id="3-1-No-available-formula-with-the-name-quot-java-quot"><a href="#3-1-No-available-formula-with-the-name-quot-java-quot" class="headerlink" title="3.1 No available formula with the name &quot;java&quot; "></a>3.1 <code>No available formula with the name &quot;java&quot; </code></h3><p>执行 <code>brew install java</code>可能会出现以下报错内容：</p><pre><code>$ brew install javaUpdating Homebrew...Error: No available formula with the name &quot;java&quot; ==&gt; Searching for a previously deleted formula (in the last month)...Warning: homebrew/core is shallow clone. To get complete history run:  git -C &quot;$(brew --repo homebrew/core)&quot; fetch --unshallowError: No previously deleted formula found.==&gt; Searching for similarly named formulae...These similarly named formulae were found:app-engine-java               javacc                        jslint4java                   pdftk-javagoogle-java-format            javarepl                      libreadline-javaTo install one of them, run (for example):  brew install app-engine-java==&gt; Searching taps...==&gt; Searching taps on GitHub...Warning: Error searching on GitHub: curl failed!   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed  0     0    0     0    0     0      0      0 --:--:--  0:00:04 --:--:--     0curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to api.github.com:443 Error: No formulae found in taps.</code></pre><p>此代表当前 HomeBrew 版本较低导致安装失败，需update，可执行：</p><pre><code>$ brew update</code></pre><h3 id="3-2-homebrew-core-is-a-shallow-clone"><a href="#3-2-homebrew-core-is-a-shallow-clone" class="headerlink" title="3.2 homebrew-core is a shallow clone"></a>3.2 <code>homebrew-core is a shallow clone</code></h3><p>执行 <code>brew update</code> 可能会出现以下报错：</p><pre><code>$ brew updateError:   homebrew-core is a shallow clone.To `brew update`, first run:  git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallowThis command may take a few minutes to run due to the large size of the repository.This restriction has been made on GitHub&#39;s request because updating shallowclones is an extremely expensive operation due to the tree layout and traffic ofHomebrew/homebrew-core and Homebrew/homebrew-cask. We don&#39;t do this for youautomatically to avoid repeatedly performing an expensive unshallow operation inCI systems (which should instead be fixed to not use shallow clones). Sorry forthe inconvenience!</code></pre><p>解决方法是先执行以下命令再执行 <code>brew update</code>：</p><pre><code>$ rm -rf /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</code></pre><h3 id="3-3-The-following-directories-are-not-writable-by-your-user-usr-local-share-man-man8"><a href="#3-3-The-following-directories-are-not-writable-by-your-user-usr-local-share-man-man8" class="headerlink" title="3.3 The following directories are not writable by your user: /usr/local/share/man/man8"></a>3.3 <code>The following directories are not writable by your user: /usr/local/share/man/man8</code></h3><p>执行 <code>brew install java</code>可能会因为权限问题出现以下报错内容：</p><pre><code>$ brew install javaError: The following directories are not writable by your user:/usr/local/share/man/man8You should change the ownership of these directories to your user.  sudo chown -R $(whoami) /usr/local/share/man/man8And make sure that your user has write permission.  chmod u+w /usr/local/share/man/man8</code></pre><p>解决方法可执行以下命令：</p><pre><code>$ sudo chown -R $(whoami) /usr/local/share/man/man8</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 基础</title>
      <link href="2021/03/10/%E5%B7%A5%E5%85%B7/Git/Git-%E5%9F%BA%E7%A1%80/"/>
      <url>2021/03/10/%E5%B7%A5%E5%85%B7/Git/Git-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取Git仓库"><a href="#1-获取Git仓库" class="headerlink" title="1.获取Git仓库"></a>1.获取Git仓库</h2><p>通常有两种获取 <code>Git</code> 项目仓库的方式：</p><ol><li>本地创建 Git 仓库；</li><li>从其它服务器 <code>克隆</code> 一个已存在的 Git 仓库</li></ol><h3 id="1-1-本地创建-Git-仓库"><a href="#1-1-本地创建-Git-仓库" class="headerlink" title="1.1 本地创建 Git 仓库"></a>1.1 本地创建 Git 仓库</h3><h4 id="1-1-1-创建版本库"><a href="#1-1-1-创建版本库" class="headerlink" title="1.1.1 创建版本库"></a>1.1.1 创建版本库</h4><p>创建版本库很简单，首先，选择一个合适的地方，创建一个空目录：</p><pre><code>mkdir Git仓库目录cd Git仓库目录pwd //显示当前目录</code></pre><p>然后通过 <code>git init</code> 命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/username/Git_Repository/.git/</code></pre><p>这样Git仓库就创建好了，目前还是一个空的仓库，但是该目录下多了一个 <code>.git</code> 目录，这个目录是Git来跟踪管理版本库的，不可随意改动。</p><blockquote><p>如果你没有看到 <code>.git</code> 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p></blockquote><h4 id="1-1-2-本地Git关联远程仓库"><a href="#1-1-2-本地Git关联远程仓库" class="headerlink" title="1.1.2 本地Git关联远程仓库"></a>1.1.2 本地Git关联远程仓库</h4><p>以 <code>GitHub</code> 为例，可以从 GitHub 仓库克隆出新的仓库，也可以关联一个已有的本地仓库，然后将本地仓库的内容推送到 GitHub 仓库。打开本地仓库，执行以下命令来进行关联：</p><pre><code>git remote add origin git@github.com:username/Git_Repository.git</code></pre><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.</code></pre><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。以后只要本地有修改，就可以通过以下命令把本地master分支的最新修改推送至GitHub：</p><pre><code>$ git push origin master</code></pre><blockquote><p>由于远程库是空的，我们第一次推送master分支时，加上了 <code>-u</code> 参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></blockquote><h4 id="1-1-3-删除远程库"><a href="#1-1-3-删除远程库" class="headerlink" title="1.1.3 删除远程库"></a>1.1.3 删除远程库</h4><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用 <code>git remote rm &lt;name&gt;</code> 命令。使用前，建议先用 <code>git remote -v</code> 查看远程库信息：</p><pre><code>$ git remote -vorigin    git@github.com:username/Git_Repository.git (fetch)origin    git@github.com:username/Git_Repository.git (push)</code></pre><p>然后根据名字删除：</p><pre><code>$ git remote rm origin</code></pre><h3 id="1-2-克隆现有的仓库"><a href="#1-2-克隆现有的仓库" class="headerlink" title="1.2 克隆现有的仓库"></a>1.2 克隆现有的仓库</h3><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code>，url为仓库地址，比如：</p><pre><code>git clone https://github.com/libgit2/libgit2</code></pre><blockquote><p>这会在当前目录下创建一个名为 <code>libgit2</code> 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p></blockquote><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><pre><code>git clone https://github.com/libgit2/libgit2 mylibgit</code></pre><p>这会执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p><blockquote><p><code>Git</code> 支持多种数据传输协议。上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 <code>SSH</code> 传输协议，比如 <code>user@server:path/to/repo.git</code>。</p></blockquote><h2 id="2-Git基本操作"><a href="#2-Git基本操作" class="headerlink" title="2.Git基本操作"></a>2.Git基本操作</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h3><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">git init</td><td align="center">初始化仓库</td></tr><tr><td align="center">git clone</td><td align="center">克隆远程仓库</td></tr></tbody></table><h3 id="2-2-提交与修改"><a href="#2-2-提交与修改" class="headerlink" title="2.2 提交与修改"></a>2.2 提交与修改</h3><h4 id="2-2-1-检查当前文件状态"><a href="#2-2-1-检查当前文件状态" class="headerlink" title="2.2.1 检查当前文件状态"></a>2.2.1 检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态，对于没有任何文件修改的仓库执行完命令之后显示<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_0.png"></p><h4 id="2-2-2-跟踪新文件"><a href="#2-2-2-跟踪新文件" class="headerlink" title="2.2.2 跟踪新文件"></a>2.2.2 跟踪新文件</h4><p>新建 <code>_config.yml</code> 文件，执行 <code>git status</code> 之后显示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_1.png"><br>此时代表 <code>_config.yml</code> 文件还未被跟踪，我们使用命令 <code>git add</code> 来跟踪文件，运行：</p><pre><code>git add _config.yml</code></pre><p>然后再执行 <code>git status</code>，就会看到 <code>_config.yml</code> 文件已被跟踪，并处于暂存状态：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_2.png"></p><blockquote><p><code>git add</code> 命令使用文件或目录的路径作为参数</p></blockquote><h4 id="2-2-3-暂存已修改的文件"><a href="#2-2-3-暂存已修改的文件" class="headerlink" title="2.2.3 暂存已修改的文件"></a>2.2.3 暂存已修改的文件</h4><p>修改一个已被跟踪的文件，以 <code>_config.yml</code> 为例，修改之后执行 <code>git status</code> 命令之后，会看到下面内容：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_3.png"><br>暂存这次修改，再次执行 <code>git add</code> 命令。</p><blockquote><p><code>_config.yml</code> 文件同时出现在暂存区 和 非暂存区，但是 <code>git commit</code>时，只会提交最后一次运行 <code>git add</code> 时的版本。</p></blockquote><h4 id="2-2-4-状态预览"><a href="#2-2-4-状态预览" class="headerlink" title="2.2.4 状态预览"></a>2.2.4 状态预览</h4><p><code>git status</code> 命令的输出非常详细，但其用语有些繁琐。可以使用 <code>git status -s</code> 或 <code>git status -short</code> 来进行简洁输出：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_action_status_preview.png"></p><blockquote><p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态:<br><code>??</code> : 新添加的未跟踪文件<br><code>A</code>   : 新添加到暂存区中的文件<br><code>M</code>   : 被修改的文件<br><code>AM</code> : 添加到暂存区之后又有改动</p></blockquote><h4 id="2-2-5-忽略文件"><a href="#2-2-5-忽略文件" class="headerlink" title="2.2.5 忽略文件"></a>2.2.5 忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表，在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略</li><li>可以使用标准的 <code>glob</code> 模式匹配，它会递归地应用在整个工作区中</li><li>匹配模式可以以（<code>/</code>）开头防止递归</li><li>匹配模式可以以（<code>/</code>）结尾指定目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反</li></ul><blockquote><p>所谓的 <code>glob</code> 模式是指 <code>shell</code> 所使用的简化了的正则表达式:<br><code>*</code> : 匹配零个或多个任意字符<br><code>[abc]</code> : 匹配任何一个列在方括号中的字符(要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)<br><code>?</code> : 只匹配一个任意字符<br><code>[0-9]</code> : 匹配所有 <code>0</code> 到 <code>9</code> 的数字<br><code>**</code> : 匹配任意中间目录(比如：<code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等)</p></blockquote><p><code>.gitignore</code> 文件示例：</p><pre><code># 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf</code></pre><h4 id="2-2-6-比较暂存区和工作区的差异"><a href="#2-2-6-比较暂存区和工作区的差异" class="headerlink" title="2.2.6 比较暂存区和工作区的差异"></a>2.2.6 比较暂存区和工作区的差异</h4><p>比较文件在暂存区和工作区的差异，使用命令：</p><pre><code>$ git diff</code></pre><ul><li>查看文件修改之后还没有暂存的变化部分，直接使用命令：<pre><code>$ git diff [file]</code></pre></li><li>显示已暂存文件和上次提交的差异，使用命令：<pre><code>$ git diff --staged或$ git diff --cached</code></pre></li><li>显示两次提交之间的差异，使用命令：<pre><code>$ git diff [first-branch]...[second-branch]</code></pre></li></ul><h4 id="2-2-7-提交更新"><a href="#2-2-7-提交更新" class="headerlink" title="2.2.7 提交更新"></a>2.2.7 提交更新</h4><p>提交暂存区到本地仓库中，命令为：</p><pre><code>$ git commit -m [message] //message为提交log信息</code></pre><p>提交暂存区的指定文件到本地仓库，使用命令：</p><pre><code>git commit [file1] [file2] ... -m [message]</code></pre><p>修改文件后，不执行 <code>git add</code> 命令，直接跳过使用暂存区来提交，使用命令：</p><pre><code>git commit -a -m [message]</code></pre><blockquote><p><code>-a</code> 选项使提交包含了所有修改过的文件，执行时 Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，跳过 <code>git add</code> 步骤。<br>提交之后，发现漏提文件或者提交信息写错了，可以重新提交，使用命令：</p></blockquote><pre><code>git commit -m &quot;message&quot;git add forgotten_filegit commit --amend</code></pre><blockquote><p>最终只会有一个提交——第二次提交将代替第一次提交的结果</p></blockquote><h4 id="2-2-8-移除文件"><a href="#2-2-8-移除文件" class="headerlink" title="2.2.8 移除文件"></a>2.2.8 移除文件</h4><ol><li><p>从工作区删除文件<br>从工作区中移除某个文件，可以直接删除，也可以用 <code>rm</code> 命令删：</p><pre><code>rm [file]</code></pre><p>这只是简单的从工作目录中删除了文件，运行 <code>git status</code> 时就会有 <code>Changes not staged for commit</code> 部分：</p><pre><code>$ rm test.md$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes not staged for commit:(use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)     deleted:    test.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>然后再运行 <code>git rm </code> 记录此次移除文件的操作，然后提交，文件从版本库中被删除：</p><pre><code>$ git rm test.mdrm &#39;test.md&#39;$ git commit -m &quot;remove test.md&quot;[master d46f35e] remove test.md1 file changed, 1 deletion(-)delete mode 100644 test.md</code></pre><blockquote><p>如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>git rm -f [file]</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p></blockquote></li><li><p>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可：</p><pre><code>git rm --cached test.md</code></pre></li></ol><h4 id="2-2-9-移动文件"><a href="#2-2-9-移动文件" class="headerlink" title="2.2.9 移动文件"></a>2.2.9 移动文件</h4><p><code>git mv</code> 命令用于移动或重命名一个文件、目录或软连接:</p><pre><code>$ git mv file_from file_to</code></pre><p><code>git mv</code> 相当于运行了下面三条命令：</p><pre><code>$ mv file_from file_to$ git rm file_from$ git add file_to</code></pre><h4 id="2-2-10-撤销修改"><a href="#2-2-10-撤销修改" class="headerlink" title="2.2.10 撤销修改"></a>2.2.10 撤销修改</h4><p>文件改错或者删除错了，可以把文件从版本库中恢复：</p><pre><code>$ git checkout -- test.md //无论时修改，还是删除，都可以从版本库中还原</code></pre><blockquote><p>从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git --- 入门</title>
      <link href="2021/03/08/%E5%B7%A5%E5%85%B7/Git/Git-%E5%85%A5%E9%97%A8/"/>
      <url>2021/03/08/%E5%B7%A5%E5%85%B7/Git/Git-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于版本控制"><a href="#1-关于版本控制" class="headerlink" title="1.关于版本控制"></a>1.关于版本控制</h2><h3 id="1-1-什么是版本控制"><a href="#1-1-什么是版本控制" class="headerlink" title="1.1 什么是版本控制"></a>1.1 什么是版本控制</h3><p>版本控制是一种记录一个或若干文件(可以是任意类型的文件)内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="1-2-为什么要用版本控制"><a href="#1-2-为什么要用版本控制" class="headerlink" title="1.2 为什么要用版本控制"></a>1.2 为什么要用版本控制</h3><p>在我们的实际开发过程中，经常会有这样的问题：</p><ol><li>多人开发同一个项目，代码合并的问题</li><li>检查某个文件的修改记录（修改人、修改时间、修改内容）</li><li>将项目代码恢复到之前的某个版本</li></ol><h3 id="1-3-历史分类"><a href="#1-3-历史分类" class="headerlink" title="1.3 历史分类"></a>1.3 历史分类</h3><p>纵观版本控制系统的发展历史，<a href="https://ericsink.com/vcbe/index.html">《Version Control By Example》</a>一书的作者 <code>Eric Sink</code> 在他的书中对版本控制进行了分类，广义上讲，版本控制工具的历史可以分为三代：</p><table><thead><tr><th align="center">代</th><th align="center">名称</th><th align="center">网络</th><th align="center">操作</th><th align="center">并发性</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">第一代</td><td align="center">本地版本控制系统</td><td align="center">无</td><td align="center">仅一个文件</td><td align="center">锁定的</td><td align="center">RCS</td></tr><tr><td align="center">第二代</td><td align="center">集中式版本控制系统</td><td align="center">集中式</td><td align="center">多文件</td><td align="center">提交之前合并</td><td align="center">CVS, SourceSafe, Subversion, Team Foundation Server</td></tr><tr><td align="center">第三代</td><td align="center">分布式版本控制系统</td><td align="center">分布式</td><td align="center">变更的集合</td><td align="center">合并之前提交</td><td align="center">Bazaar, Git, Mercurial</td></tr></tbody></table><h4 id="1-3-1-本地版本控制系统"><a href="#1-3-1-本地版本控制系统" class="headerlink" title="1.3.1 本地版本控制系统"></a>1.3.1 本地版本控制系统</h4><p>本地版本控制系统，一次只能有一个人处理文件，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><h4 id="1-3-2-集中式版本控制系统"><a href="#1-3-2-集中式版本控制系统" class="headerlink" title="1.3.2 集中式版本控制系统"></a>1.3.2 集中式版本控制系统</h4><p>集中式版本控制系统，版本库是集中存放在中央服务器的，协同工作的人都是通过客户端连接到这台服务器，取出最新的文件或者提交更新。<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_category_cvcs.png"><br>由上图可看到，在集中式版本控制系统中：</p><ul><li>优点: 不同的开发者可以在不同的电脑上进行协同开发，对同步修改更加宽容</li><li>缺点: 中央服务器的单点故障。如果宕机一小时，那么在这一个小时内，谁都无法提交更新。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，那么将丢失所有数据——包括项目的整个变更历史，只剩下各自机器上保留的单独快照。</li></ul><h4 id="1-3-3-分布式版本控制系统"><a href="#1-3-3-分布式版本控制系统" class="headerlink" title="1.3.3 分布式版本控制系统"></a>1.3.3 分布式版本控制系统</h4><p>分布式版本控制系统，允许合并和提交分开，在每个使用者电脑上都有一个完整的版本库，包括完整的历史记录，没有网络依然可以使用。<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_category_dvcs.png"><br>由上图可看到，分布式式版本控制系统也可以有个服务器端的仓库，用来同步各开发者的私有仓库！在分布式版本控制系统中，每个参与者的本地也会有一个完整的仓库。即使服务器端崩溃，我们仍然可以使用 Git（仅在本地仓库管理我们的代码），在网络具备时，再和服务器进行同步即可！</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><h3 id="2-1-Git起源"><a href="#2-1-Git起源" class="headerlink" title="2.1 Git起源"></a>2.1 Git起源</h3><p>Linus 在1991年创建了开源的 <code>Linux</code>，Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，初期世界各地的志愿者把源代码文件通过 <code>diff</code> 的方式发给Linus，然后由linus 本人通过 <code>linux</code> 命令 <code>diff</code> 和 <code>patch</code> 两条命令手动完成。随着 Linux 代码越来越壮大，靠 Linus 一个人来手动合并已经不现实。2002 年，Linus 选择了一个商业版本控制系统 <code>BitKeeper</code> 作为 Linux 内核的代码管理工具（<code>BitKeeper</code> 的开发商 <code>BitMover</code> 授权 linux 社区免费使用）。但是，免费使用是有很多的限制的，因此 linux 社区的大佬开始破解 <code>BitKeeper</code>。其中，<code>samba</code> 的作者 <code>andrew</code> 破解成功了。但是被 <code>BitMover</code> 公司发现，收回免费使用权。</p><p>迫不得已，Linus 选择了自己开发一个分布式版本控制工具以替代 <code>BitKeeper</code>。linus 闭关一个月，用C写出了 <code>Git</code>。在一个月后，<code>Git</code> 成功接管了 <code>Linux</code> 社区的版本控制工作，并且开始开源。</p><h3 id="2-2-Git简介"><a href="#2-2-Git简介" class="headerlink" title="2.2 Git简介"></a>2.2 Git简介</h3><p><code>Git</code> 是目前世界上最先进的分布式版本控制系统。</p><h4 id="2-2-1-Git特点"><a href="#2-2-1-Git特点" class="headerlink" title="2.2.1 Git特点"></a>2.2.1 Git特点</h4><ol><li>直接记录快照，而不是差异比较:<br> 其他版本控制系统(<code>CVS</code>、<code>Subversion</code>、<code>Perforce</code>、<code>Bazaar</code> 等等)将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异:<br> <img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_cvs_record.png"><br> 在<code>Git</code>中保存项时，它主要对当时的全部文件制作一个快照并保存这个快照的索引，<code>Git</code> 对待数据更像是一个 <code>快照流</code>。<br> <img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_git_record.png"></li><li>近乎所有操作都是本地执行</li><li>Git保证完整性: Git数据库中保存的信息都是以文件内容的哈希值（40个十六进制字符 <code>0-9</code> 和 <code>a-f</code>）来索引，而不是文件名。</li><li>执行的Git操作，只往Git数据库中增加数据，而且Git操作不可逆。</li></ol><h4 id="2-2-2-Git工作区、暂存区和版本库"><a href="#2-2-2-Git工作区、暂存区和版本库" class="headerlink" title="2.2.2 Git工作区、暂存区和版本库"></a>2.2.2 Git工作区、暂存区和版本库</h4><p>Git有三种状态，你的文件有可能处于其中之一：</p><ul><li><code>已提交</code>：表示数据已经安全的保存在本地数据库中</li><li><code>已修改</code>：表示修改了文件，但还没保存到数据库中</li><li><code>已暂存</code>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><p>由此可以引入Git的三个工作区：<br><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_work_zone.png"></p><ul><li><code>工作区</code>：就是你在电脑里能看到的目录</li><li><code>暂存区</code>：英文叫 <code>stage</code> 或 <code>index</code>。一般存放在 <code>.git</code> 目录下的 <code>index</code> 文件 <code>（.git/index）</code>中，所以我们把暂存区有时也叫作索引（index）</li><li><code>版本库</code>：工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 Git 的版本库</li></ul><h4 id="2-2-3-Git工作流程"><a href="#2-2-3-Git工作流程" class="headerlink" title="2.2.3 Git工作流程"></a>2.2.3 Git工作流程</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Git/git_start_git_process.png"><br>一般工作流程如下：</p><ol><li>克隆Git资源作为工作目录</li><li>在工作目录中添加或者修改文件</li><li>如果其他人修改了，你可以更新资源</li><li>在提交前查看修改</li><li>提交修改，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li></ol><h3 id="2-3-Git安装"><a href="#2-3-Git安装" class="headerlink" title="2.3 Git安装"></a>2.3 Git安装</h3><p>Git 本身支持 <code>Mac OS X</code>、<code>Windows</code>、<code>Linux/Unix</code> 这些主流的平台。</p><h4 id="2-3-1-Mac-OS"><a href="#2-3-1-Mac-OS" class="headerlink" title="2.3.1 Mac OS"></a>2.3.1 Mac OS</h4><p>在 Mac 上安装 Git 有多种方式。 最简单的方法是安装 <code>Xcode Command Line Tools</code>。 <code>Mavericks （10.9）</code> 或更高版本的系统中，在 <code>Terminal</code> 里尝试首次运行 git 命令即可:</p><pre><code>git --version</code></pre><p>如果没有安装过命令行开发者工具，将会提示你安装。</p><blockquote><p>还可以通过 <code>homebrew</code> 安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/">http://brew.sh/</a>。</p></blockquote><h3 id="2-4-Git配置"><a href="#2-4-Git配置" class="headerlink" title="2.4 Git配置"></a>2.4 Git配置</h3><p>Git 的配置主要就是 Git 命令 <code>git config</code> 的使用。</p><h4 id="2-4-1-设置用户信息"><a href="#2-4-1-设置用户信息" class="headerlink" title="2.4.1 设置用户信息"></a>2.4.1 设置用户信息</h4><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p><pre><code>$ git config --global user.name &quot;username&quot;$ git config --global user.email username@example.com</code></pre><blockquote><p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p></blockquote><h4 id="2-4-2-检查配置信息"><a href="#2-4-2-检查配置信息" class="headerlink" title="2.4.2 检查配置信息"></a>2.4.2 检查配置信息</h4><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置：</p><pre><code>$ git config --listcredential.helper=osxkeychaincore.excludesfile=/Users/username/.gitignore_globaldifftool.sourcetree.cmd=opendiff &quot;$LOCAL&quot; &quot;$REMOTE&quot;difftool.sourcetree.path=mergetool.sourcetree.cmd=/Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh &quot;$LOCAL&quot; &quot;$REMOTE&quot; -ancestor &quot;$BASE&quot; -merge &quot;$MERGED&quot;mergetool.sourcetree.trustexitcode=trueuser.name=usernameuser.email=email@email.comcommit.template=/Users/username/.stCommitMsghttp.postbuffer=524288000http.lowspeedlimit=0http.lowspeedtime=999999credential.helper=osxkeychaincore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=trueremote.origin.url=git@github.com:username/repository.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=origin</code></pre><p>你可以通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置:</p><pre><code>$ git config user.nameusername</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 主题3-hexo</title>
      <link href="2021/03/07/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E4%B8%BB%E9%A2%983-hexo/"/>
      <url>2021/03/07/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E4%B8%BB%E9%A2%983-hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="1-左侧栏"><a href="#1-左侧栏" class="headerlink" title="1.左侧栏"></a>1.左侧栏</h3><h4 id="1-1-修改左侧栏宽度"><a href="#1-1-修改左侧栏宽度" class="headerlink" title="1.1 修改左侧栏宽度"></a>1.1 修改左侧栏宽度</h4><p>打开 <code>themes/_config.yml</code> 文件中，更改对应代码对应的宽度即可</p><pre><code>width:    lg: 120 # 1468px&lt;屏幕宽度 左侧分类宽度    md: 100 # 1024px&lt;屏幕宽度&lt;=1468px 左侧分类宽度    sm: 100 # 426px&lt;屏幕宽度&lt;=1024px 左侧分类宽度（ipad）</code></pre><h4 id="1-2-修改背景颜色"><a href="#1-2-修改背景颜色" class="headerlink" title="1.2 修改背景颜色"></a>1.2 修改背景颜色</h4><p>打开<code>themes/source/css/_partial/nav-left.styl</code>文件，将<code>.nav_left</code>的<code>background</code>设置成自己喜欢的颜色即可</p><h4 id="1-3-修改图片"><a href="#1-3-修改图片" class="headerlink" title="1.3 修改图片"></a>1.3 修改图片</h4><p><code>themes/source/img</code>文件中，<code>avatar.jpg</code>为头像，<code>weixin.jpg</code>和<code>alipay.jpg</code>分别对应打赏的微信和支付宝收款图片，直接将图片替换为自己的即可 </p><h3 id="2-文章列表栏"><a href="#2-文章列表栏" class="headerlink" title="2.文章列表栏"></a>2.文章列表栏</h3><h4 id="2-1-去除文章列表时间"><a href="#2-1-去除文章列表时间" class="headerlink" title="2.1 去除文章列表时间"></a>2.1 去除文章列表时间</h4><p>打开<code>themes/layout/_partial/nav_right.ejs</code> 文件，将下面代码删除即可</p><pre><code>&lt;span class=&quot;post-date&quot; title=&quot;&lt;%= date(post.date, &#39;YYYY-MM-DD HH:mm:ss&#39;)%&gt;&quot;&gt;&lt;%= date(post.date, &#39;YYYY/MM/DD&#39;) %&gt;&lt;/span&gt;</code></pre><h3 id="3-关于写作"><a href="#3-关于写作" class="headerlink" title="3.关于写作"></a>3.关于写作</h3><h4 id="3-1-字数统计"><a href="#3-1-字数统计" class="headerlink" title="3.1 字数统计"></a>3.1 字数统计</h4><pre><code>npm i --save hexo-wordcount</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 主题安装</title>
      <link href="2021/03/07/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85/"/>
      <url>2021/03/07/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 基本配置</title>
      <link href="2021/03/06/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>2021/03/06/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="1-1-page"><a href="#1-1-page" class="headerlink" title="1.1 page"></a>1.1 page</h4><p>如果新建page页，可以使用</p><pre><code>hexo new page newpage</code></pre><p>系统会自动在<code>source</code>文件夹下创建一个<code>newpage</code>文件夹，以及<code>newpage</code>文件夹中的<code>index.md</code>，这样访问的<code>newpage</code>对应的链接就是<a href="http://xxx.xxx/newpage">http://xxx.xxx/newpage</a></p><h5 id="1-1-1-新建分类categories页"><a href="#1-1-1-新建分类categories页" class="headerlink" title="1.1.1 新建分类categories页"></a>1.1.1 新建分类categories页</h5><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;categories&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code>---title: categoriesdate: 2021-03-03 08:25:30type: &quot;categories&quot;layout: &quot;categories&quot;---</code></pre><h5 id="1-1-2-新建标签tags页"><a href="#1-1-2-新建标签tags页" class="headerlink" title="1.1.2 新建标签tags页"></a>1.1.2 新建标签tags页</h5><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;tags&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code>---title: tagsdate: 2021-03-03 08:25:30type: &quot;tags&quot;layout: &quot;tags&quot;---</code></pre><h5 id="1-1-3-新建关于我about页"><a href="#1-1-3-新建关于我about页" class="headerlink" title="1.1.3 新建关于我about页"></a>1.1.3 新建关于我about页</h5><p><code>about</code> 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page &quot;about&quot;</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code>---title: aboutdate: 2021-03-03 08:25:30type: &quot;about&quot;layout: &quot;about&quot;---</code></pre><h5 id="1-1-4-添加404页面"><a href="#1-1-4-添加404页面" class="headerlink" title="1.1.4 添加404页面"></a>1.1.4 添加404页面</h5><p>原来的主题没有<code>404</code>页面，我们加一个。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><pre><code>title: 404date: 2019-08-5 16:41:10type: &quot;404&quot;layout: &quot;404&quot;description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;</code></pre><p>网上好多都说要在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件(注：我安装的主题在该目录下已有<code>404.ejs</code>文件，无需自己创建)</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    /* don&#39;t remove. */    .about-cover &#123;        height: 75vh;    &#125;&lt;/style&gt;&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;                &lt;div class=&quot;brand&quot;&gt;                    &lt;div class=&quot;title center-align&quot;&gt;                        404                    &lt;/div&gt;                    &lt;div class=&quot;description center-align&quot;&gt;                        &lt;%= page.description %&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // 每天切换 banner 图.  Switch banner image every day.    $(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);&lt;/script&gt;</code></pre><h4 id="1-2-文章"><a href="#1-2-文章" class="headerlink" title="1.2 文章"></a>1.2 文章</h4><h5 id="1-2-1-创建文章模版"><a href="#1-2-1-创建文章模版" class="headerlink" title="1.2.1 创建文章模版"></a>1.2.1 创建文章模版</h5><p>为了新建文章方便，我们可以修改一下文章模板，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre><code>---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:tags:categories:---</code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，修改对应信息就可以了</p><h5 id="1-2-2-Front-matter"><a href="#1-2-2-Front-matter" class="headerlink" title="1.2.2 Front-matter"></a>1.2.2 Front-matter</h5><p><code>Front-matter</code> 选项中的所有内容均为非必填的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值</p><table><thead><tr><th align="center">配置选项</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">Markdown的文件标题</td><td align="center">文章标题</td></tr><tr><td align="center">date</td><td align="center">文件创建时的日期时间</td><td align="center">发布时间</td></tr><tr><td align="center">author</td><td align="center">根 <code>_config.yml</code> 中的 <code>author</code></td><td align="center">文章作者</td></tr><tr><td align="center">img</td><td align="center"><code>featureImages</code> 中的某个值</td><td align="center">文章特征图</td></tr><tr><td align="center">top</td><td align="center"><code>true</code></td><td align="center">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="center">cover</td><td align="center"><code>false</code></td><td align="center">表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="center">coverImg</td><td align="center">无</td><td align="center">表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="center">password</td><td align="center">无</td><td align="center">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="center">toc</td><td align="center"><code>true</code></td><td align="center">是否开启 <code>TOC</code>，可以针对某篇文章单独关闭 <code>TOC</code> 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="center">mathjax</td><td align="center"><code>false</code></td><td align="center">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="center">summary</td><td align="center">无</td><td align="center">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="center">categories</td><td align="center">无</td><td align="center">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="center">tags</td><td align="center">无</td><td align="center">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p>注意：</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code> 加密的 <code>password</code> 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 <code>SHA256</code> 加密的地址，可供使用：开源中国在线工具、chahuo、站长工具。</li></ol></blockquote><h5 id="1-2-3-文章添加图片"><a href="#1-2-3-文章添加图片" class="headerlink" title="1.2.3 文章添加图片"></a>1.2.3 文章添加图片</h5>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 --- 环境搭建</title>
      <link href="2021/03/06/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2021/03/06/%E5%B7%A5%E5%85%B7/Hexo/Hexo%E5%8D%9A%E5%AE%A2---%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于博客"><a href="#1-关于博客" class="headerlink" title="1.关于博客"></a>1.关于博客</h2><p>常见的写博客的途径有：</p><ul><li><code>借助平台</code>，比如掘金、CSDN、博客园、简书、有道云笔记等，这些平台的用户交互做的很好，但是缺乏个性化，有的更甚至需要购买会员，才能解锁所有功能。</li><li><code>自己购买域名和服务器</code>，虽然完全可以按照自己的想法来搭建，但是搭建成本比较高，还需要定期去维护，对于大多数来说，一可能没有这样的精力和时间，二没有这样的技术能力。</li><li><code>开源框架+GitHub</code>，这种方式就比较方便了，不用我们自己维护更新，网上有很多的搭建和个性化定制博客的教程，我们按照教程就可以慢慢搭建成我们自己想要的博客。</li></ul><blockquote><p>之前写文章用的比较多的是印象笔记，较早时候感觉印象笔记还是挺好的，但是随着后来自己要求的慢慢变高，就觉得印象笔记里面编辑出来的文章样式不满足自己的需求，再加上创建带目录的文章竟然需要购买会员。然后就萌生自己搭建博客的想法，然后就从网上查了相关资料和介绍，在前人的基础上搭建了一个简单的博客(<code>Hexo+GitHub</code>)</p></blockquote><p>本篇博客旨在记录自己的搭建过程，方便以后的查看和修改，当然还有一些优化项和功能后续会慢慢更新。</p><h2 id="2-关于Hexo"><a href="#2-关于Hexo" class="headerlink" title="2.关于Hexo"></a>2.关于Hexo</h2><p><a href="https://hexo.io/zh-cn/">Hexo</a>基于<code>Node.js</code>，使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，可利用靓丽的主题生成静态网页，而且只需两三条命令即可将生成的网页上传到<code>github</code>等代码管理托管平台，简单、快速，是搭建博客的首选框架。</p><blockquote><p><code>Hexo</code>的作者是来自台湾的 <a href="https://zespia.tw/">Tommy Chen</a>，对中文的支持很友好，可以选择中文进行查看。</p></blockquote><p>Hexo特点:</p><ul><li>部署方便并且速度</li><li>支持 <code>Markdown</code>语法</li><li>使用极简命令即可部署到<code>GitHub Pages</code></li><li>高扩展性、可个性化定制</li><li>兼容于 <code>Windows</code>, <code>Mac</code> &amp; <code>Linux</code></li></ul><h2 id="3-搭建"><a href="#3-搭建" class="headerlink" title="3.搭建"></a>3.搭建</h2><p>本人使用Mac电脑，以此只记录了Mac电脑下的搭建过程</p><h3 id="3-1-安装Git"><a href="#3-1-安装Git" class="headerlink" title="3.1 安装Git"></a>3.1 安装Git</h3><p>什么是<code>Git</code>？关于<code>Git</code>，廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a>讲的特别好，大家可以去看看，也可以直接查看 <a href="https://git-scm.com/book/zh/v2">Git官网 Pro Git Book</a>中的讲解。而我们为了把本地的网页文件上传到<code>github</code>上面去，需要用到分布式版本控制工具<code>Git</code>。</p><p>在 <code>Mac</code> 上安装 <code>Git</code> 有多种方式。最简单的方法是安装 <code>Xcode Command Line Tools</code>。 Mavericks（10.9）或更高版本的系统中，在 <code>Terminal</code> 里尝试首次运行 <code>git</code> 命令即可。</p><pre><code>$ git --version</code></pre><p>如果没有安装过命令行开发者工具，将会提示你安装。</p><p>如果你想安装更新的版本，可以使用二进制安装程序。 官方维护的 macOS Git 安装程序可以在 Git 官方网站下载，网址为 <a href="https://git-scm.com/download/mac%E3%80%82">https://git-scm.com/download/mac。</a></p><pre><code>git --version</code></pre><blockquote><p>如果你想安装更新的版本，可以使用二进制安装程序。官方维护的 <code>macOS Git</code> 安装程序可以在 <code>Git</code> 官方网站下载，网址为 <a href="https://git-scm.com/download/mac">https://git-scm.com/download/mac</a></p></blockquote><h3 id="3-2-安装Node-js"><a href="#3-2-安装Node-js" class="headerlink" title="3.2 安装Node.js"></a>3.2 安装Node.js</h3><p>打开 <a href="https://nodejs.org/en/download/">Node.js</a> 下载页面，直接选择 <code>macOS Installer</code> 下载，然后双击已下载的<code>pkg</code>文件安装即可。<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_node_js_download.png"><br>安装完成之后，可通过以下命令来检查是否安装成功:</p><pre><code>node -v</code></pre><h3 id="3-3-安装Hexo"><a href="#3-3-安装Hexo" class="headerlink" title="3.3 安装Hexo"></a>3.3 安装Hexo</h3><p>安装完 <code>Git</code> 和 <code>Node.js</code>之后，即可使用 <code>npm</code> 安装 <code>Hexo</code>。终端输入如下命令：</p><pre><code>sudo npm install -g hexo-cli</code></pre><p>安装完成之后输入 <code>hexo -v</code> 验证是否安装成功。</p><blockquote><p>Hexo官网上的安装命令是 <code>npm install -g hexo-cli</code>，但是实际安装的时候需要加上 <code>sudo</code>，否则会因为权限问题报错而导致安装失败</p></blockquote><h4 id="3-3-1-初始化"><a href="#3-3-1-初始化" class="headerlink" title="3.3.1 初始化"></a>3.3.1 初始化</h4><p>使用终端 <code>cd</code> 到一个文件目录，执行以下命令（命令中的 <code>Blog</code> 是要创建的博客文件夹）:</p><pre><code>hexo init Blog</code></pre><p>使用终端 <code>cd</code> 到 <code>Blog</code> 文件夹下，执行以下命令，安装必备的组件：</p><pre><code>cd Blognpm install</code></pre><p>安装完成之后，<code>Blog</code> 目录下有：</p><ul><li><code>node_modules</code>: 依赖包</li><li><code>public</code>: 存放生成的页面</li><li><code>scaffolds</code>: 生成文章的一些模板</li><li><code>source</code>: 用来存放你的文章</li><li><code>themes</code>: 安装的主题</li><li><code>_config.yml</code>: 博客的配置文件</li></ul><h4 id="3-3-2-本地预览"><a href="#3-3-2-本地预览" class="headerlink" title="3.3.2 本地预览"></a>3.3.2 本地预览</h4><p>经过上面步骤之后，基本的博客系统就已经搭建好了，而且自带了 <code>landscape</code> 主题，执行如下命令，开启本地 <code>Hexo</code> 服务器:</p><pre><code>sudo npm install hexo-server  //安装hexo serverhexo generate //或者 hexo g，生成静态页面hexo server //或者 hexo s，本地预览</code></pre><p>然后浏览器打开<a href="http://localhost:4000/">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_blog_preview.png"></p><h3 id="3-4-将Hexo部署到GitHub-Pages"><a href="#3-4-将Hexo部署到GitHub-Pages" class="headerlink" title="3.4 将Hexo部署到GitHub Pages"></a>3.4 将Hexo部署到GitHub Pages</h3><h4 id="3-4-1-创建仓库"><a href="#3-4-1-创建仓库" class="headerlink" title="3.4.1 创建仓库"></a>3.4.1 创建仓库</h4><p>登录 <a href="https://github.com/">GitHub</a> 账号，新建名称为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 的仓库，具体如下图所示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_creat.png"></p><h4 id="3-4-2-开启GitHub-Pages"><a href="#3-4-2-开启GitHub-Pages" class="headerlink" title="3.4.2 开启GitHub Pages"></a>3.4.2 开启GitHub Pages</h4><p><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_setting.png"><br>点击 <code>setting</code> ,打开创建的仓库的设置页面，滑动到 <code>GitHub Pages</code> 位置，进行如下设置，这样才能通过 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>来访问<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_repository_pages.png"></p><h4 id="3-4-3-生成SSH添加到GitHub"><a href="#3-4-3-生成SSH添加到GitHub" class="headerlink" title="3.4.3 生成SSH添加到GitHub"></a>3.4.3 生成SSH添加到GitHub</h4><p><code>GitHub</code> 使用 <code>SSH</code> 公钥进行认证，关于 <code>SSH</code> 相关内容可以直接查看另一篇博客<a href="2021/03/07/%E5%B7%A5%E5%85%B7/Terminal/Terminal---%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5">Terminal—生成SSH公钥</a></p><p>在 <code>GitHub</code> 中，点击头像打开 <code>Setting</code> 页面，将 <code>SSH</code> 添加到 <code>SSH and GPG keys</code>中，如下图所示：<br><img src="/images/%E5%B7%A5%E5%85%B7/Hexo/hexo_github_ssh.png"><br>然后在终端输入 <code>ssh -T git@github.com</code>，如果出现 <code>Hi xxx! You&#39;ve successfully authenticated...</code>，那么恭喜你，添加成功了。</p><h4 id="3-4-4-将Hexo部署到GitHub-Pages"><a href="#3-4-4-将Hexo部署到GitHub-Pages" class="headerlink" title="3.4.4 将Hexo部署到GitHub Pages"></a>3.4.4 将Hexo部署到GitHub Pages</h4><p>打开 <code>Blog</code> 根目录下的 <code>_config.yml</code> 文件，这是博客的配置文件，在这里可以修改博客配置的各种相关信息，修改 <code>deploy</code> 相关信息如下：</p><pre><code>deploy:  type: git  repository: https://github.com/xxx/xxx.github.io.git //此地址为自己github的仓库地址  branch: master</code></pre><blockquote><p>修改 <code>_config.yml</code> 文件时，所有的冒号 <code>:</code> 后面都要加一个空格，否则执行命令时会报错。</p></blockquote><p>配置之后，<code>Hexo</code> 和 <code>GitHub</code> 就能关联起来，部署时，就可以将生成的静态网页上传到上面填写的仓库中。</p><p>然后就可以通过下面命令，将本地 <code>Hexo</code> 博客部署到 <code>GitHub</code> 上：</p><pre><code>npm install hexo-deployer-git --save //安装 deploy-githexo clean  //清除之前生成的静态文件hexo g  //生成静态页面至public目录hexo d  //将.deploy目录部署到GitHub</code></pre><p>至此博客已部署完成，可以通过 <code>https://xxx.github.io/</code> 来访问你的博客啦！！！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
